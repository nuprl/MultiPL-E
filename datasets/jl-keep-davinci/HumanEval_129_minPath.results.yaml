name: HumanEval_129_minPath
language: julia
results:
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2xpz9sh_.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xpz9sh_.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xpz9sh_.jl:32\n   [2] top-level scope at /tmp/tmp2xpz9sh_.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xpz9sh_.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2xpz9sh_.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code goes here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpmdg2spdd.jl:39\\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpmdg2spdd.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:40\\\
    n  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n   Evaluated:\
    \ Int64[] == [1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpmdg2spdd.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:41\\\
    n  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpmdg2spdd.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:42\\\
    n  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpmdg2spdd.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:43\\\
    n  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpmdg2spdd.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:44\\\
    n  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpmdg2spdd.jl:44\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:45\\\
    n  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmpmdg2spdd.jl:45\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:46\\\
    n  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpmdg2spdd.jl:46\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:47\\\
    n  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpmdg2spdd.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:48\\\
    n  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpmdg2spdd.jl:48\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\ntest set: Test Failed at /tmp/tmpmdg2spdd.jl:49\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpmdg2spdd.jl:49\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmdg2spdd.jl:38\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t\
    @test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_bzup993.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_bzup993.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp_bzup993.jl:32\\n   [2] top-level scope at /tmp/tmp_bzup993.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_bzup993.jl:37\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp67dp4vi5.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp67dp4vi5.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp67dp4vi5.jl:32\n   [2] top-level scope at /tmp/tmp67dp4vi5.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp67dp4vi5.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp67dp4vi5.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt4hz2fyr.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpt4hz2fyr.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # The following is a dictionary that maps a cell\
    \ to the list of its neighbors.\n    # For example, neighbors[(1, 2)] = [(1, 1),\
    \ (2, 2), (1, 3)]\n    neighbors = Dict{Tuple{Int64, Int64}, Vector{Tuple{Int64,\
    \ Int64}}}()\n    for i in 1:N\n        for j in 1:N\n            neighbors[(i,\
    \ j)] = []\n            if i > 1\n                push!(neighbors[(i, j)], (i\
    \ - 1, j))\n            end\n            if i < N\n                push!(neighbors[(i,\
    \ j)], (i + 1, j))\n            end\n            if j > 1\n                push!(neighbors[(i,\
    \ j)], (i, j - 1))\n            end\n            if j < N\n                push!(neighbors[(i,\
    \ j)], (i, j + 1))\n            end\n        end\n    end\n    # The following\
    \ is a dictionary that maps a cell to its value.\n    # For example, values[(1,\
    \ 2)] = 2\n    values = Dict{Tuple{Int64, Int64}, Int64}()\n    for i in 1:N\n\
    \        for j in 1:N\n            values[(i, j)] = grid[i][j]\n        end\n\
    \    end\n    # The following is a dictionary that maps a cell to the minimum\
    \ path that\n    # starts from that cell and has length k.\n    # For example,\
    \ min_paths[(1, 2)] = [1, 2, 1]\n    min_paths = Dict{Tuple{Int64, Int64}, Vector{Int64}}()\n\
    \    for i in 1:N\n        for j in 1:N\n            min_paths[(i, j)] = [values[(i,\
    \ j)]]\n        end\n    end\n    # The following is a dictionary that maps a\
    \ cell to the minimum path that\n    # starts from that cell and has length k\
    \ - 1.\n    # For example, min_paths[(1, 2)] = [1, 2]\n    min_paths_\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp13n0koax.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp13n0koax.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp13n0koax.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # The following is the key to the problem.\n   \
    \ # We need to find the minimum path of length k in the grid.\n    # We can start\
    \ from any cell, and in each step we can move to any of the neighbor cells.\n\
    \    # We can go to cells which share an edge with you current cell.\n    # We\
    \ CANNOT go off the grid.\n    # A path A (of length k) is considered less than\
    \ a path B (of length k) if\n    # after making the ordered lists of the values\
    \ on the cells that A and B go\n    # through (let's call them lst_A and lst_B),\
    \ lst_A is lexicographically less\n    # than lst_B, in other words, there exist\
    \ an integer index i (1 <= i <= k)\n    # such that lst_A[i] < lst_B[i] and for\
    \ any j (1 <= j < i) we have\n    # lst_A[j] = lst_B[j].\n    # It is guaranteed\
    \ that the answer is unique.\n    # Return an ordered list of the values on the\
    \ cells that the minimum path go through.\n    #\n    # The following is the key\
    \ to the problem.\n    # We need to find the minimum path of length k in the grid.\n\
    \    # We can start from any cell, and in each step we can move to any of the\
    \ neighbor cells.\n    # We can go to cells which share an edge with you current\
    \ cell.\n    # We CANNOT go off the grid.\n    # A path A (of length k) is considered\
    \ less than a path B (of length k) if\n    # after making the ordered lists of\
    \ the values on the cells that A and B go\n    # through (let's call them lst_A\
    \ and lst_B), lst_A is lexicographically less\n    # than lst_B, in other words,\
    \ there exist an integer index i (1 <= i <= k)\n    # such that lst_A[i] < lst_B[i]\
    \ and for any j (1 <= j < i) we have\n    # lst_A[j] = lst_B[j].\n    # It is\
    \ guaranteed that the answer is unique\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvpu5m586.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpvpu5m586.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpvpu5m586.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    min_path = Vector{Int64}(undef, k)\n    min_path[1]\
    \ = grid[1, 1]\n    for i in 2:k\n        min_path[i] = grid[1, 1]\n        for\
    \ j in 1:i-1\n            if min_path[j] < min_path[i]\n                min_path[i]\
    \ = min_path[j]\n            end\n        end\n    end\n    return min_path\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprksawfbk.jl:49\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmprksawfbk.jl:33\n   [3] top-level scope at /tmp/tmprksawfbk.jl:49\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:50\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmprksawfbk.jl:33\n\
    \   [3] top-level scope at /tmp/tmprksawfbk.jl:50\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:51\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmprksawfbk.jl:33\n   [3] top-level scope at /tmp/tmprksawfbk.jl:51\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:52\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmprksawfbk.jl:33\n   [3] top-level scope at /tmp/tmprksawfbk.jl:52\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:53\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmprksawfbk.jl:33\n   [3] top-level scope at /tmp/tmprksawfbk.jl:53\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:54\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmprksawfbk.jl:33\n   [3] top-level scope at /tmp/tmprksawfbk.jl:54\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:55\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Array{Int64,1} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmprksawfbk.jl:33\n   [3] top-level scope at /tmp/tmprksawfbk.jl:55\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:56\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1}, ::Array{Int64,1},\
    \ ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprksawfbk.jl:33\n   [3] top-level scope at /tmp/tmprksawfbk.jl:56\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:57\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1}, ::Array{Int64,1},\
    \ ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprksawfbk.jl:33\n   [3] top-level scope at /tmp/tmprksawfbk.jl:57\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:58\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmprksawfbk.jl:33\n\
    \   [3] top-level scope at /tmp/tmprksawfbk.jl:58\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmprksawfbk.jl:59\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmprksawfbk.jl:33\n\
    \   [3] top-level scope at /tmp/tmprksawfbk.jl:59\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmprksawfbk.jl:48\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprksawfbk.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    @assert 1 <= k <= n * n\n    @assert n >= 2\n  \
    \  @assert length(grid[1]) == n\n    @assert length(unique(grid)) == n * n\n \
    \   @assert all(1 <= grid[i][j] <= n * n for i in 1:n, j in 1:n)\n    # your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzfoiaoz6.jl:44\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  AssertionError: length(unique(grid)) == n * n\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpzfoiaoz6.jl:35\n   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:44\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:45\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  AssertionError: length(unique(grid))\
    \ == n * n\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpzfoiaoz6.jl:35\n   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:45\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:46\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  AssertionError: length(unique(grid)) == n * n\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpzfoiaoz6.jl:35\n   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:46\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:47\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  AssertionError: length(unique(grid)) == n * n\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpzfoiaoz6.jl:35\n\
    \   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:48\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  AssertionError: length(unique(grid)) == n * n\n  Stacktrace:\n   [1]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpzfoiaoz6.jl:35\n   [2]\
    \ top-level scope at /tmp/tmpzfoiaoz6.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:49\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  AssertionError: length(unique(grid)) == n * n\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpzfoiaoz6.jl:35\n\
    \   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:50\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  AssertionError: length(unique(grid)) == n * n\n\
    \  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpzfoiaoz6.jl:35\n\
    \   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:51\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  AssertionError:\
    \ length(unique(grid)) == n * n\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpzfoiaoz6.jl:35\n   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:52\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  AssertionError:\
    \ length(unique(grid)) == n * n\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpzfoiaoz6.jl:35\n   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:53\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  AssertionError: 1 <= k\
    \ <= n * n\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpzfoiaoz6.jl:32\n   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfoiaoz6.jl:54\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  AssertionError: 1 <= k\
    \ <= n * n\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpzfoiaoz6.jl:32\n   [2] top-level scope at /tmp/tmpzfoiaoz6.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfoiaoz6.jl:43\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzfoiaoz6.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphabquen2.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmphabquen2.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmphabquen2.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphabquen2.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmphabquen2.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphabquen2.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmphabquen2.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmphabquen2.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphabquen2.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphabquen2.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmphabquen2.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\ntest set: Test Failed at /tmp/tmphabquen2.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmphabquen2.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphabquen2.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphabquen2.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdkf5pme4.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdkf5pme4.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n\
    \    # create a graph\n    g = Graph(n * n)\n    for i in 1:n\n        for j in\
    \ 1:n\n            if i > 1\n                add_edge!(g, (i - 1) * n + j, i *\
    \ n + j)\n            end\n            if i < n\n                add_edge!(g,\
    \ (i + 1) * n + j, i * n + j)\n            end\n            if j > 1\n       \
    \         add_edge!(g, i * n + j - 1, i * n + j)\n            end\n          \
    \  if j < n\n                add_edge!(g, i * n + j + 1, i * n + j)\n        \
    \    end\n        end\n    end\n    # find the shortest path\n    sp = dijkstra_shortest_paths(g,\
    \ 1)\n    # find the minimum path\n    min_path = []\n    for i in 1:n\n     \
    \   for j in 1:n\n            if sp.dists[i * n + j] == k\n                push!(min_path,\
    \ grid[i,j])\n            end\n        end\n    end\n    return sort(min_path)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4qit9cfk.jl:74\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  UndefVarError: Graph not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp4qit9cfk.jl:39\n   [2] top-level scope at /tmp/tmp4qit9cfk.jl:74\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:75\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{Int64,1}(::Array{Array{Int64,1},1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp4qit9cfk.jl:33\n   [6] top-level scope at /tmp/tmp4qit9cfk.jl:75\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:76\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  UndefVarError: Graph not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp4qit9cfk.jl:39\n   [2] top-level scope at /tmp/tmp4qit9cfk.jl:76\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:77\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  UndefVarError: Graph not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp4qit9cfk.jl:39\n   [2] top-level scope at /tmp/tmp4qit9cfk.jl:77\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:78\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  UndefVarError: Graph not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp4qit9cfk.jl:39\n   [2] top-level scope at /tmp/tmp4qit9cfk.jl:78\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:79\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  UndefVarError: Graph not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp4qit9cfk.jl:39\n   [2] top-level scope at /tmp/tmp4qit9cfk.jl:79\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:80\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  UndefVarError: Graph not defined\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp4qit9cfk.jl:39\n\
    \   [2] top-level scope at /tmp/tmp4qit9cfk.jl:80\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:81\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError:\
    \ Graph not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp4qit9cfk.jl:39\n   [2] top-level scope at /tmp/tmp4qit9cfk.jl:81\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:82\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  UndefVarError:\
    \ Graph not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp4qit9cfk.jl:39\n   [2] top-level scope at /tmp/tmp4qit9cfk.jl:82\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:83\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  UndefVarError: Graph not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4qit9cfk.jl:39\n   [2] top-level scope at /tmp/tmp4qit9cfk.jl:83\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qit9cfk.jl:84\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError: Graph not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4qit9cfk.jl:39\n   [2] top-level scope at /tmp/tmp4qit9cfk.jl:84\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qit9cfk.jl:73\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4qit9cfk.jl:71\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp653sztdb.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp653sztdb.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp653sztdb.jl:32\\n   [2] top-level scope at /tmp/tmp653sztdb.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp653sztdb.jl:37\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfor2l8g0.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfor2l8g0.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp283gupaf.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp283gupaf.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp0d9a7d8_.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d9a7d8_.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp0d9a7d8_.jl:32\\n   [2] top-level scope at /tmp/tmp0d9a7d8_.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d9a7d8_.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp6d7731q6.jl:39\\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6d7731q6.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:40\\\
    n  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n   Evaluated:\
    \ Int64[] == [1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6d7731q6.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:41\\\
    n  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp6d7731q6.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:42\\\
    n  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6d7731q6.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:43\\\
    n  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp6d7731q6.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:44\\\
    n  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6d7731q6.jl:44\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:45\\\
    n  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmp6d7731q6.jl:45\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:46\\\
    n  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp6d7731q6.jl:46\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:47\\\
    n  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp6d7731q6.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:48\\\
    n  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp6d7731q6.jl:48\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\ntest set: Test Failed at /tmp/tmp6d7731q6.jl:49\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp6d7731q6.jl:49\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6d7731q6.jl:38\\nTest Summary: | Fail  Total\\\
    ntest set      |   11     11\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # Create a graph with N*N nodes\n    g = Graph(N*N)\n\
    \    # Add edges between nodes\n    for i in 1:N\n        for j in 1:N\n     \
    \       if i > 1\n                add_edge!(g, (i-1)*N+j, i*N+j)\n           \
    \ end\n            if i < N\n                add_edge!(g, (i-1)*N+j, i*N+j)\n\
    \            end\n            if j > 1\n                add_edge!(g, (i-1)*N+j,\
    \ (i-1)*N+j-1)\n            end\n            if j < N\n                add_edge!(g,\
    \ (i-1)*N+j, (i-1)*N+j+1)\n            end\n        end\n    end\n    # Create\
    \ a dictionary to map nodes to grid values\n    node_to_val = Dict()\n    for\
    \ i in 1:N\n        for j in 1:N\n            node_to_val[(i-1)*N+j] = grid[i][j]\n\
    \        end\n    end\n    # Create a dictionary to map grid values to nodes\n\
    \    val_to_node = Dict()\n    for i in 1:N\n        for j in 1:N\n          \
    \  val_to_node[grid[i][j]] = (i-1)*N+j\n        end\n    end\n    # Create a dictionary\
    \ to map nodes to grid coordinates\n    node_to_coord = Dict()\n    for i in 1:N\n\
    \        for j in 1:N\n            node_to_coord[(i-1)*N+j] = (i, j)\n       \
    \ end\n    end\n    # Create a dictionary to map grid coordinates to nodes\n \
    \   coord_to_node = Dict()\n    for i in 1:N\n        for j in 1:N\n         \
    \   coord_to_node[(i, j)] = (i-1)*N+j\n        end\n    end\n    # Create a dictionary\
    \ to map grid coordinates to grid values\n    coord_to_val = Dict()\n    for i\
    \ in 1:N\n        for j in 1:N\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmp3w8mhwfo.jl:82\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp3w8mhwfo.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp3w8mhwfo.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return grid\n    end\n    if k <= n\n        return\
    \ grid[1:k, 1]\n    end\n    if k <= 2 * n\n        return grid[1:n, 1]\n    end\n\
    \    if k <= 3 * n\n        return grid[1:n, 1]\n    end\n    if k <= 4 * n\n\
    \        return grid[1:n, 1]\n    end\n    if k <= 5 * n\n        return grid[1:n,\
    \ 1]\n    end\n    if k <= 6 * n\n        return grid[1:n, 1]\n    end\n    if\
    \ k <= 7 * n\n        return grid[1:n, 1]\n    end\n    if k <= 8 * n\n      \
    \  return grid[1:n, 1]\n    end\n    if k <= 9 * n\n        return grid[1:n, 1]\n\
    \    end\n    if k <= 10 * n\n        return grid[1:n, 1]\n    end\n    if k <=\
    \ 11 * n\n        return grid[1:n, 1]\n    end\n    if k <= 12 * n\n        return\
    \ grid[1:n, 1]\n    end\n    if k <= 13 * n\n        return grid[1:n, 1]\n   \
    \ end\n    if k <= 14 * n\n        return grid[1:n, 1]\n    end\n    if k <= 15\
    \ * n\n        return grid[1:n, 1]\n    end\n    if k <= 16 * n\n        return\
    \ grid[1:n, 1]\n    end\n    if k <= 17 * n\n        return grid[1:n, 1]\n   \
    \ end\n    if k <= 18 * n\n        return grid[1:n, 1]\n    end\n    if k <= 19\
    \ * n\n        return grid[1:n, 1]\n    end\n    if k <= 20 * n\n        return\
    \ grid[1:n, 1]\n    end\n    if k <= 21 * n\n        return grid[1:n, 1]\n   \
    \ end\n    if k <= 22 * n\n       \nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe1lqxyvf.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe1lqxyvf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmph37a8_ty.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmph37a8_ty.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmph37a8_ty.jl:32\\n   [2] top-level scope at /tmp/tmph37a8_ty.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmph37a8_ty.jl:37\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxi5x8v6z.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxi5x8v6z.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxi5x8v6z.jl:32\n   [2] top-level scope at /tmp/tmpxi5x8v6z.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxi5x8v6z.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxi5x8v6z.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwisyhikf.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwisyhikf.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwisyhikf.jl:32\n   [2] top-level scope at /tmp/tmpwisyhikf.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwisyhikf.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwisyhikf.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\nend\n\"\"\"\n    Given a grid with N rows and\
    \ N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains\
    \ a value. Every integer in the range [1, N * N]\n    inclusive appears exactly\
    \ once on the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm7ml6yk6.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpm7ml6yk6.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8i7f6aj5.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i7f6aj5.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp8i7f6aj5.jl:32\\n   [2] top-level scope at /tmp/tmp8i7f6aj5.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i7f6aj5.jl:37\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n*n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n\
    \    if k > n*n\n        return []\n    end\n    if k == n\n        return [grid[i,1]\
    \ for i in 1:n]\n    end\n    if k == 2*n-1\n        return [grid[i,1] for i in\
    \ 1:n]\n    end\n    if k == 2*n\n        return [grid[i,1] for i in 1:n]\n  \
    \  end\n    if k == 2*n+1\n        return [grid[i,1] for i in 1:n]\n    end\n\
    \    if k == 3*n-2\n        return [grid[i,1] for i in 1:n]\n    end\n    if k\
    \ == 3*n-1\n        return [grid[i,1] for i in 1:n]\n    end\n    if k == 3*n\n\
    \        return [grid[i,1] for i in 1:n]\n    end\n    if k == 3*n+1\n       \
    \ return [grid[i,1] for i in 1:n]\n    end\n    if k == 3*n+2\n        return\
    \ [grid[i,1] for i in 1:n]\n    end\n    if k == 4*n-3\n        return [grid[i,1]\
    \ for i in 1:n]\n    end\n    if k == 4*n-2\n        return [grid[i,1] for i in\
    \ 1:n]\n    end\n    if k == 4*n-1\n        return [grid[i,1] for i in 1:n]\n\
    \    end\n    if k == 4*n\n        return [grid[i,1] for i in 1:n]\n    end\n\
    \    if k == 4*n+1\n        return [grid[i,1] for i in 1:n]\n    end\n    if k\
    \ == 4*n+2\n        return [grid[i,1] for i in 1:n\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: expected \"]\"\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmp7gxazrj8.jl:85\n [2] include(::Module, ::String) at ./Base.jl:377\n\
    \ [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4] _start() at ./client.jl:484\n\
    in expression starting at /tmp/tmp7gxazrj8.jl:85\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpm17kld_r.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm17kld_r.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm17kld_r.jl:32\\n   [2] top-level scope at /tmp/tmpm17kld_r.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm17kld_r.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    11     11\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpju2gldzf.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpju2gldzf.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpju2gldzf.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpju2gldzf.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpju2gldzf.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpju2gldzf.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpju2gldzf.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpju2gldzf.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpju2gldzf.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpju2gldzf.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpju2gldzf.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\ntest set: Test Failed at /tmp/tmpju2gldzf.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpju2gldzf.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpju2gldzf.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpju2gldzf.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    m = length(grid[1])\n    if k == 1\n        return\
    \ [grid[1,1]]\n    end\n    if k == n * m\n        return [grid[i,j] for i in\
    \ 1:n, j in 1:m]\n    end\n    if k > n * m\n        return []\n    end\n    if\
    \ k < n\n        return [grid[i,1] for i in 1:k]\n    end\n    if k < m\n    \
    \    return [grid[1,j] for j in 1:k]\n    end\n    if k == n\n        return [grid[i,1]\
    \ for i in 1:n]\n    end\n    if k == m\n        return [grid[1,j] for j in 1:m]\n\
    \    end\n    if k == n + m - 1\n        return [grid[i,1] for i in 1:n] .* [grid[1,j]\
    \ for j in 1:m]\n    end\n    if k == n + m\n        return [grid[i,1] for i in\
    \ 1:n] .* [grid[1,j] for j in 1:m] .* [grid[1,1]]\n    end\n    if k == n + m\
    \ + 1\n        return [grid[i,1] for i in 1:n] .* [grid[1,j] for j in 1:m] .*\
    \ [grid[1,1]] .* [grid[2,1]]\n    end\n    if k == n + m + 2\n        return [grid[i,1]\
    \ for i in 1:n] .* [grid[1,j] for j in 1:m] .* [grid[1,1]] .* [grid[2,1]] .* [grid[2,2]]\n\
    \    end\n    if k == n + m + 3\n        return [grid[i,1] for i in 1:n] .* [grid[1,j]\
    \ for j in 1:m] .* [grid[1,1]] .* [grid[2,1]] .* [grid[2,2]] .* [grid[2,3]]\n\
    \    end\n    if k\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgitrg8og.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgitrg8og.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # We will use a 2D array to store the minimum path\
    \ of length k starting\n    # from each cell.\n    # dp[i][j][k] is the minimum\
    \ path of length k starting from cell (i, j).\n    dp = Array{Vector{Int64}, 3}(undef,\
    \ N, N, k + 1)\n    # We will use a 2D array to store the previous cell of each\
    \ cell in the\n    # minimum path of length k starting from each cell.\n    #\
    \ prev[i][j][k] is the previous cell of cell (i, j) in the minimum path of\n \
    \   # length k starting from cell (i, j).\n    prev = Array{Tuple{Int64, Int64},\
    \ 3}(undef, N, N, k + 1)\n    # We will use a 2D array to store the length of\
    \ the minimum path of length\n    # k starting from each cell.\n    # len[i][j][k]\
    \ is the length of the minimum path of length k starting from\n    # cell (i,\
    \ j).\n    len = Array{Int64, 3}(undef, N, N, k + 1)\n    # We will use a 2D array\
    \ to store the minimum path of length k starting\n    # from each cell.\n    #\
    \ path[i][j][k] is the minimum path of length k starting from cell (i, j).\n \
    \   path = Array{Vector{Int64}, 3}(undef, N, N, k + 1)\n    # We will use a 2D\
    \ array to store the minimum path of length k starting\n    # from each cell.\n\
    \    # path[i][j][k] is the minimum path of length k starting from cell (i, j).\n\
    \    path = Array{Vector{Int64}, 3}(undef, N, N, k + 1)\n    # We will use a 2D\
    \ array to store the minimum path of length k starting\n    # from each cell.\n\
    \    # path[i][j][k] is the minimum path of length k starting from cell (i, j).\n\
    \    path = Array{Vector{Int64}, 3}(undef, N, N, k + 1)\n    # We will use a 2\n\
    using Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2,\
    \ 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4,\
    \ 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8],\
    \ [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpc56_0u9s.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpc56_0u9s.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpc56_0u9s.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: implement\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8nh4at61.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp8nh4at61.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmp8nh4at61.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8nh4at61.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp8nh4at61.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8nh4at61.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp8nh4at61.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp8nh4at61.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8nh4at61.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8nh4at61.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp8nh4at61.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\ntest set: Test Failed at /tmp/tmp8nh4at61.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp8nh4at61.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8nh4at61.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8nh4at61.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppdjajd3a.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppdjajd3a.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppdjajd3a.jl:32\n   [2] top-level scope at /tmp/tmppdjajd3a.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppdjajd3a.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppdjajd3a.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt8e5129z.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpt8e5129z.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n\n        return grid[1,:]\n    end\n    if k == n^2\n        return\
    \ grid[:]\n    end\n    if k > n^2\n        return []\n    end\n    if k > n\n\
    \        return grid[1,:]\n    end\n    if k > n^2 - n\n        return grid[:,n]\n\
    \    end\n    if k > n^2 - n - n\n        return grid[n,:]\n    end\n    if k\
    \ > n^2 - n - n - n\n        return grid[:,1]\n    end\n    if k > n^2 - n - n\
    \ - n - n\n        return grid[1,:]\n    end\n    if k > n^2 - n - n - n - n -\
    \ n\n        return grid[:,n]\n    end\n    if k > n^2 - n - n - n - n - n - n\n\
    \        return grid[n,:]\n    end\n    if k > n^2 - n - n - n - n - n - n - n\n\
    \        return grid[:,1]\n    end\n    if k > n^2 - n - n - n - n - n - n - n\
    \ - n\n        return grid[1,:]\n    end\n    if k > n^2 - n - n - n - n - n -\
    \ n - n - n - n\n        return grid[:,n]\n    end\n    if k > n^2 - n - n - n\
    \ - n - n - n - n - n - n - n\n        return grid[n,:]\n    end\n    if k > n^2\
    \ - n - n - n - n - n - n - n - n - n - n - n\n        return grid[:,1]\n    end\n\
    \    if k > n^2 - n - n - n - n - n - n - n - n - n - n - n - n\n        return\
    \ grid[1,:]\n    end\n    if k > n^2 - n - n - n - n - n - n - n - n - n - n -\
    \ n - n - n\n\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_94vdf3e.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_94vdf3e.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    m = length(grid[1])\n    dp = Array{Int64, 2}(undef,\
    \ n, m)\n    for i in 1:n\n        for j in 1:m\n            dp[i, j] = grid[i,\
    \ j]\n        end\n    end\n    for i in 1:k-1\n        for j in 1:n\n       \
    \     for l in 1:m\n                if j > 1\n                    dp[j, l] = min(dp[j,\
    \ l], dp[j-1, l])\n                end\n                if j < n\n           \
    \         dp[j, l] = min(dp[j, l], dp[j+1, l])\n                end\n        \
    \        if l > 1\n                    dp[j, l] = min(dp[j, l], dp[j, l-1])\n\
    \                end\n                if l < m\n                    dp[j, l] =\
    \ min(dp[j, l], dp[j, l+1])\n                end\n            end\n        end\n\
    \    end\n    return dp\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp1fsq2b79.jl:64\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex! at\
    \ ./array.jl:828 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1fsq2b79.jl:36\\n   [3] top-level scope at /tmp/tmp1fsq2b79.jl:64\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:65\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex! at ./array.jl:828 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp1fsq2b79.jl:36\\n   [3] top-level scope at /tmp/tmp1fsq2b79.jl:65\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:66\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an\
    \ object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp1fsq2b79.jl:36\\\
    n   [3] top-level scope at /tmp/tmp1fsq2b79.jl:66\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:67\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex! at\
    \ ./array.jl:828 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1fsq2b79.jl:36\\n   [3] top-level scope at /tmp/tmp1fsq2b79.jl:67\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:68\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to\
    \ an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex! at\
    \ ./array.jl:828 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1fsq2b79.jl:36\\n   [3] top-level scope at /tmp/tmp1fsq2b79.jl:68\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:69\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex! at\
    \ ./array.jl:828 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1fsq2b79.jl:36\\n   [3] top-level scope at /tmp/tmp1fsq2b79.jl:69\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:70\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Array{Int64,1} to an object of type Int64\\n  Closest candidates are:\\n   \
    \ convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!\
    \ at ./array.jl:828 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1fsq2b79.jl:36\\n   [3] top-level scope at /tmp/tmp1fsq2b79.jl:70\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:71\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\\
    n    ...\\n  Stacktrace:\\n   [1] setindex! at ./array.jl:828 [inlined]\\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp1fsq2b79.jl:36\\n   [3]\
    \ top-level scope at /tmp/tmp1fsq2b79.jl:71\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:72\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\\
    n    ...\\n  Stacktrace:\\n   [1] setindex! at ./array.jl:828 [inlined]\\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp1fsq2b79.jl:36\\n   [3]\
    \ top-level scope at /tmp/tmp1fsq2b79.jl:72\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:73\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex! at ./array.jl:828 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp1fsq2b79.jl:36\\n   [3] top-level scope at /tmp/tmp1fsq2b79.jl:73\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1fsq2b79.jl:74\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex! at ./array.jl:828 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp1fsq2b79.jl:36\\n   [3] top-level scope at /tmp/tmp1fsq2b79.jl:74\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1fsq2b79.jl:63\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    11     11\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Write your code here\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4tkkvo7u.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4tkkvo7u.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4tkkvo7u.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4tkkvo7u.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4tkkvo7u.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4tkkvo7u.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4tkkvo7u.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp4tkkvo7u.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4tkkvo7u.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4tkkvo7u.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp4tkkvo7u.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\ntest set: Test Failed at /tmp/tmp4tkkvo7u.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp4tkkvo7u.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4tkkvo7u.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4tkkvo7u.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2gqbecnt.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2gqbecnt.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    m = length(grid[1])\n    # the minimum path\n  \
    \  min_path = []\n    # the minimum value\n    min_val = Inf\n    # the minimum\
    \ path length\n    min_len = Inf\n    # the minimum path index\n    min_idx =\
    \ (1, 1)\n    # the minimum path value\n    min_path_val = Inf\n    # the minimum\
    \ path length\n    min_path_len = Inf\n    # the minimum path index\n    min_path_idx\
    \ = (1, 1)\n    # the minimum path value\n    min_path_val = Inf\n    # the minimum\
    \ path length\n    min_path_len = Inf\n    # the minimum path index\n    min_path_idx\
    \ = (1, 1)\n    # the minimum path value\n    min_path_val = Inf\n    # the minimum\
    \ path length\n    min_path_len = Inf\n    # the minimum path index\n    min_path_idx\
    \ = (1, 1)\n    # the minimum path value\n    min_path_val = Inf\n    # the minimum\
    \ path length\n    min_path_len = Inf\n    # the minimum path index\n    min_path_idx\
    \ = (1, 1)\n    # the minimum path value\n    min_path_val = Inf\n    # the minimum\
    \ path length\n    min_path_len = Inf\n    # the minimum path index\n    min_path_idx\
    \ = (1, 1)\n    # the minimum path value\n    min_path_val = Inf\n    # the minimum\
    \ path length\n    min_path_len = Inf\n    # the minimum path index\n    min_path_idx\
    \ = (1, 1)\n    # the minimum path value\n    min_path_val = Inf\n    # the minimum\
    \ path length\n    min_path_len = Inf\n    # the minimum path index\n    min_path_idx\
    \ = (1, 1)\n    # the minimum path value\n    min_path_val = Inf\n    # the minimum\
    \ path length\n    min_path_len = Inf\n    # the minimum path index\n    min_path_idx\
    \ = (1, 1)\n    # the minimum path value\n    min_\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7eckm683.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp7eckm683.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp7eckm683.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    # create a matrix of all possible paths\n    paths = zeros(Int64, N, N, k)\n\
    \    # fill the first row\n    for i in 1:N\n        paths[1,i,1] = grid[1,i]\n\
    \    end\n    # fill the first column\n    for i in 1:N\n        paths[i,1,1]\
    \ = grid[i,1]\n    end\n    # fill the rest of the matrix\n    for i in 2:N\n\
    \        for j in 2:N\n            for l in 2:k\n                paths[i,j,l]\
    \ = min(paths[i-1,j,l-1], paths[i,j-1,l-1])\n            end\n        end\n  \
    \  end\n    # find the minimum path\n    min_path = zeros(Int64, k)\n    min_path[k]\
    \ = paths[N,N,k]\n    i = N\n    j = N\n    for l in k-1:-1:1\n        if paths[i-1,j,l]\
    \ < paths[i,j-1,l]\n            min_path[l] = paths[i-1,j,l]\n            i -=\
    \ 1\n        else\n            min_path[l] = paths[i,j-1,l]\n            j -=\
    \ 1\n        end\n    end\n    return min_path\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp44a9d8hc.jl:74\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp44a9d8hc.jl:39\n\
    \   [3] top-level scope at /tmp/tmp44a9d8hc.jl:74\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:75\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{Int64,1}(::Array{Array{Int64,1},1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp44a9d8hc.jl:33\n   [6] top-level scope at /tmp/tmp44a9d8hc.jl:75\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:76\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp44a9d8hc.jl:39\n\
    \   [3] top-level scope at /tmp/tmp44a9d8hc.jl:76\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:77\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp44a9d8hc.jl:39\n\
    \   [3] top-level scope at /tmp/tmp44a9d8hc.jl:77\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:78\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp44a9d8hc.jl:39\n\
    \   [3] top-level scope at /tmp/tmp44a9d8hc.jl:78\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:79\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp44a9d8hc.jl:39\n\
    \   [3] top-level scope at /tmp/tmp44a9d8hc.jl:79\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:80\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Array{Int64,1} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp44a9d8hc.jl:39\n\
    \   [3] top-level scope at /tmp/tmp44a9d8hc.jl:80\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:81\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828 [inlined]\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp44a9d8hc.jl:39\n   [3]\
    \ top-level scope at /tmp/tmp44a9d8hc.jl:81\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:82\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828 [inlined]\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp44a9d8hc.jl:39\n   [3]\
    \ top-level scope at /tmp/tmp44a9d8hc.jl:82\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:83\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp44a9d8hc.jl:39\n   [3] top-level scope at /tmp/tmp44a9d8hc.jl:83\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmp44a9d8hc.jl:84\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp44a9d8hc.jl:39\n   [3] top-level scope at /tmp/tmp44a9d8hc.jl:84\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp44a9d8hc.jl:73\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp44a9d8hc.jl:71\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    min_path = Vector{Int64}(undef, k)\n    min_path[1]\
    \ = grid[1, 1]\n    for i in 2:k\n        min_path[i] = min(grid[1, i], grid[i,\
    \ 1])\n    end\n    for i in 2:k\n        for j in 2:k\n            if min_path[i]\
    \ < min_path[j]\n                min_path[j] = min(min_path[j], grid[i, j])\n\
    \            else\n                min_path[i] = min(min_path[i], grid[i, j])\n\
    \            end\n        end\n    end\n    return min_path\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp24opqub7.jl:53\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp24opqub7.jl:33\n   [3] top-level scope at /tmp/tmp24opqub7.jl:53\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:54\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp24opqub7.jl:33\n\
    \   [3] top-level scope at /tmp/tmp24opqub7.jl:54\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:55\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp24opqub7.jl:33\n   [3] top-level scope at /tmp/tmp24opqub7.jl:55\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:56\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp24opqub7.jl:33\n   [3] top-level scope at /tmp/tmp24opqub7.jl:56\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:57\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp24opqub7.jl:33\n   [3] top-level scope at /tmp/tmp24opqub7.jl:57\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:58\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp24opqub7.jl:33\n   [3] top-level scope at /tmp/tmp24opqub7.jl:58\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:59\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Array{Int64,1} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::Array{Int64,1}, ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp24opqub7.jl:33\n   [3] top-level scope at /tmp/tmp24opqub7.jl:59\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:60\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1}, ::Array{Int64,1},\
    \ ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp24opqub7.jl:33\n   [3] top-level scope at /tmp/tmp24opqub7.jl:60\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:61\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1}, ::Array{Int64,1},\
    \ ::Int64) at ./array.jl:826\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp24opqub7.jl:33\n   [3] top-level scope at /tmp/tmp24opqub7.jl:61\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:62\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp24opqub7.jl:33\n\
    \   [3] top-level scope at /tmp/tmp24opqub7.jl:62\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \ntest set: Error During\
    \ Test at /tmp/tmp24opqub7.jl:63\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp24opqub7.jl:33\n\
    \   [3] top-level scope at /tmp/tmp24opqub7.jl:63\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp24opqub7.jl:52\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp24opqub7.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n*n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n\
    \    if k < n\n        return [grid[1,i] for i in 1:k]\n    end\n    if k == n\n\
    \        return [grid[i,1] for i in 1:n]\n    end\n    if k == n+1\n        return\
    \ [grid[i,1] for i in 1:n]\n    end\n    if k < 2*n\n        return [grid[i,1]\
    \ for i in 1:n]\n    end\n    if k == 2*n\n        return [grid[i,1] for i in\
    \ 1:n]\n    end\n    if k == 2*n+1\n        return [grid[i,1] for i in 1:n]\n\
    \    end\n    if k < 3*n\n        return [grid[i,1] for i in 1:n]\n    end\n \
    \   if k == 3*n\n        return [grid[i,1] for i in 1:n]\n    end\n    if k ==\
    \ 3*n+1\n        return [grid[i,1] for i in 1:n]\n    end\n    if k < 4*n\n  \
    \      return [grid[i,1] for i in 1:n]\n    end\n    if k == 4*n\n        return\
    \ [grid[i,1] for i in 1:n]\n    end\n    if k == 4*n+1\n        return [grid[i,1]\
    \ for i in 1:n]\n    end\n    if k < 5*n\n        return [grid[i,1] for i in 1:n]\n\
    \    end\n    if k == 5*n\n        return [grid[i,1] for i in 1:n]\n    end\n\
    \    if k == 5*n+1\n        return [grid[i,1] for i in 1:n]\n    end\n    if k\
    \ < 6*n\n        return [grid[i,1] for i in 1:n]\n   \nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp047yfky_.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp047yfky_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t\
    @test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzedrio5j.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzedrio5j.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzedrio5j.jl:32\n   [2] top-level scope at /tmp/tmpzedrio5j.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzedrio5j.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzedrio5j.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N * N\n        return [grid[i,j] for i in 1:N, j in 1:N]\n    end\n\
    \    if k <= N\n        return [grid[i,1] for i in 1:k]\n    end\n    if k <=\
    \ 2 * N\n        return [grid[i,1] for i in 1:N] .* [grid[i,2] for i in 1:k-N]\n\
    \    end\n    if k <= 3 * N\n        return [grid[i,1] for i in 1:N] .* [grid[i,2]\
    \ for i in 1:N] .* [grid[i,3] for i in 1:k-2*N]\n    end\n    if k <= 4 * N\n\
    \        return [grid[i,1] for i in 1:N] .* [grid[i,2] for i in 1:N] .* [grid[i,3]\
    \ for i in 1:N] .* [grid[i,4] for i in 1:k-3*N]\n    end\n    if k <= 5 * N\n\
    \        return [grid[i,1] for i in 1:N] .* [grid[i,2] for i in 1:N] .* [grid[i,3]\
    \ for i in 1:N] .* [grid[i,4] for i in 1:N] .* [grid[i,5] for i in 1:k-4*N]\n\
    \    end\n    if k <= 6 * N\n        return [grid[i,1] for i in 1:N] .* [grid[i,2]\
    \ for i in 1:N] .* [grid[i,3] for i in 1:N] .* [grid[i,4] for i in 1:N] .* [grid[i,5]\
    \ for i in 1:N] .* [grid[i,6] for i in 1:k-5*N]\n    end\n    if k <= 7 * N\n\
    \        return [grid[i,1] for i in 1:N] .*\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfb6mn2ql.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfb6mn2ql.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t\
    @test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj4bnpfl3.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4bnpfl3.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpj4bnpfl3.jl:32\n   [2] top-level scope at /tmp/tmpj4bnpfl3.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4bnpfl3.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj4bnpfl3.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpu5xw3sqx.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu5xw3sqx.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpu5xw3sqx.jl:32\\n   [2] top-level scope at /tmp/tmpu5xw3sqx.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu5xw3sqx.jl:37\\n  \\nTest Summary: | Error\
    \  '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # create a matrix of the same size as grid, with\
    \ all elements equal to 0\n    visited = zeros(Int64, N, N)\n    # create a matrix\
    \ of the same size as grid, with all elements equal to 0\n    dist = zeros(Int64,\
    \ N, N)\n    # create a matrix of the same size as grid, with all elements equal\
    \ to 0\n    prev = zeros(Int64, N, N)\n    # create a matrix of the same size\
    \ as grid, with all elements equal to 0\n    prev_val = zeros(Int64, N, N)\n \
    \   # create a matrix of the same size as grid, with all elements equal to 0\n\
    \    prev_dist = zeros(Int64, N, N)\n    # create a matrix of the same size as\
    \ grid, with all elements equal to 0\n    prev_prev = zeros(Int64, N, N)\n   \
    \ # create a matrix of the same size as grid, with all elements equal to 0\n \
    \   prev_prev_val = zeros(Int64, N, N)\n    # create a matrix of the same size\
    \ as grid, with all elements equal to 0\n    prev_prev_dist = zeros(Int64, N,\
    \ N)\n    # create a matrix of the same size as grid, with all elements equal\
    \ to 0\n    prev_prev_prev = zeros(Int64, N, N)\n    # create a matrix of the\
    \ same size as grid, with all elements equal to 0\n    prev_prev_prev_val = zeros(Int64,\
    \ N, N)\n    # create a matrix of the same size as grid, with all elements equal\
    \ to 0\n    prev_prev_prev_dist = zeros(Int64, N, N)\n    # create a matrix of\
    \ the same size as grid, with all elements equal to 0\n    prev_prev_prev_prev\
    \ = zeros(Int64, N, N)\n    # create a matrix of the same size as grid, with all\
    \ elements equal to 0\n    prev_prev_prev_prev_val = zeros(Int64, N, N)\n    #\
    \ create a matrix of the same size as grid, with all elements equal to 0\n   \
    \ prev_prev_prev_prev_dist =\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmps709ecpg.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmps709ecpg.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmps709ecpg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N * N\n        return [grid[i,j] for i in 1:N, j in 1:N]\n    end\n\
    \    if k > N * N\n        return []\n    end\n    if k == N\n        return [grid[i,1]\
    \ for i in 1:N]\n    end\n    if k == N + 1\n        return [grid[i,1] for i in\
    \ 1:N]\n    end\n    if k == N + 2\n        return [grid[i,1] for i in 1:N]\n\
    \    end\n    if k == N + 3\n        return [grid[i,1] for i in 1:N]\n    end\n\
    \    if k == N + 4\n        return [grid[i,1] for i in 1:N]\n    end\n    if k\
    \ == N + 5\n        return [grid[i,1] for i in 1:N]\n    end\n    if k == N +\
    \ 6\n        return [grid[i,1] for i in 1:N]\n    end\n    if k == N + 7\n   \
    \     return [grid[i,1] for i in 1:N]\n    end\n    if k == N + 8\n        return\
    \ [grid[i,1] for i in 1:N]\n    end\n    if k == N + 9\n        return [grid[i,1]\
    \ for i in 1:N]\n    end\n    if k == N + 10\n        return [grid[i,1] for i\
    \ in 1:N]\n    end\n    if k == N + 11\n        return [grid[i,1] for i in 1:N]\n\
    \    end\n    if k == N + 12\n        return [grid[i,1] for i in 1:N]\n    end\n\
    \    if k == N + 13\n        return [grid[i,1] for i in 1:N]\n    end\n    if\
    \ k == N + 14\n        return [grid[i,1] for i in 1:N]\n    end\n    if k == N\
    \ + 15\n        return [grid[i,1]\nusing Test\n\n@testset begin\n\ncandidate =\
    \ minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpawdt12e8.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpawdt12e8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # Initialize the grid with the values\n    grid_values\
    \ = Dict{(Int64, Int64), Int64}()\n    for i in 1:N\n        for j in 1:N\n  \
    \          grid_values[(i, j)] = grid[i][j]\n        end\n    end\n    # Initialize\
    \ the grid with the distances\n    grid_distances = Dict{(Int64, Int64), Int64}()\n\
    \    for i in 1:N\n        for j in 1:N\n            grid_distances[(i, j)] =\
    \ Inf\n        end\n    end\n    # Initialize the grid with the previous cells\n\
    \    grid_previous = Dict{(Int64, Int64), (Int64, Int64)}()\n    for i in 1:N\n\
    \        for j in 1:N\n            grid_previous[(i, j)] = (-1, -1)\n        end\n\
    \    end\n    # Initialize the grid with the visited cells\n    grid_visited =\
    \ Dict{(Int64, Int64), Bool}()\n    for i in 1:N\n        for j in 1:N\n     \
    \       grid_visited[(i, j)] = false\n        end\n    end\n    # Initialize the\
    \ grid with the neighbors\n    grid_neighbors = Dict{(Int64, Int64), Vector{(Int64,\
    \ Int64)}}()\n    for i in 1:N\n        for j in 1:N\n            grid_neighbors[(i,\
    \ j)] = []\n        end\n    end\n    for i in 1:N\n        for j in 1:N\n   \
    \         if i > 1\n                push!(grid_neighbors[(i, j)], (i - 1, j))\n\
    \            end\n            if i < N\n                push!(grid_neighbors[(i,\
    \ j)], (i + 1, j))\n            end\n            if j > 1\n                push!(grid_neighbors[(i,\
    \ j)], (i, j - 1))\n            end\n            if j < N\n                push!(grid_neighbors[(i,\
    \ j)], (i, j + 1))\n\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t\
    @test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvw66e1pm.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvw66e1pm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2qr2pszc.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp2qr2pszc.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmp2qr2pszc.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2qr2pszc.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp2qr2pszc.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp2qr2pszc.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp2qr2pszc.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp2qr2pszc.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2qr2pszc.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2qr2pszc.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp2qr2pszc.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\ntest set: Test Failed at /tmp/tmp2qr2pszc.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp2qr2pszc.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qr2pszc.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2qr2pszc.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    # create a matrix to store the minimum path\n  \
    \  min_path = Array{Int64, 2}(undef, n, n)\n    # create a matrix to store the\
    \ minimum path\n    min_path_value = Array{Int64, 2}(undef, n, n)\n    # create\
    \ a matrix to store the minimum path\n    min_path_value[1, 1] = grid[1, 1]\n\
    \    # create a matrix to store the minimum path\n    min_path[1, 1] = grid[1,\
    \ 1]\n    # create a matrix to store the minimum path\n    for i in 2:n\n    \
    \    min_path_value[i, 1] = min_path_value[i - 1, 1] + grid[i, 1]\n        min_path[i,\
    \ 1] = grid[i, 1]\n    end\n    # create a matrix to store the minimum path\n\
    \    for j in 2:n\n        min_path_value[1, j] = min_path_value[1, j - 1] + grid[1,\
    \ j]\n        min_path[1, j] = grid[1, j]\n    end\n    # create a matrix to store\
    \ the minimum path\n    for i in 2:n\n        for j in 2:n\n            if min_path_value[i\
    \ - 1, j] < min_path_value[i, j - 1]\n                min_path_value[i, j] = min_path_value[i\
    \ - 1, j] + grid[i, j]\n                min_path[i, j] = grid[i, j]\n        \
    \    else\n                min_path_value[i, j] = min_path_value[i, j - 1] + grid[i,\
    \ j]\n                min_path[i, j] = grid[i, j]\n            end\n        end\n\
    \    end\n    # create a matrix to store the minimum path\n    min_path_value\n\
    \    # create a matrix to store the minimum path\n    min_path\n    # create a\
    \ matrix to store the minimum path\n    min_path_value[n, n]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl8plr3n7.jl:74\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpl8plr3n7.jl:37\n\
    \   [3] top-level scope at /tmp/tmpl8plr3n7.jl:74\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:75\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpl8plr3n7.jl:37\n   [3] top-level scope at /tmp/tmpl8plr3n7.jl:75\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:76\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpl8plr3n7.jl:37\n\
    \   [3] top-level scope at /tmp/tmpl8plr3n7.jl:76\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:77\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpl8plr3n7.jl:37\n\
    \   [3] top-level scope at /tmp/tmpl8plr3n7.jl:77\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:78\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpl8plr3n7.jl:37\n\
    \   [3] top-level scope at /tmp/tmpl8plr3n7.jl:78\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:79\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpl8plr3n7.jl:37\n\
    \   [3] top-level scope at /tmp/tmpl8plr3n7.jl:79\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:80\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Array{Int64,1} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpl8plr3n7.jl:37\n\
    \   [3] top-level scope at /tmp/tmpl8plr3n7.jl:80\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:81\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828 [inlined]\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpl8plr3n7.jl:37\n   [3]\
    \ top-level scope at /tmp/tmpl8plr3n7.jl:81\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:82\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828 [inlined]\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpl8plr3n7.jl:37\n   [3]\
    \ top-level scope at /tmp/tmpl8plr3n7.jl:82\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:83\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpl8plr3n7.jl:37\n   [3] top-level scope at /tmp/tmpl8plr3n7.jl:83\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \ntest set: Error During\
    \ Test at /tmp/tmpl8plr3n7.jl:84\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpl8plr3n7.jl:37\n   [3] top-level scope at /tmp/tmpl8plr3n7.jl:84\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl8plr3n7.jl:73\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl8plr3n7.jl:71\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxz39p27w.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxz39p27w.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxz39p27w.jl:32\n   [2] top-level scope at /tmp/tmpxz39p27w.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxz39p27w.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxz39p27w.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqxymhrww.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqxymhrww.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqxymhrww.jl:32\n   [2] top-level scope at /tmp/tmpqxymhrww.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqxymhrww.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqxymhrww.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2bn1i31r.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2bn1i31r.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpheo3hp2j.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpheo3hp2j.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpheo3hp2j.jl:32\n   [2] top-level scope at /tmp/tmpheo3hp2j.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpheo3hp2j.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpheo3hp2j.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4fx32r8r.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp4fx32r8r.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp4fx32r8r.jl:32\n   [2] top-level scope at /tmp/tmp4fx32r8r.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4fx32r8r.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4fx32r8r.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N\n        return grid[1,:]\n    end\n    if k == N^2\n        return\
    \ grid[:]\n    end\n    if k > N^2\n        return []\n    end\n    if k < N\n\
    \        return grid[1,1:k]\n    end\n    if k > N^2 - N\n        return grid[N,N-k+1:N]\n\
    \    end\n    if k > N^2 - 2N\n        return [grid[1,N], grid[2,N-1], grid[3,N-2]]\n\
    \    end\n    if k > N^2 - 3N\n        return [grid[1,N], grid[2,N-1], grid[3,N-2],\
    \ grid[3,N-3]]\n    end\n    if k > N^2 - 4N\n        return [grid[1,N], grid[2,N-1],\
    \ grid[3,N-2], grid[3,N-3], grid[3,N-4]]\n    end\n    if k > N^2 - 5N\n     \
    \   return [grid[1,N], grid[2,N-1], grid[3,N-2], grid[3,N-3], grid[3,N-4], grid[3,N-5]]\n\
    \    end\n    if k > N^2 - 6N\n        return [grid[1,N], grid[2,N-1], grid[3,N-2],\
    \ grid[3,N-3], grid[3,N-4], grid[3,N-5], grid[3,N-6]]\n    end\n    if k > N^2\
    \ - 7N\n        return [grid[1,N], grid[2,N-1], grid[3,N-2], grid[3,N-3], grid[3,N-4],\
    \ grid[3,N-5], grid[3,N-6], grid[3,N-7]]\n    end\n    if k > N^2 - 8N\n     \
    \   return [grid[1,N], grid[2,N-1\nusing Test\n\n@testset begin\n\ncandidate =\
    \ minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing separator in array expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr142nkmb.jl:70\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr142nkmb.jl:70\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    using Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2,\
    \ 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4,\
    \ 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8],\
    \ [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqmahg73e.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqmahg73e.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5hn9ttua.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hn9ttua.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5hn9ttua.jl:32\n   [2] top-level scope at /tmp/tmp5hn9ttua.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5hn9ttua.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5hn9ttua.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpy43vjva0.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpy43vjva0.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpy43vjva0.jl:32\\n   [2] top-level scope at /tmp/tmpy43vjva0.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpy43vjva0.jl:37\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuovcmkvl.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuovcmkvl.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N * N\n        return [grid[i,j] for i in 1:N, j in 1:N]\n    end\n\
    \    if k > N * N\n        return []\n    end\n    if k == 2\n        if N ==\
    \ 2\n            return [grid[1,1], grid[2,1]]\n        end\n        if grid[1,1]\
    \ < grid[1,2]\n            return [grid[1,1], grid[1,2]]\n        else\n     \
    \       return [grid[1,2], grid[1,1]]\n        end\n    end\n    if k == 3\n \
    \       if N == 3\n            return [grid[1,1], grid[2,1], grid[3,1]]\n    \
    \    end\n        if grid[1,1] < grid[1,2]\n            return [grid[1,1], grid[1,2],\
    \ grid[1,3]]\n        else\n            return [grid[1,2], grid[1,1], grid[1,3]]\n\
    \        end\n    end\n    if k == 4\n        if N == 4\n            return [grid[1,1],\
    \ grid[2,1], grid[3,1], grid[4,1]]\n        end\n        if grid[1,1] < grid[1,2]\n\
    \            return [grid[1,1], grid[1,2], grid[1,3], grid[1,4]]\n        else\n\
    \            return [grid[1,2], grid[1,1], grid[1,3], grid[1,4]]\n        end\n\
    \    end\n    if k == 5\n        if N == 5\n            return [grid[1,1], grid[2,1],\
    \ grid[3,1], grid[4,1], grid[5,1]]\n        end\n        if grid[1,1] < grid[1,2]\n\
    \            return [grid[1,1], grid[1,2], grid[1,3], grid[1,4], grid[1,5]]\n\
    \        else\n            return [grid[1,2], grid[1,1],\nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing separator in array expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxjoelttt.jl:81\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxjoelttt.jl:81\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    dp = zeros(Int64, N, N, k + 1)\n    for i in 1:N,\
    \ j in 1:N\n        dp[i, j, 1] = grid[i, j]\n    end\n    for i in 1:N, j in\
    \ 1:N, l in 2:k + 1\n        dp[i, j, l] = dp[i, j, l - 1]\n        if i > 1\n\
    \            dp[i, j, l] = min(dp[i, j, l], dp[i - 1, j, l - 1])\n        end\n\
    \        if i < N\n            dp[i, j, l] = min(dp[i, j, l], dp[i + 1, j, l -\
    \ 1])\n        end\n        if j > 1\n            dp[i, j, l] = min(dp[i, j, l],\
    \ dp[i, j - 1, l - 1])\n        end\n        if j < N\n            dp[i, j, l]\
    \ = min(dp[i, j, l], dp[i, j + 1, l - 1])\n        end\n    end\n    res = zeros(Int64,\
    \ k)\n    res[1] = dp[1, 1, k]\n    i, j = 1, 1\n    for l in 2:k\n        if\
    \ i > 1 && dp[i - 1, j, k - l + 1] == res[l - 1]\n            i -= 1\n       \
    \ elseif i < N && dp[i + 1, j, k - l + 1] == res[l - 1]\n            i += 1\n\
    \        elseif j > 1 && dp[i, j - 1, k - l + 1] == res[l - 1]\n            j\
    \ -= 1\n        else\n            j += 1\n        end\n        res[l] = grid[i,\
    \ j]\n    end\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_mw8qfz2.jl:73\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n\
    \   [3] top-level scope at /tmp/tmp_mw8qfz2.jl:73\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:74\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n   [3] top-level scope at /tmp/tmp_mw8qfz2.jl:74\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:75\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n\
    \   [3] top-level scope at /tmp/tmp_mw8qfz2.jl:75\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:76\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n\
    \   [3] top-level scope at /tmp/tmp_mw8qfz2.jl:76\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:77\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n\
    \   [3] top-level scope at /tmp/tmp_mw8qfz2.jl:77\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:78\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n\
    \   [3] top-level scope at /tmp/tmp_mw8qfz2.jl:78\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:79\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Array{Int64,1} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n\
    \   [3] top-level scope at /tmp/tmp_mw8qfz2.jl:79\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:80\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828 [inlined]\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n   [3]\
    \ top-level scope at /tmp/tmp_mw8qfz2.jl:80\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:81\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828 [inlined]\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n   [3]\
    \ top-level scope at /tmp/tmp_mw8qfz2.jl:81\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:82\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n   [3] top-level scope at /tmp/tmp_mw8qfz2.jl:82\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \ntest set: Error During\
    \ Test at /tmp/tmp_mw8qfz2.jl:83\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp_mw8qfz2.jl:34\n   [3] top-level scope at /tmp/tmp_mw8qfz2.jl:83\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp_mw8qfz2.jl:72\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_mw8qfz2.jl:70\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp14mwdfu3.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp14mwdfu3.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp14mwdfu3.jl:32\\n   [2] top-level scope at /tmp/tmp14mwdfu3.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp14mwdfu3.jl:37\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp04mkq5bk.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp04mkq5bk.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmp04mkq5bk.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp04mkq5bk.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp04mkq5bk.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp04mkq5bk.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp04mkq5bk.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp04mkq5bk.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp04mkq5bk.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp04mkq5bk.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp04mkq5bk.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\ntest set: Test Failed at /tmp/tmp04mkq5bk.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp04mkq5bk.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04mkq5bk.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp04mkq5bk.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpu8u5rge_.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu8u5rge_.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu8u5rge_.jl:32\n   [2] top-level scope at /tmp/tmpu8u5rge_.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu8u5rge_.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu8u5rge_.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    # find the minimum value in the grid\n    min_val = grid[1,1]\n    for i\
    \ in 1:n\n        for j in 1:n\n            if grid[i,j] < min_val\n         \
    \       min_val = grid[i,j]\n            end\n        end\n    end\n    # find\
    \ the position of the minimum value in the grid\n    min_pos = [1,1]\n    for\
    \ i in 1:n\n        for j in 1:n\n            if grid[i,j] == min_val\n      \
    \          min_pos = [i,j]\n                break\n            end\n        end\n\
    \    end\n    # find the minimum path\n    path = [min_val]\n    for i in 2:k\n\
    \        # find the minimum value in the grid\n        min_val = grid[1,1]\n \
    \       for j in 1:n\n            for l in 1:n\n                if grid[j,l] <\
    \ min_val\n                    min_val = grid[j,l]\n                end\n    \
    \        end\n        end\n        # find the position of the minimum value in\
    \ the grid\n        min_pos = [1,1]\n        for j in 1:n\n            for l in\
    \ 1:n\n                if grid[j,l] == min_val\n                    min_pos =\
    \ [j,l]\n                    break\n                end\n            end\n   \
    \     end\n        # find the minimum path\n        path = [min_val]\n       \
    \ for j in 2:k\n            # find the minimum value in the grid\n           \
    \ min_val = grid[1,1]\n            for l in 1:n\n                for m in 1:n\n\
    \                    if grid[l,m] < min_val\n                        min_val =\
    \ grid[l,m]\n                    end\n                end\n            end\n \
    \           # find the position of the minimum value in the grid\n           \
    \ min_pos = [1,1]\n            for l in 1:n\n                for m in 1:n\n  \
    \                  if grid[l,m] == min_val\n                        min_pos =\
    \ [l,m]\n                        break\n                   \nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4gja4g15.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4gja4g15.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N\n        return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1]]\n\
    \    end\n    if k == N + 1\n        return [grid[1,1], grid[1,2], grid[2,2],\
    \ grid[2,1], grid[1,1], grid[1,2]]\n    end\n    if k == N + 2\n        return\
    \ [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1], grid[1,2], grid[2,2]]\n\
    \    end\n    if k == N + 3\n        return [grid[1,1], grid[1,2], grid[2,2],\
    \ grid[2,1], grid[1,1], grid[1,2], grid[2,2], grid[2,1]]\n    end\n    if k ==\
    \ N + 4\n        return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1],\
    \ grid[1,2], grid[2,2], grid[2,1], grid[1,1]]\n    end\n    if k == N + 5\n  \
    \      return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1], grid[1,2],\
    \ grid[2,2], grid[2,1], grid[1,1], grid[1,2]]\n    end\n    if k == N + 6\n  \
    \      return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1], grid[1,2],\
    \ grid[2,2], grid[2,1], grid[1,1], grid[1,2], grid[2,2]]\n    end\n    if k ==\
    \ N + 7\n        return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1],\
    \ grid[1,\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing separator in array expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6npec6ch.jl:60\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6npec6ch.jl:60\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n\
    \    if k == n\n        return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1]]\n\
    \    end\n    if k == n + 1\n        return [grid[1,1], grid[1,2], grid[2,2],\
    \ grid[2,1], grid[1,1], grid[1,2]]\n    end\n    if k == n + 2\n        return\
    \ [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1], grid[1,2], grid[1,3]]\n\
    \    end\n    if k == n + 3\n        return [grid[1,1], grid[1,2], grid[2,2],\
    \ grid[2,1], grid[1,1], grid[1,2], grid[1,3], grid[2,3]]\n    end\n    if k ==\
    \ n + 4\n        return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1],\
    \ grid[1,2], grid[1,3], grid[2,3], grid[3,3]]\n    end\n    if k == n + 5\n  \
    \      return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1], grid[1,2],\
    \ grid[1,3], grid[2,3], grid[3,3], grid[3,2]]\n    end\n    if k == n + 6\n  \
    \      return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1], grid[1,2],\
    \ grid[1,3], grid[2,3], grid[3,3], grid[3,2], grid[3,1]]\n    end\n    if k ==\
    \ n + 7\n        return [\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprbwu6q_h.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprbwu6q_h.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    # We use a priority queue to store the paths we are currently exploring.\n\
    \    # The priority queue is ordered by the lexicographic order of the paths.\n\
    \    # The priority queue is implemented as a binary heap.\n    # Each path is\
    \ represented as a tuple (path, i, j) where path is the list\n    # of values\
    \ on the cells that the path go through, and i, j are the\n    # coordinates of\
    \ the last cell of the path.\n    # We use a dictionary to store the paths that\
    \ we have already explored.\n    # The dictionary is used to avoid exploring the\
    \ same path twice.\n    # The dictionary is implemented as a hash table.\n   \
    \ # The key of the dictionary is the list of values on the cells that the\n  \
    \  # path go through.\n    # The value of the dictionary is the length of the\
    \ path.\n    # We use a set to store the paths that we have already explored.\n\
    \    # The set is used to avoid exploring the same path twice.\n    # The set\
    \ is implemented as a hash table.\n    # The key of the set is the list of values\
    \ on the cells that the path go\n    # through.\n    # The value of the set is\
    \ the length of the path.\n    # We use a dictionary to store the paths that we\
    \ have already explored.\n    # The dictionary is used to avoid exploring the\
    \ same path twice.\n    # The dictionary is implemented as a hash table.\n   \
    \ # The key of the dictionary is the list of values on the cells that the\n  \
    \  # path go through.\n    # The value of the dictionary is the length of the\
    \ path.\n    # We use a set to store the paths that we have already explored.\n\
    \    # The set is used to avoid exploring the same path twice.\n    # The set\
    \ is implemented as a hash table.\n    # The key of the set is the list of values\
    \ on the cells that the path go\n    # through.\n    # The value of the set is\
    \ the length of the path.\n    # We use a dictionary to store the paths that we\
    \ have already explored.\n    # The dictionary is used to avoid exploring the\
    \ same path twice.\n    # The dictionary is implemented as a hash table.\n   \
    \ #\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2_5ze2zo.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp2_5ze2zo.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp2_5ze2zo.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n\
    \    if k > n * n\n        return []\n    end\n    # find the minimum value in\
    \ the grid\n    min_val = grid[1,1]\n    for i in 1:n\n        for j in 1:n\n\
    \            if grid[i,j] < min_val\n                min_val = grid[i,j]\n   \
    \         end\n        end\n    end\n    # find the position of the minimum value\n\
    \    min_pos = [1,1]\n    for i in 1:n\n        for j in 1:n\n            if grid[i,j]\
    \ == min_val\n                min_pos = [i,j]\n                break\n       \
    \     end\n        end\n    end\n    # find the minimum path\n    min_path = [min_val]\n\
    \    for i in 1:k-1\n        # find the minimum value in the neighborhood\n  \
    \      min_val = grid[min_pos[1], min_pos[2]]\n        for j in max(1, min_pos[1]-1):min(n,\
    \ min_pos[1]+1)\n            for k in max(1, min_pos[2]-1):min(n, min_pos[2]+1)\n\
    \                if grid[j,k] < min_val\n                    min_val = grid[j,k]\n\
    \                end\n            end\n        end\n        # find the position\
    \ of the minimum value\n        for j in max(1, min_pos[1]-1):min(n, min_pos[1]+1)\n\
    \            for k in max(1, min_pos[2]-1):min(n, min_pos[2]+1)\n            \
    \    if grid[j,k] == min_val\n                    min_pos = [j,k]\n          \
    \          break\n                end\n            end\n        end\n        #\
    \ add the minimum value to the path\n        push!(min_path, min_val)\n    end\n\
    \    return min_path\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmplb_6q4_2.jl:91\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  BoundsError: attempt to access 3-element Array{Array{Int64,1},1}\
    \ at index [1, 2]\\n  Stacktrace:\\n   [1] getindex at ./array.jl:789 [inlined]\\\
    n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmplb_6q4_2.jl:45\\\
    n   [3] top-level scope at /tmp/tmplb_6q4_2.jl:91\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplb_6q4_2.jl:92\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64)\
    \ at ./array.jl:826\\n   [2] copyto! at ./multidimensional.jl:962 [inlined]\\\
    n   [3] Array{Int64,1}(::Array{Array{Int64,1},1}) at ./array.jl:541\\n   [4] convert\
    \ at ./array.jl:533 [inlined]\\n   [5] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmplb_6q4_2.jl:33\\n   [6] top-level scope at /tmp/tmplb_6q4_2.jl:92\\\
    n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [8] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplb_6q4_2.jl:93\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1} at index\
    \ [1, 2]\\n  Stacktrace:\\n   [1] getindex at ./array.jl:789 [inlined]\\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmplb_6q4_2.jl:45\\n   [3]\
    \ top-level scope at /tmp/tmplb_6q4_2.jl:93\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplb_6q4_2.jl:94\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1}\
    \ at index [1, 2]\\n  Stacktrace:\\n   [1] getindex at ./array.jl:789 [inlined]\\\
    n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmplb_6q4_2.jl:45\\\
    n   [3] top-level scope at /tmp/tmplb_6q4_2.jl:94\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplb_6q4_2.jl:95\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1} at\
    \ index [1, 2]\\n  Stacktrace:\\n   [1] getindex at ./array.jl:789 [inlined]\\\
    n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmplb_6q4_2.jl:45\\\
    n   [3] top-level scope at /tmp/tmplb_6q4_2.jl:95\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplb_6q4_2.jl:96\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1}\
    \ at index [1, 2]\\n  Stacktrace:\\n   [1] getindex at ./array.jl:789 [inlined]\\\
    n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmplb_6q4_2.jl:45\\\
    n   [3] top-level scope at /tmp/tmplb_6q4_2.jl:96\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplb_6q4_2.jl:97\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1}\
    \ at index [1, 2]\\n  Stacktrace:\\n   [1] getindex at ./array.jl:789 [inlined]\\\
    n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmplb_6q4_2.jl:45\\\
    n   [3] top-level scope at /tmp/tmplb_6q4_2.jl:97\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplb_6q4_2.jl:98\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  BoundsError:\
    \ attempt to access 3-element Array{Array{Int64,1},1} at index [1, 2]\\n  Stacktrace:\\\
    n   [1] getindex at ./array.jl:789 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmplb_6q4_2.jl:45\\n   [3] top-level scope at /tmp/tmplb_6q4_2.jl:98\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplb_6q4_2.jl:99\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  BoundsError:\
    \ attempt to access 3-element Array{Array{Int64,1},1} at index [1, 2]\\n  Stacktrace:\\\
    n   [1] getindex at ./array.jl:789 [inlined]\\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmplb_6q4_2.jl:45\\n   [3] top-level scope at /tmp/tmplb_6q4_2.jl:99\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n  \\ntest set: Test Failed\
    \ at /tmp/tmplb_6q4_2.jl:100\\n  Expression: candidate([[1, 2], [3, 4]], 10) ==\
    \ [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2,\
    \ 1, 2, 1, 2]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplb_6q4_2.jl:100\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplb_6q4_2.jl:90\\ntest set: Test Failed at /tmp/tmplb_6q4_2.jl:101\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplb_6q4_2.jl:101\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplb_6q4_2.jl:90\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxho0haw6.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpxho0haw6.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxho0haw6.jl:32\n   [2] top-level scope at /tmp/tmpxho0haw6.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxho0haw6.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxho0haw6.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement me!\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmppscjc8g7.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmppscjc8g7.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmppscjc8g7.jl:32\\n   [2] top-level scope at /tmp/tmppscjc8g7.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmppscjc8g7.jl:37\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: implement\n    return [1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnu7c2rir.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: [1] == [1, 2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnu7c2rir.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\ntest set: Test Failed at /tmp/tmpnu7c2rir.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: [1] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnu7c2rir.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\ntest set: Test Failed at /tmp/tmpnu7c2rir.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: [1] == [1, 10, 1,\
    \ 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpnu7c2rir.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\ntest set: Test Failed at /tmp/tmpnu7c2rir.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: [1] == [1, 7, 1, 7, 1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnu7c2rir.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\ntest set: Test Failed at /tmp/tmpnu7c2rir.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: [1] == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpnu7c2rir.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\ntest set: Test Failed at /tmp/tmpnu7c2rir.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: [1] ==\
    \ [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at /tmp/tmpnu7c2rir.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\ntest set: Test Failed at /tmp/tmpnu7c2rir.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: [1] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpnu7c2rir.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\ntest set: Test Failed at /tmp/tmpnu7c2rir.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: [1] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpnu7c2rir.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\ntest set: Test Failed at /tmp/tmpnu7c2rir.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: [1] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpnu7c2rir.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\ntest set: Test Failed at /tmp/tmpnu7c2rir.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: [1] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpnu7c2rir.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnu7c2rir.jl:38\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1    10     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 10 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnu7c2rir.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N * N\n        return sort(grid)\n    end\n    if k > N * N\n   \
    \     return []\n    end\n    if k == N\n        return sort(grid[1,:])\n    end\n\
    \    if k == N * (N - 1) + 1\n        return sort(grid[:,1])\n    end\n    if\
    \ k == N * (N - 1)\n        return sort(grid[:,N])\n    end\n    if k == N * (N\
    \ - 1) - 1\n        return sort(grid[N,:])\n    end\n    if k == N * (N - 1) -\
    \ N + 1\n        return sort(grid[:,N-1])\n    end\n    if k == N * (N - 1) -\
    \ N + 2\n        return sort(grid[:,N-2])\n    end\n    if k == N * (N - 1) -\
    \ N + 3\n        return sort(grid[:,N-3])\n    end\n    if k == N * (N - 1) -\
    \ N + 4\n        return sort(grid[:,N-4])\n    end\n    if k == N * (N - 1) -\
    \ N + 5\n        return sort(grid[:,N-5])\n    end\n    if k == N * (N - 1) -\
    \ N + 6\n        return sort(grid[:,N-6])\n    end\n    if k == N * (N - 1) -\
    \ N + 7\n        return sort(grid[:,N-7])\n    end\n    if k == N * (N - 1) -\
    \ N + 8\n        return sort(grid[:,N-8])\n    end\n    if k == N * (N - 1) -\
    \ N + 9\n        return sort(grid[:,N-9])\n    end\n    if k == N * (N - 1) -\
    \ N + 10\n        return sort(grid[:,N-10])\n    end\n    if k == N * (N - 1)\
    \ - N + 11\n        return sort(grid[:,N-11])\n    end\n    if k == N * (N - 1\n\
    using Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2,\
    \ 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4,\
    \ 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8],\
    \ [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvrhp6y0m.jl:87\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvrhp6y0m.jl:87\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    visited = zeros(Int64, n, n)\n    min_path = []\n\
    \    min_path_value = Inf\n    for i in 1:n, j in 1:n\n        visited[i, j] =\
    \ 1\n        path = [grid[i, j]]\n        path_value = grid[i, j]\n        dfs(grid,\
    \ visited, path, path_value, min_path, min_path_value, i, j, k - 1)\n        visited[i,\
    \ j] = 0\n    end\n    return min_path\nend\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxmkyz9iw.jl:49\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpxmkyz9iw.jl:39\n   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:49\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:50\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  UndefVarError: dfs not defined\n\
    \  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpxmkyz9iw.jl:39\n\
    \   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:51\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpxmkyz9iw.jl:39\n   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:52\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpxmkyz9iw.jl:39\n   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:53\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpxmkyz9iw.jl:39\n   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:54\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpxmkyz9iw.jl:39\n   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:55\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  UndefVarError: dfs not defined\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpxmkyz9iw.jl:39\n\
    \   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:56\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpxmkyz9iw.jl:39\n   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:57\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpxmkyz9iw.jl:39\n   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:58\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxmkyz9iw.jl:39\n   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:58\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpxmkyz9iw.jl:59\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpxmkyz9iw.jl:39\n   [2] top-level scope at /tmp/tmpxmkyz9iw.jl:59\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxmkyz9iw.jl:48\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxmkyz9iw.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\n\"\"\"\n    Given a grid with\
    \ N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the\
    \ grid contains a value. Every integer in the range [1, N * N]\n    inclusive\
    \ appears exactly once on the cells of the grid.\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp79xpth6m.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp79xpth6m.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpixc63v7q.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpixc63v7q.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpixc63v7q.jl:32\n   [2] top-level scope at /tmp/tmpixc63v7q.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixc63v7q.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpixc63v7q.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement me!\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp00q4jt1e.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp00q4jt1e.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp00q4jt1e.jl:32\n   [2] top-level scope at /tmp/tmp00q4jt1e.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp00q4jt1e.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp00q4jt1e.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    visited = zeros(Int64, N, N)\n    min_path = zeros(Int64,\
    \ k)\n    min_path_sum = Inf\n    min_path_idx = 0\n    for i in 1:N, j in 1:N\n\
    \        visited[i, j] = 1\n        path = [grid[i, j]]\n        path_sum = grid[i,\
    \ j]\n        path_idx = 1\n        dfs(grid, visited, i, j, path, path_sum, path_idx,\
    \ min_path, min_path_sum, min_path_idx, k)\n        visited[i, j] = 0\n    end\n\
    \    return min_path\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2m40az2o.jl:51\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp2m40az2o.jl:41\n   [2] top-level scope at /tmp/tmp2m40az2o.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:52\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  UndefVarError: dfs not defined\n\
    \  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp2m40az2o.jl:41\n\
    \   [2] top-level scope at /tmp/tmp2m40az2o.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:53\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp2m40az2o.jl:41\n   [2] top-level scope at /tmp/tmp2m40az2o.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:54\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp2m40az2o.jl:41\n   [2] top-level scope at /tmp/tmp2m40az2o.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:55\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp2m40az2o.jl:41\n   [2] top-level scope at /tmp/tmp2m40az2o.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:56\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp2m40az2o.jl:41\n   [2] top-level scope at /tmp/tmp2m40az2o.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:57\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  UndefVarError: dfs not defined\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp2m40az2o.jl:41\n\
    \   [2] top-level scope at /tmp/tmp2m40az2o.jl:57\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:58\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp2m40az2o.jl:41\n   [2] top-level scope at /tmp/tmp2m40az2o.jl:58\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:59\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp2m40az2o.jl:41\n   [2] top-level scope at /tmp/tmp2m40az2o.jl:59\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:60\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2m40az2o.jl:41\n   [2] top-level scope at /tmp/tmp2m40az2o.jl:60\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2m40az2o.jl:61\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2m40az2o.jl:41\n   [2] top-level scope at /tmp/tmp2m40az2o.jl:61\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2m40az2o.jl:50\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2m40az2o.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_wydan80.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp_wydan80.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp_wydan80.jl:32\n   [2] top-level scope at /tmp/tmp_wydan80.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_wydan80.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_wydan80.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement me!\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdqqlz0rn.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdqqlz0rn.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdqqlz0rn.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdqqlz0rn.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdqqlz0rn.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdqqlz0rn.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdqqlz0rn.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpdqqlz0rn.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdqqlz0rn.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdqqlz0rn.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpdqqlz0rn.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\ntest set: Test Failed at /tmp/tmpdqqlz0rn.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpdqqlz0rn.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqqlz0rn.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdqqlz0rn.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6o2u8jh4.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6o2u8jh4.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code goes here\n    return []\nend\n\"\"\"\n    Given a grid with\
    \ N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the\
    \ grid contains a value. Every integer in the range [1, N * N]\n    inclusive\
    \ appears exactly once on the cells of the grid.\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl7butcg6.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl7butcg6.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    visited = zeros(Int64, n, n)\n    min_path = []\n\
    \    min_path_sum = Inf\n    for i in 1:n, j in 1:n\n        visited[i, j] = 1\n\
    \        path = [grid[i, j]]\n        path_sum = grid[i, j]\n        dfs(grid,\
    \ visited, path, path_sum, min_path, min_path_sum, i, j, k)\n        visited[i,\
    \ j] = 0\n    end\n    return min_path\nend\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpeni_jlu2.jl:49\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpeni_jlu2.jl:39\n   [2] top-level scope at /tmp/tmpeni_jlu2.jl:49\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:50\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  UndefVarError: dfs not defined\n\
    \  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpeni_jlu2.jl:39\n\
    \   [2] top-level scope at /tmp/tmpeni_jlu2.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:51\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpeni_jlu2.jl:39\n   [2] top-level scope at /tmp/tmpeni_jlu2.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:52\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpeni_jlu2.jl:39\n   [2] top-level scope at /tmp/tmpeni_jlu2.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:53\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpeni_jlu2.jl:39\n   [2] top-level scope at /tmp/tmpeni_jlu2.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:54\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpeni_jlu2.jl:39\n   [2] top-level scope at /tmp/tmpeni_jlu2.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:55\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  UndefVarError: dfs not defined\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpeni_jlu2.jl:39\n\
    \   [2] top-level scope at /tmp/tmpeni_jlu2.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:56\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpeni_jlu2.jl:39\n   [2] top-level scope at /tmp/tmpeni_jlu2.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:57\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpeni_jlu2.jl:39\n   [2] top-level scope at /tmp/tmpeni_jlu2.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:58\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpeni_jlu2.jl:39\n   [2] top-level scope at /tmp/tmpeni_jlu2.jl:58\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpeni_jlu2.jl:59\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpeni_jlu2.jl:39\n   [2] top-level scope at /tmp/tmpeni_jlu2.jl:59\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeni_jlu2.jl:48\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeni_jlu2.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpuqwzcqql.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuqwzcqql.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpuqwzcqql.jl:32\\n   [2] top-level scope at /tmp/tmpuqwzcqql.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuqwzcqql.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    11     11\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return grid\n    end\n    if k == n\n        return\
    \ [grid[1,1], grid[2,1], grid[3,1], grid[3,2], grid[3,3], grid[2,3], grid[1,3],\
    \ grid[1,2]]\n    end\n    if k == n + 1\n        return [grid[1,1], grid[2,1],\
    \ grid[3,1], grid[3,2], grid[3,3], grid[2,3], grid[1,3], grid[1,2], grid[2,2]]\n\
    \    end\n    if k == n + 2\n        return [grid[1,1], grid[2,1], grid[3,1],\
    \ grid[3,2], grid[3,3], grid[2,3], grid[1,3], grid[1,2], grid[2,2], grid[2,1]]\n\
    \    end\n    if k == n + 3\n        return [grid[1,1], grid[2,1], grid[3,1],\
    \ grid[3,2], grid[3,3], grid[2,3], grid[1,3], grid[1,2], grid[2,2], grid[2,1],\
    \ grid[3,1]]\n    end\n    if k == n + 4\n        return [grid[1,1], grid[2,1],\
    \ grid[3,1], grid[3,2], grid[3,3], grid[2,3], grid[1,3], grid[1,2], grid[2,2],\
    \ grid[2,1], grid[3,1], grid[3,2]]\n    end\n    if k == n + 5\n        return\
    \ [grid[1,1], grid[2,1], grid[3,1], grid[3,2], grid[3,3], grid[2,3], grid[1,3],\
    \ grid[1,2], grid[2,2], grid[2,1], grid[3,1], grid[3,2], grid[3,3]]\n    end\n\
    \    if k\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvgfo2msp.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvgfo2msp.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp768qn0h2.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp768qn0h2.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # The following function returns the neighbors of\
    \ a cell (x, y)\n    # in the grid.\n    function neighbors(x::Int64, y::Int64)::Vector{Tuple{Int64,\
    \ Int64}}\n        return [ (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1) ]\n\
    \    end\n    # The following function returns the value of a cell (x, y) in the\
    \ grid.\n    function value(x::Int64, y::Int64)::Int64\n        return grid[x][y]\n\
    \    end\n    # The following function returns the minimum path of length k starting\n\
    \    # from a cell (x, y) in the grid.\n    function minPath(x::Int64, y::Int64)::Vector{Int64}\n\
    \        # We use a dynamic programming approach to solve this problem.\n    \
    \    # We use a 2D array to store the minimum path of length i starting\n    \
    \    # from cell (x, y).\n        # The following array stores the minimum path\
    \ of length i starting\n        # from cell (x, y).\n        dp = Vector{Vector{Int64}}(undef,\
    \ k + 1)\n        for i = 1:k + 1\n            dp[i] = Vector{Int64}(undef, N)\n\
    \            for j = 1:N\n                dp[i][j] = Vector{Int64}(undef, N)\n\
    \            end\n        end\n        # The following array stores the previous\
    \ cell of the minimum path\n        # of length i starting from cell (x, y).\n\
    \        prev = Vector{Vector{Tuple{Int64, Int64}}}(undef, k + 1)\n        for\
    \ i = 1:k + 1\n            prev[i] = Vector{Tuple{Int64, Int64}}(undef, N)\n \
    \           for j = 1:N\n                prev[i][j] = Vector{Tuple{Int64, Int64}}(undef,\
    \ N)\n            end\n        end\n        # We initialize the base case.\n \
    \       for i = 1:N\n            for j = 1:N\n                dp[1][i][j] = value\n\
    using Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2,\
    \ 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4,\
    \ 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8],\
    \ [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmprzqu1mrm.jl:67\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmprzqu1mrm.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmprzqu1mrm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmpt3xlec.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpmpt3xlec.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpmpt3xlec.jl:32\n   [2] top-level scope at /tmp/tmpmpt3xlec.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmpt3xlec.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmpt3xlec.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N * N\n        return [grid[i,j] for i in 1:N, j in 1:N]\n    end\n\
    \    # find the path with the minimum value\n    min_val = Inf\n    min_path =\
    \ []\n    for i in 1:N\n        for j in 1:N\n            path = [grid[i,j]]\n\
    \            visited = Set([(i,j)])\n            dfs(grid, i, j, k-1, path, visited)\n\
    \            if path[end] < min_val\n                min_val = path[end]\n   \
    \             min_path = path\n            end\n        end\n    end\n    return\
    \ min_path\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp066pryln.jl:59\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp066pryln.jl:45\n   [2] top-level scope at /tmp/tmp066pryln.jl:59\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:60\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{Int64,1}(::Array{Array{Int64,1},1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp066pryln.jl:33\n   [6] top-level scope at /tmp/tmp066pryln.jl:60\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:61\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp066pryln.jl:45\n   [2] top-level scope at /tmp/tmp066pryln.jl:61\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:62\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp066pryln.jl:45\n   [2] top-level scope at /tmp/tmp066pryln.jl:62\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:63\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp066pryln.jl:45\n   [2] top-level scope at /tmp/tmp066pryln.jl:63\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:64\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp066pryln.jl:45\n   [2] top-level scope at /tmp/tmp066pryln.jl:64\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:65\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  UndefVarError: dfs not defined\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp066pryln.jl:45\n\
    \   [2] top-level scope at /tmp/tmp066pryln.jl:65\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:66\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp066pryln.jl:45\n   [2] top-level scope at /tmp/tmp066pryln.jl:66\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:67\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp066pryln.jl:45\n   [2] top-level scope at /tmp/tmp066pryln.jl:67\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:68\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp066pryln.jl:45\n   [2] top-level scope at /tmp/tmp066pryln.jl:68\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp066pryln.jl:69\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp066pryln.jl:45\n   [2] top-level scope at /tmp/tmp066pryln.jl:69\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp066pryln.jl:58\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp066pryln.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6qjt28cv.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp6qjt28cv.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp6qjt28cv.jl:32\n   [2] top-level scope at /tmp/tmp6qjt28cv.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6qjt28cv.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6qjt28cv.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    m = length(grid[1])\n    # @assert n == m\n    #\
    \ @assert k <= n * m\n    # @assert k >= 1\n    # @assert all(all(1 <= grid[i][j]\
    \ <= n * m for j in 1:m) for i in 1:n)\n    # @assert all(all(grid[i][j] in grid[i]\
    \ for j in 1:m) for i in 1:n)\n    # @assert all(all(grid[i][j] in [grid[i][k]\
    \ for k in 1:m] for j in 1:m) for i in 1:n)\n    # @assert all(all(grid[i][j]\
    \ in [grid[k][j] for k in 1:n] for j in 1:m) for i in 1:n)\n    # @assert all(all(grid[i][j]\
    \ in [grid[i + 1][j] for i in 1:n - 1] for j in 1:m) for i in 1:n)\n    # @assert\
    \ all(all(grid[i][j] in [grid[i - 1][j] for i in 2:n] for j in 1:m) for i in 1:n)\n\
    \    # @assert all(all(grid[i][j] in [grid[i][j + 1] for j in 1:m - 1] for j in\
    \ 1:m) for i in 1:n)\n    # @assert all(all(grid[i][j] in [grid[i][j - 1] for\
    \ j in 2:m] for j in 1:m) for i in 1:n)\n    # @assert all(all(grid[i][j] in [grid[i\
    \ + 1][j], grid[i - 1][j], grid[i][j + 1], grid[i][j - 1] for i in 1:n - 1, j\
    \ in 1:m - 1] for j in 1:m) for i in 1:n)\n    # @assert all(all(grid[i][j] in\
    \ [grid[i + 1][j], grid[i - 1][j], grid[i][j + 1], grid[\nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfkkh24z_.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpfkkh24z_.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpfkkh24z_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp9hgos6q7.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9hgos6q7.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp9hgos6q7.jl:32\\n   [2] top-level scope at /tmp/tmp9hgos6q7.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9hgos6q7.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    11     11\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    @assert N >= 2 \"N should be greater than or equal\
    \ to 2\"\n    @assert k >= 1 \"k should be greater than or equal to 1\"\n    @assert\
    \ k <= N * N \"k should be less than or equal to N * N\"\n    @assert all(length(row)\
    \ == N for row in grid) \"grid should be a square matrix\"\n    @assert all(1\
    \ <= val <= N * N for row in grid for val in row) \"grid should contain values\
    \ in the range [1, N * N]\"\n    @assert all(length(unique(row)) == N for row\
    \ in grid) \"grid should contain each value in the range [1, N * N] exactly once\"\
    \n    # TODO: implement the solution\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw635brg0.jl:46\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpw635brg0.jl:46\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw635brg0.jl:45\ntest set: Test Failed at /tmp/tmpw635brg0.jl:47\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpw635brg0.jl:47\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw635brg0.jl:45\ntest set: Test Failed at /tmp/tmpw635brg0.jl:48\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw635brg0.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw635brg0.jl:45\ntest set: Test Failed at /tmp/tmpw635brg0.jl:49\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpw635brg0.jl:49\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw635brg0.jl:45\ntest set: Test Failed at /tmp/tmpw635brg0.jl:50\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw635brg0.jl:50\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw635brg0.jl:45\ntest set: Test Failed at /tmp/tmpw635brg0.jl:51\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpw635brg0.jl:51\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw635brg0.jl:45\ntest set: Test Failed at /tmp/tmpw635brg0.jl:52\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpw635brg0.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw635brg0.jl:45\ntest set: Test Failed at /tmp/tmpw635brg0.jl:53\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw635brg0.jl:53\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw635brg0.jl:45\ntest set: Test Failed at /tmp/tmpw635brg0.jl:54\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw635brg0.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw635brg0.jl:45\ntest set: Error During Test at\
    \ /tmp/tmpw635brg0.jl:55\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  AssertionError: k should\
    \ be less than or equal to N * N\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpw635brg0.jl:34\n   [2] top-level scope at /tmp/tmpw635brg0.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw635brg0.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpw635brg0.jl:56\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  AssertionError: k should\
    \ be less than or equal to N * N\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpw635brg0.jl:34\n   [2] top-level scope at /tmp/tmpw635brg0.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw635brg0.jl:45\n  \nTest Summary: | Fail  Error\
    \  Total\ntest set      |    9      2     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 9 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw635brg0.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpldmuu3g2.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpldmuu3g2.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpldmuu3g2.jl:32\n   [2] top-level scope at /tmp/tmpldmuu3g2.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpldmuu3g2.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpldmuu3g2.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppi9a6650.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmppi9a6650.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmppi9a6650.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppi9a6650.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmppi9a6650.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmppi9a6650.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmppi9a6650.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmppi9a6650.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppi9a6650.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppi9a6650.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmppi9a6650.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\ntest set: Test Failed at /tmp/tmppi9a6650.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmppi9a6650.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppi9a6650.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppi9a6650.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    \"\"\"\n    Finds the minimum path of length k in the grid.\n    \"\"\"\
    \n    # Get the size of the grid.\n    N = size(grid, 1)\n    # Get the number\
    \ of cells in the grid.\n    n = N * N\n    # Get the number of possible paths\
    \ of length k.\n    paths = nchoosek(n, k)\n    # Initialize the minimum path.\n\
    \    min_path = Vector{Int64}(k)\n    # Initialize the minimum path value.\n \
    \   min_path_value = Inf\n    # Initialize the current path.\n    current_path\
    \ = Vector{Int64}(k)\n    # Initialize the current path value.\n    current_path_value\
    \ = 0\n    # Initialize the current path index.\n    current_path_index = 1\n\
    \    # Initialize the current cell.\n    current_cell = 1\n    # Initialize the\
    \ current cell value.\n    current_cell_value = grid[1, 1]\n    # Initialize the\
    \ current cell row.\n    current_cell_row = 1\n    # Initialize the current cell\
    \ column.\n    current_cell_column = 1\n    # Initialize the current cell index.\n\
    \    current_cell_index = 1\n    # Initialize the current path length.\n    current_path_length\
    \ = 0\n    # Initialize the current path length.\n    current_path_length = 0\n\
    \    # Initialize the current path length.\n    current_path_length = 0\n    #\
    \ Initialize the current path length.\n    current_path_length = 0\n    # Initialize\
    \ the current path length.\n    current_path_length = 0\n    # Initialize the\
    \ current path length.\n    current_path_length = 0\n    # Initialize the current\
    \ path length.\n    current_path_length = 0\n    # Initialize the current path\
    \ length.\n    current_path_length = 0\n    # Initialize the current path length.\n\
    \    current_path_length = 0\n    # Initialize the current path length.\n    current_path_length\
    \ = 0\n    # Initialize the current path length.\n    current_path_length = 0\n\
    \    # Initialize the current path length.\n    current_path_length =\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_r1jom0u.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp_r1jom0u.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp_r1jom0u.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N * N\n        return [grid[i,j] for i in 1:N, j in 1:N]\n    end\n\
    \    if k < N\n        return [grid[1,i] for i in 1:k]\n    end\n    if k < 2\
    \ * N\n        return [grid[1,i] for i in 1:N] * [grid[1,i] for i in 1:k-N]\n\
    \    end\n    if k < 3 * N\n        return [grid[1,i] for i in 1:N] * [grid[1,i]\
    \ for i in 1:N] * [grid[1,i] for i in 1:k-2*N]\n    end\n    if k < 4 * N\n  \
    \      return [grid[1,i] for i in 1:N] * [grid[1,i] for i in 1:N] * [grid[1,i]\
    \ for i in 1:N] * [grid[1,i] for i in 1:k-3*N]\n    end\n    if k < 5 * N\n  \
    \      return [grid[1,i] for i in 1:N] * [grid[1,i] for i in 1:N] * [grid[1,i]\
    \ for i in 1:N] * [grid[1,i] for i in 1:N] * [grid[1,i] for i in 1:k-4*N]\n  \
    \  end\n    if k < 6 * N\n        return [grid[1,i] for i in 1:N] * [grid[1,i]\
    \ for i in 1:N] * [grid[1,i] for i in 1:N] * [grid[1,i] for i in 1:N] * [grid[1,i]\
    \ for i in 1:N] * [grid[1,i] for i in 1:k-5*N]\n    end\n    if k < 7 * N\n  \
    \      return [grid[1,i] for i in 1:N] * [grid[1,i] for i in 1:N] * [\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpac4yxaob.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpac4yxaob.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    # find the minimum value in the grid\n    min_val = grid[1,1]\n    for i\
    \ in 1:N\n        for j in 1:N\n            if grid[i,j] < min_val\n         \
    \       min_val = grid[i,j]\n            end\n        end\n    end\n    # find\
    \ the minimum path\n    min_path = []\n    for i in 1:N\n        for j in 1:N\n\
    \            if grid[i,j] == min_val\n                min_path = [grid[i,j]]\n\
    \                break\n            end\n        end\n    end\n    # find the\
    \ minimum path\n    while length(min_path) < k\n        # find the minimum value\
    \ in the grid\n        min_val = grid[1,1]\n        for i in 1:N\n           \
    \ for j in 1:N\n                if grid[i,j] < min_val\n                    min_val\
    \ = grid[i,j]\n                end\n            end\n        end\n        # find\
    \ the minimum path\n        for i in 1:N\n            for j in 1:N\n         \
    \       if grid[i,j] == min_val\n                    min_path = [grid[i,j]]\n\
    \                    break\n                end\n            end\n        end\n\
    \    end\n    return min_path\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpu3favisj.jl:82\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  BoundsError: attempt to access 3-element Array{Array{Int64,1},1} at index [1,\
    \ 2]\n  Stacktrace:\n   [1] getindex at ./array.jl:789 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpu3favisj.jl:39\n   [3] top-level scope at /tmp/tmpu3favisj.jl:82\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:83\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::Array{Int64,1}, ::Int64) at ./array.jl:826\n\
    \   [2] copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{Int64,1}(::Array{Array{Int64,1},1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpu3favisj.jl:33\n   [6] top-level scope at /tmp/tmpu3favisj.jl:83\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:84\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1} at index\
    \ [1, 2]\n  Stacktrace:\n   [1] getindex at ./array.jl:789 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpu3favisj.jl:39\n   [3] top-level scope at /tmp/tmpu3favisj.jl:84\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:85\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1}\
    \ at index [1, 2]\n  Stacktrace:\n   [1] getindex at ./array.jl:789 [inlined]\n\
    \   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpu3favisj.jl:39\n\
    \   [3] top-level scope at /tmp/tmpu3favisj.jl:85\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:86\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1} at\
    \ index [1, 2]\n  Stacktrace:\n   [1] getindex at ./array.jl:789 [inlined]\n \
    \  [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpu3favisj.jl:39\n\
    \   [3] top-level scope at /tmp/tmpu3favisj.jl:86\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:87\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1}\
    \ at index [1, 2]\n  Stacktrace:\n   [1] getindex at ./array.jl:789 [inlined]\n\
    \   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpu3favisj.jl:39\n\
    \   [3] top-level scope at /tmp/tmpu3favisj.jl:87\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:88\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  BoundsError: attempt to access 4-element Array{Array{Int64,1},1}\
    \ at index [1, 2]\n  Stacktrace:\n   [1] getindex at ./array.jl:789 [inlined]\n\
    \   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpu3favisj.jl:39\n\
    \   [3] top-level scope at /tmp/tmpu3favisj.jl:88\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:89\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  BoundsError:\
    \ attempt to access 3-element Array{Array{Int64,1},1} at index [1, 2]\n  Stacktrace:\n\
    \   [1] getindex at ./array.jl:789 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpu3favisj.jl:39\n   [3] top-level scope at /tmp/tmpu3favisj.jl:89\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:90\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  BoundsError:\
    \ attempt to access 3-element Array{Array{Int64,1},1} at index [1, 2]\n  Stacktrace:\n\
    \   [1] getindex at ./array.jl:789 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpu3favisj.jl:39\n   [3] top-level scope at /tmp/tmpu3favisj.jl:90\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:91\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  BoundsError: attempt to\
    \ access 2-element Array{Array{Int64,1},1} at index [1, 2]\n  Stacktrace:\n  \
    \ [1] getindex at ./array.jl:789 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpu3favisj.jl:39\n   [3] top-level scope at /tmp/tmpu3favisj.jl:91\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3favisj.jl:92\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  BoundsError: attempt to\
    \ access 2-element Array{Array{Int64,1},1} at index [1, 2]\n  Stacktrace:\n  \
    \ [1] getindex at ./array.jl:789 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpu3favisj.jl:39\n   [3] top-level scope at /tmp/tmpu3favisj.jl:92\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpu3favisj.jl:81\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu3favisj.jl:79\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    N = length(grid)\n    @assert N >= 2\n    @assert\
    \ k >= 1\n    @assert N * N == length(unique(grid))\n    @assert all(1 <= grid[i][j]\
    \ <= N * N for i in 1:N, j in 1:N)\n    #\n    #\n    #\n    return grid\nend\n\
    using Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2,\
    \ 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4,\
    \ 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8],\
    \ [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp62tp__7y.jl:48\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  AssertionError: N * N == length(unique(grid))\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp62tp__7y.jl:36\n   [2] top-level scope at /tmp/tmp62tp__7y.jl:48\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:49\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  AssertionError: N * N == length(unique(grid))\n\
    \  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp62tp__7y.jl:36\n\
    \   [2] top-level scope at /tmp/tmp62tp__7y.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:50\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  AssertionError: N * N == length(unique(grid))\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp62tp__7y.jl:36\n   [2] top-level scope at /tmp/tmp62tp__7y.jl:50\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:51\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  AssertionError: N * N == length(unique(grid))\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp62tp__7y.jl:36\n\
    \   [2] top-level scope at /tmp/tmp62tp__7y.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:52\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  AssertionError: N * N == length(unique(grid))\n  Stacktrace:\n   [1]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp62tp__7y.jl:36\n   [2]\
    \ top-level scope at /tmp/tmp62tp__7y.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:53\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  AssertionError: N * N == length(unique(grid))\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp62tp__7y.jl:36\n\
    \   [2] top-level scope at /tmp/tmp62tp__7y.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:54\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  AssertionError: N * N == length(unique(grid))\n\
    \  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp62tp__7y.jl:36\n\
    \   [2] top-level scope at /tmp/tmp62tp__7y.jl:54\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:55\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  AssertionError:\
    \ N * N == length(unique(grid))\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp62tp__7y.jl:36\n   [2] top-level scope at /tmp/tmp62tp__7y.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:56\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  AssertionError:\
    \ N * N == length(unique(grid))\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp62tp__7y.jl:36\n   [2] top-level scope at /tmp/tmp62tp__7y.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:57\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  AssertionError: N * N\
    \ == length(unique(grid))\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp62tp__7y.jl:36\n   [2] top-level scope at /tmp/tmp62tp__7y.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmp62tp__7y.jl:58\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  AssertionError: N * N\
    \ == length(unique(grid))\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp62tp__7y.jl:36\n   [2] top-level scope at /tmp/tmp62tp__7y.jl:58\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62tp__7y.jl:47\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp62tp__7y.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement your solution here\n    return []\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpwcw8fa4d.jl:39\\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:40\\\
    n  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n   Evaluated:\
    \ Int64[] == [1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:41\\\
    n  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:42\\\
    n  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:43\\\
    n  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:44\\\
    n  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:44\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:45\\\
    n  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmpwcw8fa4d.jl:45\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:46\\\
    n  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:46\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:47\\\
    n  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:48\\\
    n  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:48\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\ntest set: Test Failed at /tmp/tmpwcw8fa4d.jl:49\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwcw8fa4d.jl:49\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwcw8fa4d.jl:38\\nTest Summary: | Fail  Total\\\
    ntest set      |   11     11\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfq1bzg_m.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpfq1bzg_m.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpfq1bzg_m.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfq1bzg_m.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpfq1bzg_m.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpfq1bzg_m.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpfq1bzg_m.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpfq1bzg_m.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfq1bzg_m.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfq1bzg_m.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpfq1bzg_m.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\ntest set: Test Failed at /tmp/tmpfq1bzg_m.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpfq1bzg_m.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfq1bzg_m.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfq1bzg_m.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa1xf61pr.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1xf61pr.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpa1xf61pr.jl:32\n   [2] top-level scope at /tmp/tmpa1xf61pr.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1xf61pr.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa1xf61pr.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpms04zw_x.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpms04zw_x.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpms04zw_x.jl:32\\n   [2] top-level scope at /tmp/tmpms04zw_x.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpms04zw_x.jl:37\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpewu33sop.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpewu33sop.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpewu33sop.jl:32\n   [2] top-level scope at /tmp/tmpewu33sop.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpewu33sop.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpewu33sop.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeyy2_zdo.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpeyy2_zdo.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpeyy2_zdo.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeyy2_zdo.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpeyy2_zdo.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeyy2_zdo.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpeyy2_zdo.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpeyy2_zdo.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeyy2_zdo.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeyy2_zdo.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpeyy2_zdo.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\ntest set: Test Failed at /tmp/tmpeyy2_zdo.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpeyy2_zdo.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeyy2_zdo.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeyy2_zdo.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqu3ihc1d.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqu3ihc1d.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code goes here\n    return []\nend\n\"\"\"\n    Given a grid with\
    \ N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the\
    \ grid contains a value. Every integer in the range [1, N * N]\n    inclusive\
    \ appears exactly once on the cells of the grid.\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp01pwjmoz.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp01pwjmoz.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    \"\"\"\n    This function returns the minimum path of length k in the\
    \ grid.\n    \"\"\"\n    N = length(grid)\n    # We will use a priority queue\
    \ to store the paths.\n    # The priority queue will be ordered by the lexicographical\
    \ order of the\n    # paths.\n    # The paths will be represented as a tuple (path,\
    \ current_cell).\n    # The path is a vector of the values on the cells that the\
    \ path goes through.\n    # The current_cell is a tuple (row, column) which represents\
    \ the current\n    # cell of the path.\n    pq = PriorityQueue()\n    # We will\
    \ use a set to store the visited cells.\n    # The cells will be represented as\
    \ a tuple (row, column).\n    visited = Set()\n    # We will use a dictionary\
    \ to store the minimum path for each cell.\n    # The keys of the dictionary are\
    \ the cells.\n    # The values of the dictionary are the minimum path for the\
    \ cell.\n    min_paths = Dict()\n    # We will use a dictionary to store the minimum\
    \ path length for each cell.\n    # The keys of the dictionary are the cells.\n\
    \    # The values of the dictionary are the minimum path length for the cell.\n\
    \    min_path_lengths = Dict()\n    # We will use a dictionary to store the neighbors\
    \ of each cell.\n    # The keys of the dictionary are the cells.\n    # The values\
    \ of the dictionary are the neighbors of the cell.\n    neighbors = Dict()\n \
    \   # We will use a dictionary to store the value of each cell.\n    # The keys\
    \ of the dictionary are the cells.\n    # The values of the dictionary are the\
    \ value of the cell.\n    values = Dict()\n    # We will use a dictionary to store\
    \ the row of each cell.\n    # The keys of the dictionary are the cells.\n   \
    \ # The values of the dictionary are the row of the cell.\n    rows = Dict()\n\
    \    # We will use a dictionary to store the column of each cell.\n    # The keys\
    \ of the dictionary are the cells.\n    # The values of the dictionary are the\
    \ column of the cell.\n    columns = Dict()\n    # We will use a dictionary to\
    \ store the index of each cell.\n    # The keys of the dictionary\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpar1o789k.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpar1o789k.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpar1o789k.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmplwe3qveh.jl:39\\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplwe3qveh.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:40\\\
    n  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n   Evaluated:\
    \ Int64[] == [1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplwe3qveh.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:41\\\
    n  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplwe3qveh.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:42\\\
    n  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplwe3qveh.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:43\\\
    n  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmplwe3qveh.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:44\\\
    n  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplwe3qveh.jl:44\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:45\\\
    n  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmplwe3qveh.jl:45\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:46\\\
    n  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplwe3qveh.jl:46\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:47\\\
    n  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplwe3qveh.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:48\\\
    n  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplwe3qveh.jl:48\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\ntest set: Test Failed at /tmp/tmplwe3qveh.jl:49\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplwe3qveh.jl:49\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplwe3qveh.jl:38\\nTest Summary: | Fail  Total\\\
    ntest set      |   11     11\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphgbj21a_.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphgbj21a_.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphgbj21a_.jl:32\n   [2] top-level scope at /tmp/tmphgbj21a_.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphgbj21a_.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphgbj21a_.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n\n        return [grid[i,i] for i in 1:n]\n    end\n    if k ==\
    \ n * n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n    if k\
    \ < n\n        return [grid[i,i] for i in 1:k]\n    end\n    if k > n * n - n\n\
    \        return [grid[i,j] for i in 1:n, j in 1:n][1:k]\n    end\n    if k % n\
    \ == 0\n        return [grid[i,i] for i in 1:n] * (k // n)\n    end\n    if k\
    \ % n == 1\n        return [grid[i,i] for i in 1:n] * (k // n) .+ [grid[1,1]]\n\
    \    end\n    if k % n == 2\n        return [grid[i,i] for i in 1:n] * (k // n)\
    \ .+ [grid[1,1], grid[2,2]]\n    end\n    if k % n == 3\n        return [grid[i,i]\
    \ for i in 1:n] * (k // n) .+ [grid[1,1], grid[2,2], grid[1,1]]\n    end\n   \
    \ if k % n == 4\n        return [grid[i,i] for i in 1:n] * (k // n) .+ [grid[1,1],\
    \ grid[2,2], grid[1,1], grid[2,2]]\n    end\n    if k % n == 5\n        return\
    \ [grid[i,i] for i in 1:n] * (k // n) .+ [grid[1,1], grid[2,2], grid[1,1], grid[2,2],\
    \ grid[1,1]]\n    end\n    if k % n == 6\n        return [grid[i,i] for i in 1:n]\
    \ * (k // n) .+ [grid[1,1], grid[2,2], grid[1,\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing separator in array expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4yyyv1hv.jl:69\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4yyyv1hv.jl:69\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # create a matrix of size NxNxNxNxN, where the first\
    \ two dimensions are \n    # the starting point, the third dimension is the length\
    \ of the path, and\n    # the last two dimensions are the path\n    dp = zeros(Int64,\
    \ N, N, k, N, N)\n    # initialize the first layer of the matrix\n    for i in\
    \ 1:N, j in 1:N\n        dp[i, j, 1, i, j] = grid[i, j]\n    end\n    # iterate\
    \ over the length of the path\n    for l in 2:k\n        # iterate over the starting\
    \ point\n        for i in 1:N, j in 1:N\n            # iterate over the previous\
    \ point\n            for ii in 1:N, jj in 1:N\n                # if the previous\
    \ point is not adjacent to the current point,\n                # skip it\n   \
    \             if abs(i - ii) + abs(j - jj) != 1\n                    continue\n\
    \                end\n                # if the previous point is adjacent to the\
    \ current point,\n                # update the current point\n               \
    \ dp[i, j, l, i, j] = max(dp[i, j, l, i, j], dp[ii, jj, l - 1, ii, jj])\n    \
    \        end\n        end\n    end\n    # find the minimum path\n    min_path\
    \ = zeros(Int64, k)\n    min_val = Inf\n    for i in 1:N, j in 1:N\n        if\
    \ dp[i, j, k, i, j] < min_val\n            min_val = dp[i, j, k, i, j]\n     \
    \       min_path = [grid[i, j]]\n        elseif dp[i, j, k, i, j] == min_val\n\
    \            min_path = [min_path; grid[i, j]]\n        end\n    end\n    # return\
    \ the minimum path\n    return min_path\nend\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7mdb27hc.jl:76\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7mdb27hc.jl:38\n\
    \   [3] top-level scope at /tmp/tmp7mdb27hc.jl:76\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:77\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp7mdb27hc.jl:38\n   [3] top-level scope at /tmp/tmp7mdb27hc.jl:77\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:78\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7mdb27hc.jl:38\n\
    \   [3] top-level scope at /tmp/tmp7mdb27hc.jl:78\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:79\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7mdb27hc.jl:38\n\
    \   [3] top-level scope at /tmp/tmp7mdb27hc.jl:79\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:80\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1} to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7mdb27hc.jl:38\n\
    \   [3] top-level scope at /tmp/tmp7mdb27hc.jl:80\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:81\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7mdb27hc.jl:38\n\
    \   [3] top-level scope at /tmp/tmp7mdb27hc.jl:81\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:82\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Array{Int64,1} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828\
    \ [inlined]\n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7mdb27hc.jl:38\n\
    \   [3] top-level scope at /tmp/tmp7mdb27hc.jl:82\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:83\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828 [inlined]\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7mdb27hc.jl:38\n   [3]\
    \ top-level scope at /tmp/tmp7mdb27hc.jl:83\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:84\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Array{Int64,1} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at\
    \ number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n\
    \    ...\n  Stacktrace:\n   [1] setindex! at ./array.jl:828 [inlined]\n   [2]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7mdb27hc.jl:38\n   [3]\
    \ top-level scope at /tmp/tmp7mdb27hc.jl:84\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:85\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp7mdb27hc.jl:38\n   [3] top-level scope at /tmp/tmp7mdb27hc.jl:85\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \ntest set: Error During\
    \ Test at /tmp/tmp7mdb27hc.jl:86\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Array{Int64,1} to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex! at ./array.jl:828 [inlined]\n   [2] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp7mdb27hc.jl:38\n   [3] top-level scope at /tmp/tmp7mdb27hc.jl:86\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp7mdb27hc.jl:75\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7mdb27hc.jl:73\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\n\"\"\"\n    Given a grid with\
    \ N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the\
    \ grid contains a value. Every integer in the range [1, N * N]\n    inclusive\
    \ appears exactly once on the cells of the grid.\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa1gn4uaj.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpa1gn4uaj.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdghm1nu0.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdghm1nu0.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpt1ipsubh.jl:39\\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpt1ipsubh.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:40\\\
    n  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n   Evaluated:\
    \ Int64[] == [1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpt1ipsubh.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:41\\\
    n  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpt1ipsubh.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:42\\\
    n  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpt1ipsubh.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:43\\\
    n  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpt1ipsubh.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:44\\\
    n  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpt1ipsubh.jl:44\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:45\\\
    n  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmpt1ipsubh.jl:45\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:46\\\
    n  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpt1ipsubh.jl:46\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:47\\\
    n  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpt1ipsubh.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:48\\\
    n  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpt1ipsubh.jl:48\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\ntest set: Test Failed at /tmp/tmpt1ipsubh.jl:49\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpt1ipsubh.jl:49\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt1ipsubh.jl:38\\nTest Summary: | Fail  Total\\\
    ntest set      |   11     11\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    # find the minimum value in the grid\n    min_val = grid[1,1]\n    for i\
    \ in 1:N\n        for j in 1:N\n            if grid[i,j] < min_val\n         \
    \       min_val = grid[i,j]\n            end\n        end\n    end\n    # find\
    \ the minimum path\n    min_path = []\n    for i in 1:N\n        for j in 1:N\n\
    \            if grid[i,j] == min_val\n                path = [grid[i,j]]\n   \
    \             grid[i,j] = -1\n                path = find_path(grid, i, j, path,\
    \ k-1)\n                if length(path) == k\n                    if length(min_path)\
    \ == 0\n                        min_path = path\n                    else\n  \
    \                      if path < min_path\n                            min_path\
    \ = path\n                        end\n                    end\n             \
    \   end\n                grid[i,j] = min_val\n            end\n        end\n \
    \   end\n    return min_path\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpcgb4la0a.jl:72\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  BoundsError: attempt to access 3-element Array{Array{Int64,1},1}\
    \ at index [1, 2]\\n  Stacktrace:\\n   [1] getindex at ./array.jl:789 [inlined]\\\
    n   [2] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpcgb4la0a.jl:39\\\
    n   [3] top-level scope at /tmp/tmpcgb4la0a.jl:72\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpcgb4la0a.jl:71\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpidob01a0.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpidob01a0.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbo6f8xr4.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo6f8xr4.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpbo6f8xr4.jl:32\n   [2] top-level scope at /tmp/tmpbo6f8xr4.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo6f8xr4.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbo6f8xr4.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2xjevfmm.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xjevfmm.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2xjevfmm.jl:32\n   [2] top-level scope at /tmp/tmp2xjevfmm.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2xjevfmm.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2xjevfmm.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9hz7zc8i.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hz7zc8i.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9hz7zc8i.jl:32\n   [2] top-level scope at /tmp/tmp9hz7zc8i.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hz7zc8i.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9hz7zc8i.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if n == 1\n        return grid[1]\n    end\n   \
    \ # find the minimum element\n    min_val = grid[1][1]\n    min_idx = [1, 1]\n\
    \    for i in 1:n\n        for j in 1:n\n            if grid[i][j] < min_val\n\
    \                min_val = grid[i][j]\n                min_idx = [i, j]\n    \
    \        end\n        end\n    end\n    # find the minimum path\n    path = [min_val]\n\
    \    cur_idx = min_idx\n    for i in 1:k-1\n        # find the minimum element\
    \ in the neighborhood\n        min_val = grid[cur_idx[1]][cur_idx[2]]\n      \
    \  min_idx = cur_idx\n        for j in cur_idx[1]-1:cur_idx[1]+1\n           \
    \ for k in cur_idx[2]-1:cur_idx[2]+1\n                if j >= 1 && j <= n && k\
    \ >= 1 && k <= n && grid[j][k] < min_val\n                    min_val = grid[j][k]\n\
    \                    min_idx = [j, k]\n                end\n            end\n\
    \        end\n        push!(path, min_val)\n        cur_idx = min_idx\n    end\n\
    \    return path\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t\
    @test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpl06eovv2.jl:71\\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\\n   Evaluated: [1, 1, 1] == [1,\
    \ 2, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl06eovv2.jl:71\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\ntest set: Test Failed at /tmp/tmpl06eovv2.jl:73\\\
    n  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\\n   Evaluated: [1, 1, 1, 1] == [1, 2, 1, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpl06eovv2.jl:73\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\ntest set: Test Failed at /tmp/tmpl06eovv2.jl:74\\\
    n  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\n   Evaluated: [1, 1, 1, 1, 1, 1,\
    \ 1] == [1, 10, 1, 10, 1, 10, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl06eovv2.jl:74\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\ntest set: Test Failed at /tmp/tmpl06eovv2.jl:75\\\
    n  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\\n   Evaluated: [1, 1, 1, 1, 1] == [1, 7, 1,\
    \ 7, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl06eovv2.jl:75\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\ntest set: Test Failed at /tmp/tmpl06eovv2.jl:76\\\
    n  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\n   Evaluated: [1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1] == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmpl06eovv2.jl:76\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\ntest set: Test Failed at /tmp/tmpl06eovv2.jl:77\\\
    n  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n   Evaluated: [1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpl06eovv2.jl:77\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\ntest set: Test Failed at /tmp/tmpl06eovv2.jl:78\\\
    n  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\\n   Evaluated: [1, 1, 1, 1, 1, 1, 1, 1] == [1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl06eovv2.jl:78\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\ntest set: Test Failed at /tmp/tmpl06eovv2.jl:79\\\
    n  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\\n   Evaluated: [1, 1, 1, 1, 1, 1, 1, 1] == [1, 5, 1, 5, 1, 5, 1,\
    \ 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl06eovv2.jl:79\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\ntest set: Test Failed at /tmp/tmpl06eovv2.jl:80\\\
    n  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\\n   Evaluated: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] == [1, 2, 1, 2, 1, 2, 1, 2,\
    \ 1, 2]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl06eovv2.jl:80\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\ntest set: Test Failed at /tmp/tmpl06eovv2.jl:81\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] == [1, 3, 1, 3, 1, 3, 1, 3,\
    \ 1, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl06eovv2.jl:81\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl06eovv2.jl:70\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n\
    \    # find the minimum value\n    min_val = grid[1,1]\n    for i in 1:n, j in\
    \ 1:n\n        if grid[i,j] < min_val\n            min_val = grid[i,j]\n     \
    \   end\n    end\n    # find the minimum value's position\n    min_pos = []\n\
    \    for i in 1:n, j in 1:n\n        if grid[i,j] == min_val\n            push!(min_pos,\
    \ (i,j))\n        end\n    end\n    # find the minimum path\n    min_path = []\n\
    \    for (i,j) in min_pos\n        path = [grid[i,j]]\n        if i == 1\n   \
    \         if j == 1\n                path = [grid[i,j], grid[i+1,j], grid[i,j+1]]\n\
    \            elseif j == n\n                path = [grid[i,j], grid[i+1,j], grid[i,j-1]]\n\
    \            else\n                path = [grid[i,j], grid[i+1,j], grid[i,j-1],\
    \ grid[i,j+1]]\n            end\n        elseif i == n\n            if j == 1\n\
    \                path = [grid[i,j], grid[i-1,j], grid[i,j+1]]\n            elseif\
    \ j == n\n                path = [grid[i,j], grid[i-1,j], grid[i,j-1]]\n     \
    \       else\n                path = [grid[i,j], grid[i-1,j], grid[i,j-1], grid[i,j+1]]\n\
    \            end\n        else\n            if j == 1\n                path =\
    \ [grid[i,j], grid[i-1,j], grid[i,j+1], grid[i+1,j]]\n            elseif j ==\
    \ n\n                path = [grid[\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeogv634z.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpeogv634z.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: implement your solution here\n    return []\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu1ejtmz_.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpu1ejtmz_.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpu1ejtmz_.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu1ejtmz_.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpu1ejtmz_.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpu1ejtmz_.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpu1ejtmz_.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpu1ejtmz_.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu1ejtmz_.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu1ejtmz_.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpu1ejtmz_.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\ntest set: Test Failed at /tmp/tmpu1ejtmz_.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpu1ejtmz_.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu1ejtmz_.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu1ejtmz_.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdvgsw6pa.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdvgsw6pa.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdvgsw6pa.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdvgsw6pa.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdvgsw6pa.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdvgsw6pa.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdvgsw6pa.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpdvgsw6pa.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdvgsw6pa.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdvgsw6pa.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpdvgsw6pa.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\ntest set: Test Failed at /tmp/tmpdvgsw6pa.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpdvgsw6pa.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdvgsw6pa.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdvgsw6pa.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code goes here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6s88ls09.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp6s88ls09.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmp6s88ls09.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6s88ls09.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp6s88ls09.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6s88ls09.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp6s88ls09.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp6s88ls09.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6s88ls09.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6s88ls09.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp6s88ls09.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\ntest set: Test Failed at /tmp/tmp6s88ls09.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp6s88ls09.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6s88ls09.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6s88ls09.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpai7_miz_.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpai7_miz_.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpai7_miz_.jl:32\n   [2] top-level scope at /tmp/tmpai7_miz_.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpai7_miz_.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpai7_miz_.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp80t0divd.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp80t0divd.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmp80t0divd.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp80t0divd.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp80t0divd.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp80t0divd.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp80t0divd.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp80t0divd.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp80t0divd.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp80t0divd.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp80t0divd.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\ntest set: Test Failed at /tmp/tmp80t0divd.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp80t0divd.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp80t0divd.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp80t0divd.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpe6i04igo.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6i04igo.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpe6i04igo.jl:32\n   [2] top-level scope at /tmp/tmpe6i04igo.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6i04igo.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe6i04igo.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement me!\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpy2pv0dg9.jl:39\\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:40\\\
    n  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n   Evaluated:\
    \ Int64[] == [1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:41\\\
    n  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:42\\\
    n  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:43\\\
    n  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:44\\\
    n  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:44\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:45\\\
    n  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmpy2pv0dg9.jl:45\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:46\\\
    n  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:46\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:47\\\
    n  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:48\\\
    n  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:48\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\ntest set: Test Failed at /tmp/tmpy2pv0dg9.jl:49\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpy2pv0dg9.jl:49\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy2pv0dg9.jl:38\\nTest Summary: | Fail  Total\\\
    ntest set      |   11     11\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    # create a matrix to store the minimum path\n    min_path = zeros(Int64,\
    \ n, n)\n    # create a matrix to store the minimum path length\n    min_path_length\
    \ = zeros(Int64, n, n)\n    # create a matrix to store the minimum path value\n\
    \    min_path_value = zeros(Int64, n, n)\n    # create a matrix to store the minimum\
    \ path index\n    min_path_index = zeros(Int64, n, n)\n    # create a matrix to\
    \ store the minimum path value\n    min_path_value = zeros(Int64, n, n)\n    #\
    \ create a matrix to store the minimum path index\n    min_path_index = zeros(Int64,\
    \ n, n)\n    # create a matrix to store the minimum path value\n    min_path_value\
    \ = zeros(Int64, n, n)\n    # create a matrix to store the minimum path index\n\
    \    min_path_index = zeros(Int64, n, n)\n    # create a matrix to store the minimum\
    \ path value\n    min_path_value = zeros(Int64, n, n)\n    # create a matrix to\
    \ store the minimum path index\n    min_path_index = zeros(Int64, n, n)\n    #\
    \ create a matrix to store the minimum path value\n    min_path_value = zeros(Int64,\
    \ n, n)\n    # create a matrix to store the minimum path index\n    min_path_index\
    \ = zeros(Int64, n, n)\n    # create a matrix to store the minimum path value\n\
    \    min_path_value = zeros(Int64, n, n)\n    # create a matrix to store the minimum\
    \ path index\n    min_path_index = zeros(Int64, n, n)\n    # create a matrix to\
    \ store the minimum path value\n    min_path_value = zeros(Int64, n, n)\n    #\
    \ create a matrix to store the minimum path index\n    min_path_index = zeros(Int64,\
    \ n, n)\n    # create a matrix to store\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpj67oxdmw.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpj67oxdmw.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpj67oxdmw.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprza8spw1.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprza8spw1.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpyf7ok2jy.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpyf7ok2jy.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpyf7ok2jy.jl:32\n   [2] top-level scope at /tmp/tmpyf7ok2jy.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyf7ok2jy.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyf7ok2jy.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphlolz023.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmphlolz023.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmphlolz023.jl:32\n   [2] top-level scope at /tmp/tmphlolz023.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphlolz023.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphlolz023.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement me!\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoqernxuv.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpoqernxuv.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpoqernxuv.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoqernxuv.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpoqernxuv.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpoqernxuv.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpoqernxuv.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpoqernxuv.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoqernxuv.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoqernxuv.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpoqernxuv.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\ntest set: Test Failed at /tmp/tmpoqernxuv.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpoqernxuv.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqernxuv.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoqernxuv.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    visited = zeros(Int64, n, n)\n    visited[1, 1]\
    \ = 1\n    min_path = [grid[1, 1]]\n    min_path_sum = grid[1, 1]\n    min_path_len\
    \ = 1\n    min_path_visited = visited\n    min_path_visited[1, 1] = 1\n    min_path_visited_sum\
    \ = 1\n    min_path_visited_len = 1\n    queue = [([grid[1, 1]], 1, 1, 1, 1, 1)]\n\
    \    while !isempty(queue)\n        path, path_sum, path_len, i, j, visited_sum\
    \ = popfirst!(queue)\n        if path_len == k\n            if path_sum < min_path_sum\
    \ || (path_sum == min_path_sum && path < min_path)\n                min_path =\
    \ path\n                min_path_sum = path_sum\n                min_path_len\
    \ = path_len\n                min_path_visited = visited\n                min_path_visited_sum\
    \ = visited_sum\n                min_path_visited_len = path_len\n           \
    \ end\n        else\n            if visited_sum < n * n\n                if i\
    \ > 1 && visited[i - 1, j] == 0\n                    visited[i - 1, j] = 1\n \
    \                   push!(queue, (vcat(path, grid[i - 1, j]), path_sum + grid[i\
    \ - 1, j], path_len + 1, i - 1, j, visited_sum + 1))\n                    visited[i\
    \ - 1, j] = 0\n                end\n                if i < n && visited[i + 1,\
    \ j] == 0\n                    visited[i + 1, j] = 1\n                    push!(queue,\
    \ (vcat(path, grid[i + 1, j]), path_sum + grid[i + 1, j], path_len + 1, i + 1,\
    \ j, visited_sum + 1))\n                    visited[i + 1, j] = 0\n          \
    \      end\n                if j > 1 && visited[i, j - 1] == 0\n             \
    \       visited[i, j - 1\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing separator in array expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmproa43idv.jl:67\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmproa43idv.jl:67\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return grid\n    end\n    if k > n * n\n        return\
    \ []\n    end\n    if k == n\n        return grid[1,:]\n    end\n    if k == 2\
    \ * n\n        return grid[1,:]\n    end\n    if k == n + 1\n        return [grid[1,1],\
    \ grid[2,1]]\n    end\n    if k == n + 2\n        return [grid[1,1], grid[2,1],\
    \ grid[2,2]]\n    end\n    if k == 2 * n + 1\n        return [grid[1,1], grid[2,1],\
    \ grid[2,2], grid[3,2]]\n    end\n    if k == 2 * n + 2\n        return [grid[1,1],\
    \ grid[2,1], grid[2,2], grid[3,2], grid[3,3]]\n    end\n    if k == 3 * n\n  \
    \      return grid[1,:]\n    end\n    if k == 3 * n + 1\n        return [grid[1,1],\
    \ grid[2,1], grid[2,2], grid[3,2], grid[3,3], grid[2,3]]\n    end\n    if k ==\
    \ 3 * n + 2\n        return [grid[1,1], grid[2,1], grid[2,2], grid[3,2], grid[3,3],\
    \ grid[2,3], grid[1,3]]\n    end\n    if k == 4 * n\n        return grid[1,:]\n\
    \    end\n    if k == 4 * n + 1\n        return [grid[1,1], grid[2,1], grid[2,2],\
    \ grid[3,2], grid[3,3], grid[2,3], grid[1,3], grid[1,2]]\n    end\n    if k ==\
    \ 4 * n + 2\n        return [grid[1,1], grid[2,1], grid[2,2], grid[3,2], grid[3,3],\
    \ grid[2,3], grid[1,3],\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing separator in array expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4i76bl2w.jl:78\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4i76bl2w.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n\
    \    if k <= n\n        return [grid[i,1] for i in 1:k]\n    end\n    if k <=\
    \ 2 * n\n        return [grid[i,1] for i in 1:n] .* [grid[i,2] for i in 1:k-n]\n\
    \    end\n    if k <= 3 * n\n        return [grid[i,1] for i in 1:n] .* [grid[i,2]\
    \ for i in 1:n] .* [grid[i,3] for i in 1:k-2*n]\n    end\n    if k <= 4 * n\n\
    \        return [grid[i,1] for i in 1:n] .* [grid[i,2] for i in 1:n] .* [grid[i,3]\
    \ for i in 1:n] .* [grid[i,4] for i in 1:k-3*n]\n    end\n    if k <= 5 * n\n\
    \        return [grid[i,1] for i in 1:n] .* [grid[i,2] for i in 1:n] .* [grid[i,3]\
    \ for i in 1:n] .* [grid[i,4] for i in 1:n] .* [grid[i,5] for i in 1:k-4*n]\n\
    \    end\n    if k <= 6 * n\n        return [grid[i,1] for i in 1:n] .* [grid[i,2]\
    \ for i in 1:n] .* [grid[i,3] for i in 1:n] .* [grid[i,4] for i in 1:n] .* [grid[i,5]\
    \ for i in 1:n] .* [grid[i,6] for i in 1:k-5*n]\n    end\n    if k <= 7 * n\n\
    \        return [grid[i,1] for i in 1:n] .*\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmfvuf3ky.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmfvuf3ky.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement your solution here\n    return []\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwj8h5hqc.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpwj8h5hqc.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpwj8h5hqc.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwj8h5hqc.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpwj8h5hqc.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwj8h5hqc.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpwj8h5hqc.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpwj8h5hqc.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwj8h5hqc.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwj8h5hqc.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpwj8h5hqc.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\ntest set: Test Failed at /tmp/tmpwj8h5hqc.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpwj8h5hqc.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwj8h5hqc.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwj8h5hqc.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    # create a matrix of size NxNxk to store the minimum path\n    # for each\
    \ cell and each length of path\n    min_path = zeros(Int64, N, N, k)\n    # create\
    \ a matrix of size NxNxk to store the minimum path\n    # for each cell and each\
    \ length of path\n    min_path_val = zeros(Int64, N, N, k)\n    # create a matrix\
    \ of size NxNxk to store the minimum path\n    # for each cell and each length\
    \ of path\n    min_path_dir = zeros(Int64, N, N, k)\n    # initialize the first\
    \ column of min_path matrix\n    for i in 1:N\n        min_path[i,1,1] = grid[i,1]\n\
    \        min_path_val[i,1,1] = grid[i,1]\n        min_path_dir[i,1,1] = 0\n  \
    \  end\n    # initialize the first row of min_path matrix\n    for j in 1:N\n\
    \        min_path[1,j,1] = grid[1,j]\n        min_path_val[1,j,1] = grid[1,j]\n\
    \        min_path_dir[1,j,1] = 0\n    end\n    # initialize the first row and\
    \ column of min_path matrix\n    for i in 2:N\n        for j in 2:N\n        \
    \    min_path[i,j,1] = grid[i,j]\n            min_path_val[i,j,1] = grid[i,j]\n\
    \            min_path_dir[i,j,1] = 0\n        end\n    end\n    # fill the min_path\
    \ matrix\n    for l in 2:k\n        for i in 1:N\n            for j in 1:N\n \
    \               if i == 1 && j == 1\n                    continue\n          \
    \      end\n                if i == 1\n                    min_path[i,j,l] = min_path[i,j-1,l-1]\n\
    \                    min_path_val[\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdust1zvt.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdust1zvt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    m = length(grid[1])\n    # The following is a 2D\
    \ array of size n x m x k.\n    # dp[i, j, l] is the minimum path of length l\
    \ that starts from cell (i, j).\n    dp = Array{Int64, 3}(undef, n, m, k)\n  \
    \  # The following is a 2D array of size n x m x k.\n    # dp_idx[i, j, l] is\
    \ the index of the cell that the minimum path of length l\n    # that starts from\
    \ cell (i, j) ends at.\n    dp_idx = Array{Int64, 3}(undef, n, m, k)\n    # The\
    \ following is a 2D array of size n x m x k.\n    # dp_dir[i, j, l] is the direction\
    \ of the cell that the minimum path of\n    # length l that starts from cell (i,\
    \ j) ends at.\n    dp_dir = Array{Int64, 3}(undef, n, m, k)\n    # The following\
    \ is a 2D array of size n x m x k.\n    # dp_val[i, j, l] is the value of the\
    \ cell that the minimum path of length l\n    # that starts from cell (i, j) ends\
    \ at.\n    dp_val = Array{Int64, 3}(undef, n, m, k)\n    # The following is a\
    \ 2D array of size n x m x k.\n    # dp_prev[i, j, l] is the value of the cell\
    \ that the minimum path of length\n    # l that starts from cell (i, j) goes through.\n\
    \    dp_prev = Array{Int64, 3}(undef, n, m, k)\n    # The following is a 2D array\
    \ of size n x m x k.\n    # dp_prev_idx[i, j, l] is the index of the cell that\
    \ the minimum path of\n    # length l that starts from cell (i, j) goes through.\n\
    \    dp_prev_idx = Array{Int64, 3}(undef, n, m,\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4q1vxzra.jl:58\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4q1vxzra.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n\
    \    if k > n * n\n        return []\n    end\n    # if k == 2\n    #     return\
    \ [grid[1,1], grid[1,2]]\n    # end\n    # if k == 3\n    #     return [grid[1,1],\
    \ grid[1,2], grid[2,2]]\n    # end\n    # if k == 4\n    #     return [grid[1,1],\
    \ grid[1,2], grid[2,2], grid[2,1]]\n    # end\n    # if k == 5\n    #     return\
    \ [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[3,1]]\n    # end\n    # if\
    \ k == 6\n    #     return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[3,1],\
    \ grid[3,2]]\n    # end\n    # if k == 7\n    #     return [grid[1,1], grid[1,2],\
    \ grid[2,2], grid[2,1], grid[3,1], grid[3,2], grid[3,3]]\n    # end\n    # if\
    \ k == 8\n    #     return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[3,1],\
    \ grid[3,2], grid[3,3], grid[2,3]]\n    # end\n    # if k == 9\n    #     return\
    \ [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[3,1], grid[3,2], grid[3,3],\
    \ grid[2,3], grid[1,3]]\n    # end\n    # if k == 10\n    #     return [grid[1,1],\
    \ grid[1,2], grid[2,2], grid[2,1\nusing Test\n\n@testset begin\n\ncandidate =\
    \ minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8qnblijo.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp8qnblijo.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp8qnblijo.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t\
    @test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzgpyy2mt.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgpyy2mt.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzgpyy2mt.jl:32\n   [2] top-level scope at /tmp/tmpzgpyy2mt.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgpyy2mt.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzgpyy2mt.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpncjxc9za.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpncjxc9za.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpncjxc9za.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpncjxc9za.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpncjxc9za.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpncjxc9za.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpncjxc9za.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpncjxc9za.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpncjxc9za.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpncjxc9za.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpncjxc9za.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\ntest set: Test Failed at /tmp/tmpncjxc9za.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpncjxc9za.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncjxc9za.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpncjxc9za.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    m = length(grid[1])\n    visited = zeros(Int64,\
    \ n, m)\n    min_path = []\n    min_path_value = Inf\n    for i = 1:n\n      \
    \  for j = 1:m\n            visited[i, j] = 1\n            dfs(grid, visited,\
    \ i, j, k, [grid[i, j]], min_path, min_path_value)\n            visited[i, j]\
    \ = 0\n        end\n    end\n    return min_path\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7v5e1bpk.jl:50\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp7v5e1bpk.jl:39\n   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:50\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:51\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  UndefVarError: dfs not defined\n\
    \  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7v5e1bpk.jl:39\n\
    \   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:52\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp7v5e1bpk.jl:39\n   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:53\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp7v5e1bpk.jl:39\n   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:54\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp7v5e1bpk.jl:39\n   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:55\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp7v5e1bpk.jl:39\n   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:56\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  UndefVarError: dfs not defined\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp7v5e1bpk.jl:39\n\
    \   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:56\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:57\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp7v5e1bpk.jl:39\n   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:58\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp7v5e1bpk.jl:39\n   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:58\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:59\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7v5e1bpk.jl:39\n   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:59\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp7v5e1bpk.jl:60\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7v5e1bpk.jl:39\n   [2] top-level scope at /tmp/tmp7v5e1bpk.jl:60\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7v5e1bpk.jl:49\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7v5e1bpk.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfy6p8n7o.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfy6p8n7o.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpfy6p8n7o.jl:32\\n   [2] top-level scope at /tmp/tmpfy6p8n7o.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfy6p8n7o.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq6m64_y9.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpq6m64_y9.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpq6m64_y9.jl:32\n   [2] top-level scope at /tmp/tmpq6m64_y9.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq6m64_y9.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq6m64_y9.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return [1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpx9zhi8iu.jl:39\\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\\n   Evaluated: [1] == [1, 2,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpx9zhi8iu.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\ntest set: Test Failed at /tmp/tmpx9zhi8iu.jl:41\\\
    n  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\\n   Evaluated: [1] == [1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpx9zhi8iu.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\ntest set: Test Failed at /tmp/tmpx9zhi8iu.jl:42\\\
    n  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\n   Evaluated: [1] == [1, 10, 1,\
    \ 10, 1, 10, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpx9zhi8iu.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\ntest set: Test Failed at /tmp/tmpx9zhi8iu.jl:43\\\
    n  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\\n   Evaluated: [1] == [1, 7, 1, 7, 1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpx9zhi8iu.jl:43\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\ntest set: Test Failed at /tmp/tmpx9zhi8iu.jl:44\\\
    n  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\n   Evaluated: [1] == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpx9zhi8iu.jl:44\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\ntest set: Test Failed at /tmp/tmpx9zhi8iu.jl:45\\\
    n  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n   Evaluated: [1] ==\
    \ [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpx9zhi8iu.jl:45\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\ntest set: Test Failed at /tmp/tmpx9zhi8iu.jl:46\\\
    n  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\\n   Evaluated: [1] == [1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpx9zhi8iu.jl:46\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\ntest set: Test Failed at /tmp/tmpx9zhi8iu.jl:47\\\
    n  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\\n   Evaluated: [1] == [1, 5, 1, 5, 1, 5, 1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpx9zhi8iu.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\ntest set: Test Failed at /tmp/tmpx9zhi8iu.jl:48\\\
    n  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\\n   Evaluated: [1] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpx9zhi8iu.jl:48\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\ntest set: Test Failed at /tmp/tmpx9zhi8iu.jl:49\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: [1] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpx9zhi8iu.jl:49\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx9zhi8iu.jl:38\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    m = length(grid[1])\n    # create a matrix to store\
    \ the minimum path\n    min_path = Array{Int64, 2}(undef, n, m)\n    # create\
    \ a matrix to store the minimum path's length\n    min_path_length = Array{Int64,\
    \ 2}(undef, n, m)\n    # create a matrix to store the minimum path's direction\n\
    \    min_path_direction = Array{Int64, 2}(undef, n, m)\n    # create a matrix\
    \ to store the minimum path's value\n    min_path_value = Array{Int64, 2}(undef,\
    \ n, m)\n    # create a matrix to store the minimum path's value\n    min_path_value\
    \ = Array{Int64, 2}(undef, n, m)\n    # create a matrix to store the minimum path's\
    \ value\n    min_path_value = Array{Int64, 2}(undef, n, m)\n    # create a matrix\
    \ to store the minimum path's value\n    min_path_value = Array{Int64, 2}(undef,\
    \ n, m)\n    # create a matrix to store the minimum path's value\n    min_path_value\
    \ = Array{Int64, 2}(undef, n, m)\n    # create a matrix to store the minimum path's\
    \ value\n    min_path_value = Array{Int64, 2}(undef, n, m)\n    # create a matrix\
    \ to store the minimum path's value\n    min_path_value = Array{Int64, 2}(undef,\
    \ n, m)\n    # create a matrix to store the minimum path's value\n    min_path_value\
    \ = Array{Int64, 2}(undef, n, m)\n    # create a matrix to store the minimum path's\
    \ value\n    min_path_value = Array{Int64, 2}(undef, n, m)\n    # create a matrix\
    \ to store the minimum path's value\n    min_path_value = Array{Int64, 2}(undef,\
    \ n, m)\n    # create a matrix to store the minimum path's value\n    min_path_value\
    \ = Array{Int64, 2}(und\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz2r6h1c3.jl:61\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpz2r6h1c3.jl:61\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpu7jqbbdj.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpu7jqbbdj.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpu7jqbbdj.jl:32\n   [2] top-level scope at /tmp/tmpu7jqbbdj.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu7jqbbdj.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu7jqbbdj.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    m = length(grid[1])\n    if k == 1\n        return\
    \ [grid[1,1]]\n    end\n    if k == n * m\n        return [grid[i,j] for i in\
    \ 1:n, j in 1:m]\n    end\n    if k < n\n        return [grid[i,1] for i in 1:k]\n\
    \    end\n    if k < m\n        return [grid[1,j] for j in 1:k]\n    end\n   \
    \ if k == n\n        return [grid[i,1] for i in 1:n]\n    end\n    if k == m\n\
    \        return [grid[1,j] for j in 1:m]\n    end\n    if k == n + m - 1\n   \
    \     return [grid[i,j] for i in 1:n, j in 1:m if i + j == k]\n    end\n    if\
    \ k < n + m - 1\n        return [grid[i,j] for i in 1:k, j in 1:k if i + j ==\
    \ k]\n    end\n    if k == n + m\n        return [grid[i,j] for i in 1:n, j in\
    \ 1:m]\n    end\n    if k < 2 * n - 1\n        return [grid[i,j] for i in 1:k,\
    \ j in 1:k if i + j == k]\n    end\n    if k < 2 * m - 1\n        return [grid[i,j]\
    \ for i in 1:k, j in 1:k if i + j == k]\n    end\n    if k == 2 * n - 1\n    \
    \    return [grid[i,j] for i in 1:n, j in 1:m if i + j == k]\n    end\n    if\
    \ k == 2 * m - 1\n        return [grid[i,j] for i in 1:n, j in 1:m if i + j ==\
    \ k]\n    end\n    if k < 2 * n + m - 2\n        return [grid[i,j] for i in 1:k,\
    \ j in 1:k if i + j == k]\n    end\n    if k < 2 *\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprnhi8596.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprnhi8596.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp59wr_331.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp59wr_331.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp59wr_331.jl:32\n   [2] top-level scope at /tmp/tmp59wr_331.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp59wr_331.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp59wr_331.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7r5f6zem.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r5f6zem.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7r5f6zem.jl:32\n   [2] top-level scope at /tmp/tmp7r5f6zem.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r5f6zem.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7r5f6zem.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk5reanh3.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk5reanh3.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk5reanh3.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk5reanh3.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk5reanh3.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpk5reanh3.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk5reanh3.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpk5reanh3.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk5reanh3.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk5reanh3.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpk5reanh3.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\ntest set: Test Failed at /tmp/tmpk5reanh3.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpk5reanh3.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk5reanh3.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk5reanh3.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    dp = Array{Vector{Int64}, 2}(undef, n, n)\n    for\
    \ i in 1:n, j in 1:n\n        dp[i, j] = [grid[i, j]]\n    end\n    for i in 1:k-1\n\
    \        for j in 1:n, k in 1:n\n            if j > 1\n                if dp[j,\
    \ k][end] < dp[j-1, k][end]\n                    dp[j, k] = dp[j-1, k]\n     \
    \           elseif dp[j, k][end] > dp[j-1, k][end]\n                    dp[j-1,\
    \ k] = dp[j, k]\n                else\n                    dp[j, k] = dp[j-1,\
    \ k]\n                end\n            end\n            if k > 1\n           \
    \     if dp[j, k][end] < dp[j, k-1][end]\n                    dp[j, k] = dp[j,\
    \ k-1]\n                elseif dp[j, k][end] > dp[j, k-1][end]\n             \
    \       dp[j, k-1] = dp[j, k]\n                else\n                    dp[j,\
    \ k] = dp[j, k-1]\n                end\n            end\n            if j < n\n\
    \                if dp[j, k][end] < dp[j+1, k][end]\n                    dp[j,\
    \ k] = dp[j+1, k]\n                elseif dp[j, k][end] > dp[j+1, k][end]\n  \
    \                  dp[j+1, k] = dp[j, k]\n                else\n             \
    \       dp[j, k] = dp[j+1, k]\n                end\n            end\n        \
    \    if k < n\n                if dp[j, k][end] < dp[j, k+1][end]\n          \
    \          dp[j, k] = dp[j, k+1]\n                elseif dp[j, k][end\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf_e215ag.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpf_e215ag.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement me!\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpjr_43izh.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpjr_43izh.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpjr_43izh.jl:32\\n   [2] top-level scope at /tmp/tmpjr_43izh.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpjr_43izh.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    11     11\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpm88rm2lz.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm88rm2lz.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpm88rm2lz.jl:32\\n   [2] top-level scope at /tmp/tmpm88rm2lz.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm88rm2lz.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    11     11\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppbbfn23q.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppbbfn23q.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmppbbfn23q.jl:32\n   [2] top-level scope at /tmp/tmppbbfn23q.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppbbfn23q.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppbbfn23q.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N * N\n        return sort(grid)\n    end\n    if k > N * N\n   \
    \     return []\n    end\n    # The idea is to find the minimum path from the\
    \ first cell to any cell\n    # in the grid.\n    # We can do this by using a\
    \ dynamic programming approach.\n    # We will use a 3D array to store the minimum\
    \ path from the first cell to\n    # any cell in the grid.\n    # The first dimension\
    \ will be the cell number, the second dimension will\n    # be the row number,\
    \ and the third dimension will be the column number.\n    # The value of the array\
    \ will be the minimum path from the first cell to\n    # the cell (i, j) in the\
    \ grid.\n    # We will use a 2D array to store the path from the first cell to\
    \ any cell\n    # in the grid.\n    # The first dimension will be the cell number,\
    \ the second dimension will\n    # be the row number, and the third dimension\
    \ will be the column number.\n    # The value of the array will be the path from\
    \ the first cell to the cell\n    # (i, j) in the grid.\n    # We will use a 2D\
    \ array to store the minimum value from the first cell to\n    # any cell in the\
    \ grid.\n    # The first dimension will be the cell number, the second dimension\
    \ will\n    # be the row number, and the third dimension will be the column number.\n\
    \    # The value of the array will be the minimum value from the first cell to\n\
    \    # the cell (i, j) in the grid.\n    # We will use a 2D array to store the\
    \ minimum value from the first cell to\n    # any cell in the grid.\n    # The\
    \ first dimension will be the cell number, the second dimension will\n    # be\
    \ the row number, and the third dimension will be the column number.\n    # The\
    \ value of the array will be the minimum value from the first cell to\n    # the\
    \ cell (i, j) in the grid.\n    # We will use a 2D array to store the minimum\
    \ value from the first cell to\n    # any cell in the grid.\n    # The first dimension\n\
    using Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2,\
    \ 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4,\
    \ 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8],\
    \ [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpo_nnkvl_.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpo_nnkvl_.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpo_nnkvl_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqi8ll0r4.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpqi8ll0r4.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpqi8ll0r4.jl:32\n   [2] top-level scope at /tmp/tmpqi8ll0r4.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqi8ll0r4.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqi8ll0r4.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code goes here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp3r7oharg.jl:39\\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3r7oharg.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:40\\\
    n  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n   Evaluated:\
    \ Int64[] == [1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3r7oharg.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:41\\\
    n  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3r7oharg.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:42\\\
    n  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3r7oharg.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:43\\\
    n  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp3r7oharg.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:44\\\
    n  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3r7oharg.jl:44\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:45\\\
    n  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmp3r7oharg.jl:45\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:46\\\
    n  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3r7oharg.jl:46\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:47\\\
    n  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3r7oharg.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:48\\\
    n  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3r7oharg.jl:48\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\ntest set: Test Failed at /tmp/tmp3r7oharg.jl:49\\\
    n  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3r7oharg.jl:49\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3r7oharg.jl:38\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # create a matrix of size N x N x k\n    # where\
    \ dp[i, j, l] is the minimum path of length l starting from cell (i, j)\n    dp\
    \ = zeros(Int64, N, N, k)\n    # create a matrix of size N x N x k\n    # where\
    \ dp[i, j, l] is the value of the cell that the minimum path of length l starting\
    \ from cell (i, j) goes through\n    dp_val = zeros(Int64, N, N, k)\n    # create\
    \ a matrix of size N x N x k\n    # where dp[i, j, l] is the minimum path of length\
    \ l starting from cell (i, j)\n    dp_prev = zeros(Int64, N, N, k)\n    # create\
    \ a matrix of size N x N x k\n    # where dp[i, j, l] is the value of the cell\
    \ that the minimum path of length l starting from cell (i, j) goes through\n \
    \   dp_prev_val = zeros(Int64, N, N, k)\n    # create a matrix of size N x N x\
    \ k\n    # where dp[i, j, l] is the minimum path of length l starting from cell\
    \ (i, j)\n    dp_next = zeros(Int64, N, N, k)\n    # create a matrix of size N\
    \ x N x k\n    # where dp[i, j, l] is the value of the cell that the minimum path\
    \ of length l starting from cell (i, j) goes through\n    dp_next_val = zeros(Int64,\
    \ N, N, k)\n    # create a matrix of size N x N x k\n    # where dp[i, j, l] is\
    \ the minimum path of length l starting from cell (i, j)\n    dp_curr = zeros(Int64,\
    \ N, N, k)\n    # create a matrix of size N x N x k\n    # where dp[i, j, l] is\
    \ the value of the cell that the minimum path of length l starting from cell (i,\
    \ j) goes through\n    dp_curr_\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsz5tetvf.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpsz5tetvf.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpsz5tetvf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement me!\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwfus0n_y.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpwfus0n_y.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpwfus0n_y.jl:32\n   [2] top-level scope at /tmp/tmpwfus0n_y.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwfus0n_y.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwfus0n_y.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t\
    @test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp1msocgsw.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1msocgsw.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp1msocgsw.jl:32\\n   [2] top-level scope at /tmp/tmp1msocgsw.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp1msocgsw.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    11     11\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcat4dag2.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcat4dag2.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return grid[:]\n    end\n    if k > n * n\n      \
    \  return []\n    end\n    if k == n\n        return [grid[1,1], grid[1,2], grid[2,2],\
    \ grid[2,1], grid[1,1]]\n    end\n    if k == n + 1\n        return [grid[1,1],\
    \ grid[1,2], grid[2,2], grid[2,1], grid[1,1], grid[1,2]]\n    end\n    if k ==\
    \ n + 2\n        return [grid[1,1], grid[1,2], grid[2,2], grid[2,1], grid[1,1],\
    \ grid[1,2], grid[1,3]]\n    end\n    if k == n + 3\n        return [grid[1,1],\
    \ grid[1,2], grid[2,2], grid[2,1], grid[1,1], grid[1,2], grid[1,3], grid[2,3]]\n\
    \    end\n    if k == n + 4\n        return [grid[1,1], grid[1,2], grid[2,2],\
    \ grid[2,1], grid[1,1], grid[1,2], grid[1,3], grid[2,3], grid[3,3]]\n    end\n\
    \    if k == n + 5\n        return [grid[1,1], grid[1,2], grid[2,2], grid[2,1],\
    \ grid[1,1], grid[1,2], grid[1,3], grid[2,3], grid[3,3], grid[3,2]]\n    end\n\
    \    if k == n + 6\n        return [grid[1,1], grid[1,2], grid[2,2], grid[2,1],\
    \ grid[1,1], grid[1,2], grid[1,3], grid[2,3], grid[3,3], grid[3,2], grid[3,1]]\n\
    \    end\n    if k == n + 7\n        return [grid[\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3u59egxm.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3u59egxm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpst207hyb.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpst207hyb.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpst207hyb.jl:32\\n   [2] top-level scope at /tmp/tmpst207hyb.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpst207hyb.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    11     11\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpr44n_1vh.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpr44n_1vh.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpr44n_1vh.jl:32\n   [2] top-level scope at /tmp/tmpr44n_1vh.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr44n_1vh.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr44n_1vh.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpl06xpiu9.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl06xpiu9.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpl06xpiu9.jl:32\\n   [2] top-level scope at /tmp/tmpl06xpiu9.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl06xpiu9.jl:37\\n  \\nTest Summary: | '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0ad56ipx.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ad56ipx.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp0ad56ipx.jl:32\n   [2] top-level scope at /tmp/tmp0ad56ipx.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ad56ipx.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0ad56ipx.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpalnkzybi.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpalnkzybi.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmpalnkzybi.jl:32\\n   [2] top-level scope at /tmp/tmpalnkzybi.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpalnkzybi.jl:37\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    11     11\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    # The first element of the tuple is the value of\
    \ the cell, the second\n    # element is the number of steps taken to reach that\
    \ cell.\n    # The third element is the value of the previous cell.\n    # The\
    \ fourth element is the number of steps taken to reach the previous cell.\n  \
    \  # The fifth element is the value of the cell before the previous cell.\n  \
    \  # The sixth element is the number of steps taken to reach the cell before the\
    \ previous cell.\n    # The seventh element is the value of the cell before the\
    \ cell before the previous cell.\n    # The eighth element is the number of steps\
    \ taken to reach the cell before the cell before the previous cell.\n    # The\
    \ ninth element is the value of the cell before the cell before the cell before\
    \ the previous cell.\n    # The tenth element is the number of steps taken to\
    \ reach the cell before the cell before the cell before the previous cell.\n \
    \   # The eleventh element is the value of the cell before the cell before the\
    \ cell before the cell before the previous cell.\n    # The twelfth element is\
    \ the number of steps taken to reach the cell before the cell before the cell\
    \ before the cell before the previous cell.\n    # The thirteenth element is the\
    \ value of the cell before the cell before the cell before the cell before the\
    \ cell before the previous cell.\n    # The fourteenth element is the number of\
    \ steps taken to reach the cell before the cell before the cell before the cell\
    \ before the cell before the previous cell.\n    # The fifteenth element is the\
    \ value of the cell before the cell before the cell before the cell before the\
    \ cell before the cell before the previous cell.\n    # The sixteenth element\
    \ is the number of steps taken to reach the cell before the cell before the cell\
    \ before the cell before the cell before the cell before the previous cell.\n\
    \    # The seventeenth element is the value of the cell before the cell before\
    \ the cell before the cell before the cell before the cell before the cell before\
    \ the previous cell.\n    # The eighteenth element is the number of steps taken\
    \ to reach the cell before the cell before the cell before the cell before the\
    \ cell before the cell before the cell before the previous cell.\n    # The nineteenth\
    \ element is the value of the cell before the cell before the cell before the\
    \ cell before the cell before the cell before the cell before the cell before\
    \ the previous cell.\n\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpe34kr2d5.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpe34kr2d5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpe34kr2d5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code goes here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmprnc1cz7a.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) ==\
    \ [1, 2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:39\\n  Test threw exception\\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:40\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:41\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:41\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:42\\n  Test threw exception\\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:42\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:43\\n  Test threw exception\\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:43\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:44\\n  Test threw exception\\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:44\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:45\\n  Test threw exception\\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:45\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:46\\n  Test threw exception\\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:46\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:47\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:47\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprnc1cz7a.jl:48\\n  Test threw exception\\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmprnc1cz7a.jl:32\\n   [2] top-level scope at /tmp/tmprnc1cz7a.jl:48\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprnc1cz7a.jl:37\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpp692fx6h.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpp692fx6h.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpp692fx6h.jl:32\n   [2] top-level scope at /tmp/tmpp692fx6h.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp692fx6h.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp692fx6h.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp45apvuw1.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp45apvuw1.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp45apvuw1.jl:32\n   [2] top-level scope at /tmp/tmp45apvuw1.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp45apvuw1.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp45apvuw1.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    m = length(grid[1])\n    dp = zeros(Int64, n, m,\
    \ k)\n    for i in 1:n\n        for j in 1:m\n            dp[i, j, 1] = grid[i,\
    \ j]\n        end\n    end\n    for i in 1:n\n        for j in 1:m\n         \
    \   for l in 2:k\n                dp[i, j, l] = dp[i, j, l - 1]\n            \
    \    if i > 1 && dp[i - 1, j, l - 1] < dp[i, j, l]\n                    dp[i,\
    \ j, l] = dp[i - 1, j, l - 1]\n                end\n                if i < n &&\
    \ dp[i + 1, j, l - 1] < dp[i, j, l]\n                    dp[i, j, l] = dp[i +\
    \ 1, j, l - 1]\n                end\n                if j > 1 && dp[i, j - 1,\
    \ l - 1] < dp[i, j, l]\n                    dp[i, j, l] = dp[i, j - 1, l - 1]\n\
    \                end\n                if j < m && dp[i, j + 1, l - 1] < dp[i,\
    \ j, l]\n                    dp[i, j, l] = dp[i, j + 1, l - 1]\n             \
    \   end\n            end\n        end\n    end\n    res = zeros(Int64, k)\n  \
    \  res[k] = dp[1, 1, k]\n    i = 1\n    j = 1\n    for l in k:-1:2\n        res[l\
    \ - 1] = dp[i, j, l - 1]\n        if i > 1 && dp[i - 1, j, l - 1] < res[l - 1]\n\
    \            res[l - 1] = dp[i - 1, j, l - 1]\n            i -= 1\n        elseif\
    \ i < n && dp[i + 1, j, l - 1] < res[l - 1\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0sbaj723.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0sbaj723.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_rpv7dcw.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_rpv7dcw.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement me!\n    return [1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpple2l19g.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: [1] == [1, 2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpple2l19g.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\ntest set: Test Failed at /tmp/tmpple2l19g.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: [1] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpple2l19g.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\ntest set: Test Failed at /tmp/tmpple2l19g.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: [1] == [1, 10, 1,\
    \ 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpple2l19g.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\ntest set: Test Failed at /tmp/tmpple2l19g.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: [1] == [1, 7, 1, 7, 1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpple2l19g.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\ntest set: Test Failed at /tmp/tmpple2l19g.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: [1] == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpple2l19g.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\ntest set: Test Failed at /tmp/tmpple2l19g.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: [1] ==\
    \ [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at /tmp/tmpple2l19g.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\ntest set: Test Failed at /tmp/tmpple2l19g.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: [1] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpple2l19g.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\ntest set: Test Failed at /tmp/tmpple2l19g.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: [1] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpple2l19g.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\ntest set: Test Failed at /tmp/tmpple2l19g.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: [1] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpple2l19g.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\ntest set: Test Failed at /tmp/tmpple2l19g.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: [1] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpple2l19g.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpple2l19g.jl:38\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1    10     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 10 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpple2l19g.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9pzb8hg4.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp9pzb8hg4.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp9pzb8hg4.jl:32\n   [2] top-level scope at /tmp/tmp9pzb8hg4.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9pzb8hg4.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9pzb8hg4.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2v5ey2j0.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp2v5ey2j0.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp2v5ey2j0.jl:32\n   [2] top-level scope at /tmp/tmp2v5ey2j0.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2v5ey2j0.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2v5ey2j0.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    Given a grid with N rows and N columns\
    \ (N >= 2) and a positive integer k, \n    each cell of the grid contains a value.\
    \ Every integer in the range [1, N * N]\n    inclusive appears exactly once on\
    \ the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa2ihfa60.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpa2ihfa60.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    # find the minimum value in the grid\n    min_val = grid[1,1]\n    for i\
    \ in 1:N\n        for j in 1:N\n            if grid[i,j] < min_val\n         \
    \       min_val = grid[i,j]\n            end\n        end\n    end\n    # find\
    \ the minimum path\n    min_path = []\n    for i in 1:N\n        for j in 1:N\n\
    \            if grid[i,j] == min_val\n                min_path = [grid[i,j]]\n\
    \                break\n            end\n        end\n    end\n    # find the\
    \ next minimum value in the grid\n    next_min_val = grid[1,1]\n    for i in 1:N\n\
    \        for j in 1:N\n            if grid[i,j] < next_min_val && grid[i,j] >\
    \ min_val\n                next_min_val = grid[i,j]\n            end\n       \
    \ end\n    end\n    # find the next minimum path\n    next_min_path = []\n   \
    \ for i in 1:N\n        for j in 1:N\n            if grid[i,j] == next_min_val\n\
    \                next_min_path = [grid[i,j]]\n                break\n        \
    \    end\n        end\n    end\n    # find the next minimum value in the grid\n\
    \    next_next_min_val = grid[1,1]\n    for i in 1:N\n        for j in 1:N\n \
    \           if grid[i,j] < next_next_min_val && grid[i,j] > next_min_val\n   \
    \             next_next_min_val = grid[i,j]\n            end\n        end\n  \
    \  end\n    # find the next minimum path\n    next_next_min_path = []\n    for\
    \ i in 1:N\n        for j in 1:N\n            if grid[i,j] == next_next_min_val\n\
    \                next_next_min_path = [grid[i,j]]\n                break\n   \
    \         end\n        end\n    end\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpm85q9lm5.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpm85q9lm5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpm85q9lm5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]],\
    \ 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],\
    \ [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5,\
    \ 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\
    \t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]],\
    \ 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9,\
    \ 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8,\
    \ 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9],\
    \ [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3,\
    \ 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3,\
    \ 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpo_op9xek.jl:40\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type String to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:41\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:42\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type String to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:43\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type String to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:44\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type String to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:45\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type String to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:46\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ String to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:47\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:48\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:49\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:49\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpo_op9xek.jl:50\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpo_op9xek.jl:31\n   [2] top-level scope at /tmp/tmpo_op9xek.jl:50\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo_op9xek.jl:39\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo_op9xek.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    @assert n >= 2\n    @assert k >= 1\n    @assert\
    \ n * n == sum(grid)\n    @assert all(grid .== sort(grid))\n    @assert all(grid\
    \ .>= 1)\n    @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n \
    \   @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n    @assert\
    \ all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n    @assert all(grid .<=\
    \ n * n)\n    @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n \
    \   @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n    @assert\
    \ all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n    @assert all(grid .<=\
    \ n * n)\n    @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n \
    \   @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n    @assert\
    \ all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n    @assert all(grid .<=\
    \ n * n)\n    @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n \
    \   @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n    @assert\
    \ all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n    @assert all(grid .<=\
    \ n * n)\n    @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n \
    \   @assert all(grid .<= n * n)\n    @assert all(grid .<= n * n)\n    @assert\
    \ all\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpa2x4fbpu.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpa2x4fbpu.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpa2x4fbpu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == n * n\n        return [grid[i,j] for i in 1:n, j in 1:n]\n    end\n\
    \    if k == n\n        return [grid[1,i] for i in 1:n]\n    end\n    if k ==\
    \ n + 1\n        return [grid[1,1], grid[2,1]]\n    end\n    if k == n + 2\n \
    \       return [grid[1,1], grid[2,1], grid[2,2]]\n    end\n    if k == n + 3\n\
    \        return [grid[1,1], grid[2,1], grid[2,2], grid[3,2]]\n    end\n    if\
    \ k == n + 4\n        return [grid[1,1], grid[2,1], grid[2,2], grid[3,2], grid[3,3]]\n\
    \    end\n    if k == n + 5\n        return [grid[1,1], grid[2,1], grid[2,2],\
    \ grid[3,2], grid[3,3], grid[2,3]]\n    end\n    if k == n + 6\n        return\
    \ [grid[1,1], grid[2,1], grid[2,2], grid[3,2], grid[3,3], grid[2,3], grid[1,3]]\n\
    \    end\n    if k == n + 7\n        return [grid[1,1], grid[2,1], grid[2,2],\
    \ grid[3,2], grid[3,3], grid[2,3], grid[1,3], grid[1,2]]\n    end\n    if k ==\
    \ n + 8\n        return [grid[1,1], grid[2,1], grid[2,2], grid[3,2], grid[3,3],\
    \ grid[2,3], grid[1,3], grid[1,2], grid[2,2]]\n    end\n    if k == n + 9\n  \
    \      return [grid[1,1], grid[2,1], grid[2,2], grid[3,2], grid[3,3\nusing Test\n\
    \n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5,\
    \ 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7,\
    \ 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11,\
    \ 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10],\
    \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10,\
    \ 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16,\
    \ 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\
    \t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7,\
    \ 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7,\
    \ 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing separator in array expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp40kyy24n.jl:67\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp40kyy24n.jl:67\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    visited = zeros(Int64, n, n)\n    min_path = []\n\
    \    min_path_value = Inf\n    for i in 1:n, j in 1:n\n        visited[i, j] =\
    \ 1\n        path = [grid[i, j]]\n        path_value = grid[i, j]\n        dfs(grid,\
    \ visited, path, path_value, min_path, min_path_value, i, j, k, n)\n        visited[i,\
    \ j] = 0\n    end\n    return min_path\nend\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5x8umyug.jl:49\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp5x8umyug.jl:39\n   [2] top-level scope at /tmp/tmp5x8umyug.jl:49\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:50\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  UndefVarError: dfs not defined\n\
    \  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp5x8umyug.jl:39\n\
    \   [2] top-level scope at /tmp/tmp5x8umyug.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:51\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp5x8umyug.jl:39\n   [2] top-level scope at /tmp/tmp5x8umyug.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:52\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp5x8umyug.jl:39\n   [2] top-level scope at /tmp/tmp5x8umyug.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:53\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp5x8umyug.jl:39\n   [2] top-level scope at /tmp/tmp5x8umyug.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:54\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  UndefVarError: dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp5x8umyug.jl:39\n   [2] top-level scope at /tmp/tmp5x8umyug.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:55\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  UndefVarError: dfs not defined\n  Stacktrace:\n\
    \   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmp5x8umyug.jl:39\n\
    \   [2] top-level scope at /tmp/tmp5x8umyug.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:56\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp5x8umyug.jl:39\n   [2] top-level scope at /tmp/tmp5x8umyug.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:57\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  UndefVarError:\
    \ dfs not defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64)\
    \ at /tmp/tmp5x8umyug.jl:39\n   [2] top-level scope at /tmp/tmp5x8umyug.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:58\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5x8umyug.jl:39\n   [2] top-level scope at /tmp/tmp5x8umyug.jl:58\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5x8umyug.jl:59\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  UndefVarError: dfs not\
    \ defined\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp5x8umyug.jl:39\n   [2] top-level scope at /tmp/tmp5x8umyug.jl:59\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5x8umyug.jl:48\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5x8umyug.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    dp = Vector{Vector{Vector{Int64}}}(undef, N)\n \
    \   for i in 1:N\n        dp[i] = Vector{Vector{Int64}}(undef, N)\n        for\
    \ j in 1:N\n            dp[i][j] = Vector{Int64}(undef, N * N)\n        end\n\
    \    end\n    for i in 1:N\n        for j in 1:N\n            dp[i][j][1] = grid[i][j]\n\
    \        end\n    end\n    for i in 1:N\n        for j in 1:N\n            for\
    \ l in 2:N * N\n                dp[i][j][l] = Inf\n            end\n        end\n\
    \    end\n    for l in 2:k\n        for i in 1:N\n            for j in 1:N\n \
    \               if i > 1\n                    dp[i][j][l] = min(dp[i][j][l], dp[i\
    \ - 1][j][l - 1])\n                end\n                if i < N\n           \
    \         dp[i][j][l] = min(dp[i][j][l], dp[i + 1][j][l - 1])\n              \
    \  end\n                if j > 1\n                    dp[i][j][l] = min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1])\n                end\n                if j < N\n      \
    \              dp[i][j][l] = min(dp[i][j][l], dp[i][j + 1][l - 1])\n         \
    \       end\n            end\n        end\n    end\n    ans = Inf\n    for i in\
    \ 1:N\n        for j in 1:N\n            ans = min(ans, dp[i][j][k])\n       \
    \ end\n    end\n    return ans\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg96ae7ol.jl:82\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  InexactError: Int64(Inf)\n  Stacktrace:\n   [1] Int64 at ./float.jl:710 [inlined]\n\
    \   [2] convert at ./number.jl:7 [inlined]\n   [3] setindex! at ./array.jl:826\
    \ [inlined]\n   [4] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpg96ae7ol.jl:47\n\
    \   [5] top-level scope at /tmp/tmpg96ae7ol.jl:82\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:83\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64 at ./float.jl:710 [inlined]\n   [2] convert at ./number.jl:7 [inlined]\n\
    \   [3] setindex! at ./array.jl:826 [inlined]\n   [4] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpg96ae7ol.jl:47\n   [5] top-level scope at /tmp/tmpg96ae7ol.jl:83\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:84\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1] Int64 at ./float.jl:710\
    \ [inlined]\n   [2] convert at ./number.jl:7 [inlined]\n   [3] setindex! at ./array.jl:826\
    \ [inlined]\n   [4] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpg96ae7ol.jl:47\n\
    \   [5] top-level scope at /tmp/tmpg96ae7ol.jl:84\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:85\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1] Int64 at ./float.jl:710\
    \ [inlined]\n   [2] convert at ./number.jl:7 [inlined]\n   [3] setindex! at ./array.jl:826\
    \ [inlined]\n   [4] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpg96ae7ol.jl:47\n\
    \   [5] top-level scope at /tmp/tmpg96ae7ol.jl:85\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:86\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1] Int64 at ./float.jl:710\
    \ [inlined]\n   [2] convert at ./number.jl:7 [inlined]\n   [3] setindex! at ./array.jl:826\
    \ [inlined]\n   [4] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpg96ae7ol.jl:47\n\
    \   [5] top-level scope at /tmp/tmpg96ae7ol.jl:86\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:87\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1] Int64 at ./float.jl:710\
    \ [inlined]\n   [2] convert at ./number.jl:7 [inlined]\n   [3] setindex! at ./array.jl:826\
    \ [inlined]\n   [4] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpg96ae7ol.jl:47\n\
    \   [5] top-level scope at /tmp/tmpg96ae7ol.jl:87\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:88\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1]\
    \ Int64 at ./float.jl:710 [inlined]\n   [2] convert at ./number.jl:7 [inlined]\n\
    \   [3] setindex! at ./array.jl:826 [inlined]\n   [4] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpg96ae7ol.jl:47\n   [5] top-level scope at /tmp/tmpg96ae7ol.jl:88\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:89\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  InexactError:\
    \ Int64(Inf)\n  Stacktrace:\n   [1] Int64 at ./float.jl:710 [inlined]\n   [2]\
    \ convert at ./number.jl:7 [inlined]\n   [3] setindex! at ./array.jl:826 [inlined]\n\
    \   [4] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpg96ae7ol.jl:47\n\
    \   [5] top-level scope at /tmp/tmpg96ae7ol.jl:89\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:90\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  InexactError:\
    \ Int64(Inf)\n  Stacktrace:\n   [1] Int64 at ./float.jl:710 [inlined]\n   [2]\
    \ convert at ./number.jl:7 [inlined]\n   [3] setindex! at ./array.jl:826 [inlined]\n\
    \   [4] minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpg96ae7ol.jl:47\n\
    \   [5] top-level scope at /tmp/tmpg96ae7ol.jl:90\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:91\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  InexactError: Int64(Inf)\n\
    \  Stacktrace:\n   [1] Int64 at ./float.jl:710 [inlined]\n   [2] convert at ./number.jl:7\
    \ [inlined]\n   [3] setindex! at ./array.jl:826 [inlined]\n   [4] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpg96ae7ol.jl:47\n   [5] top-level scope at /tmp/tmpg96ae7ol.jl:91\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96ae7ol.jl:92\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  InexactError: Int64(Inf)\n\
    \  Stacktrace:\n   [1] Int64 at ./float.jl:710 [inlined]\n   [2] convert at ./number.jl:7\
    \ [inlined]\n   [3] setindex! at ./array.jl:826 [inlined]\n   [4] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpg96ae7ol.jl:47\n   [5] top-level scope at /tmp/tmpg96ae7ol.jl:92\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpg96ae7ol.jl:81\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg96ae7ol.jl:79\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpufl_n6j_.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpufl_n6j_.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpufl_n6j_.jl:32\n   [2] top-level scope at /tmp/tmpufl_n6j_.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpufl_n6j_.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpufl_n6j_.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn_2olj8p.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpn_2olj8p.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpn_2olj8p.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn_2olj8p.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpn_2olj8p.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpn_2olj8p.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpn_2olj8p.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpn_2olj8p.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn_2olj8p.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn_2olj8p.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpn_2olj8p.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\ntest set: Test Failed at /tmp/tmpn_2olj8p.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpn_2olj8p.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_2olj8p.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn_2olj8p.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    N = length(grid)\n    if k == 1\n        return [grid[1,1]]\n    end\n\
    \    if k == N * N\n        return [grid[i,j] for i in 1:N, j in 1:N]\n    end\n\
    \    if k <= N\n        return [grid[1,i] for i in 1:k]\n    end\n    if k <=\
    \ 2 * N\n        return [grid[1,i] for i in 1:N] .* [grid[2,i] for i in 1:k-N]\n\
    \    end\n    if k <= 3 * N\n        return [grid[1,i] for i in 1:N] .* [grid[2,i]\
    \ for i in 1:N] .* [grid[3,i] for i in 1:k-2*N]\n    end\n    if k <= 4 * N\n\
    \        return [grid[1,i] for i in 1:N] .* [grid[2,i] for i in 1:N] .* [grid[3,i]\
    \ for i in 1:N] .* [grid[4,i] for i in 1:k-3*N]\n    end\n    if k <= 5 * N\n\
    \        return [grid[1,i] for i in 1:N] .* [grid[2,i] for i in 1:N] .* [grid[3,i]\
    \ for i in 1:N] .* [grid[4,i] for i in 1:N] .* [grid[5,i] for i in 1:k-4*N]\n\
    \    end\n    if k <= 6 * N\n        return [grid[1,i] for i in 1:N] .* [grid[2,i]\
    \ for i in 1:N] .* [grid[3,i] for i in 1:N] .* [grid[4,i] for i in 1:N] .* [grid[5,i]\
    \ for i in 1:N] .* [grid[6,i] for i in 1:k-5*N]\n    end\n    if k <= 7 * N\n\
    \        return [grid[1,i] for i in 1:N] .*\nusing Test\n\n@testset begin\n\n\
    candidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm8bix3iq.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpm8bix3iq.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkh26fs5c.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpkh26fs5c.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpkh26fs5c.jl:32\n   [2] top-level scope at /tmp/tmpkh26fs5c.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkh26fs5c.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkh26fs5c.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzz1vz93k.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz1vz93k.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpzz1vz93k.jl:32\n   [2] top-level scope at /tmp/tmpzz1vz93k.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz1vz93k.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzz1vz93k.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp44vn9nav.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp44vn9nav.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp44vn9nav.jl:32\n   [2] top-level scope at /tmp/tmp44vn9nav.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp44vn9nav.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp44vn9nav.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code goes here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzfmv2bn1.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzfmv2bn1.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzfmv2bn1.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzfmv2bn1.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzfmv2bn1.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzfmv2bn1.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzfmv2bn1.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpzfmv2bn1.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzfmv2bn1.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzfmv2bn1.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpzfmv2bn1.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\ntest set: Test Failed at /tmp/tmpzfmv2bn1.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpzfmv2bn1.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzfmv2bn1.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzfmv2bn1.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\nend\n\"\"\"\n    Given a grid with N rows and\
    \ N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains\
    \ a value. Every integer in the range [1, N * N]\n    inclusive appears exactly\
    \ once on the cells of the grid.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_clj3_z7.jl:33\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_clj3_z7.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy162wozq.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpy162wozq.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpy162wozq.jl:32\n   [2] top-level scope at /tmp/tmpy162wozq.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy162wozq.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy162wozq.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code goes here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2,\
    \ 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2],\
    \ [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t\
    @test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]],\
    \ 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9,\
    \ 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1,\
    \ 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3,\
    \ 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8)\
    \ == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1,\
    \ 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1,\
    \ 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7p27nxtn.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p27nxtn.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp7p27nxtn.jl:32\n   [2] top-level scope at /tmp/tmp7p27nxtn.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p27nxtn.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7p27nxtn.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpio7z82c_.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpio7z82c_.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmpio7z82c_.jl:32\n   [2] top-level scope at /tmp/tmpio7z82c_.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpio7z82c_.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpio7z82c_.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\
    \t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5,\
    \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1o5i7c1w.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:38\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:39\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:39\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  MethodError: Cannot `convert` an object of type Nothing to an object of\
    \ type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:40\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:41\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:41\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:42\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:42\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:43\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:43\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:44\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:44\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:45\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:45\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:46\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:46\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:47\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:47\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmp1o5i7c1w.jl:48\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] minPath(::Array{Array{Int64,1},1}, ::Int64) at\
    \ /tmp/tmp1o5i7c1w.jl:32\n   [2] top-level scope at /tmp/tmp1o5i7c1w.jl:48\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1o5i7c1w.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1o5i7c1w.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\
    \ == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\
    \t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],\
    \ 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16,\
    \ 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12,\
    \ 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13,\
    \ 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]],\
    \ 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2,\
    \ 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]],\
    \ 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]],\
    \ 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbsj8870h.jl:39\n  Expression: candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n   Evaluated: Int64[] == [1,\
    \ 2, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpbsj8870h.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:40\n\
    \  Expression: candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] top-level scope at /tmp/tmpbsj8870h.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:41\n\
    \  Expression: candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14,\
    \ 15, 16]], 4) == [1, 2, 1, 2]\n   Evaluated: Int64[] == [1, 2, 1, 2]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbsj8870h.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:42\n\
    \  Expression: candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8,\
    \ 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n   Evaluated: Int64[] == [1, 10,\
    \ 1, 10, 1, 10, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpbsj8870h.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:43\n\
    \  Expression: candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10,\
    \ 11, 16]], 5) == [1, 7, 1, 7, 1]\n   Evaluated: Int64[] == [1, 7, 1, 7, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbsj8870h.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:44\n\
    \  Expression: candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13,\
    \ 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n   Evaluated: Int64[] == [1, 6,\
    \ 1, 6, 1, 6, 1, 6, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpbsj8870h.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:45\n\
    \  Expression: candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
    \ 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n   Evaluated: Int64[]\
    \ == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpbsj8870h.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:46\n\
    \  Expression: candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3,\
    \ 1, 3, 1, 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbsj8870h.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:47\n\
    \  Expression: candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5,\
    \ 1, 5, 1, 5]\n   Evaluated: Int64[] == [1, 5, 1, 5, 1, 5, 1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbsj8870h.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:48\n\
    \  Expression: candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1,\
    \ 2]\n   Evaluated: Int64[] == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpbsj8870h.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\ntest set: Test Failed at /tmp/tmpbsj8870h.jl:49\n\
    \  Expression: candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1,\
    \ 3]\n   Evaluated: Int64[] == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpbsj8870h.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbsj8870h.jl:38\nTest Summary: | Fail  Total\n\
    test set      |   11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbsj8870h.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive\
    \ integer k, \n    each cell of the grid contains a value. Every integer in the\
    \ range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\
    \n    You have to find the minimum path of length k in the grid. You can start\n\
    \    from any cell, and in each step you can move to any of the neighbor cells,\n\
    \    in other words, you can go to cells which share an edge with you current\n\
    \    cell.\n    Please note that a path of length k means visiting exactly k cells\
    \ (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path\
    \ A (of length k) is considered less than a path B (of length k) if\n    after\
    \ making the ordered lists of the values on the cells that A and B go\n    through\
    \ (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than\
    \ lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such\
    \ that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] =\
    \ lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n\n    Examples:\n\
    \n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1,\
    \ 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n       \
    \ Output: [1]\n    \"\"\"\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\
    \ \n    n = length(grid)\n    @assert n >= 2 && k >= 1\n    @assert length(grid[1])\
    \ == n\n    @assert all(all(1 <= grid[i][j] <= n * n for j in 1:n) for i in 1:n)\n\
    \    @assert all(count(grid[i][j] for i in 1:n for j in 1:n) == 1 for j in 1:n)\n\
    \    @assert all(count(grid[i][j] for i in 1:n for j in 1:n) == 1 for i in 1:n)\n\
    \    @assert all(count(grid[i][j] for i in 1:n for j in 1:n) == 1 for i in 1:n\
    \ for j in 1:n)\n    \n    # TODO: implement your solution here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3],\
    \ [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7,\
    \ 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
    \ 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7,\
    \ 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6,\
    \ 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4],\
    \ [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwbncl8tq.jl:47\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n\
    \  TypeError: non-boolean (Int64) used in boolean context\n  Stacktrace:\n   [1]\
    \ count at ./reduce.jl:855 [inlined]\n   [2] count at ./reduce.jl:866 [inlined]\n\
    \   [3] #5 at ./none:0 [inlined]\n   [4] iterate at ./generator.jl:47 [inlined]\n\
    \   [5] _all(::typeof(identity), ::Base.Generator{UnitRange{Int64},var\"#5#17\"\
    {Array{Array{Int64,1},1},Int64}}, ::Colon) at ./reduce.jl:819\n   [6] all at ./reduce.jl:815\
    \ [inlined]\n   [7] all at ./reduce.jl:733 [inlined]\n   [8] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9] top-level scope at /tmp/tmpwbncl8tq.jl:47\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:48\n  Test threw exception\n  Expression: candidate([[5,\
    \ 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n  TypeError: non-boolean (Int64) used\
    \ in boolean context\n  Stacktrace:\n   [1] count at ./reduce.jl:855 [inlined]\n\
    \   [2] count at ./reduce.jl:866 [inlined]\n   [3] #5 at ./none:0 [inlined]\n\
    \   [4] iterate at ./generator.jl:47 [inlined]\n   [5] _all(::typeof(identity),\
    \ ::Base.Generator{UnitRange{Int64},var\"#5#17\"{Array{Array{Int64,1},1},Int64}},\
    \ ::Colon) at ./reduce.jl:819\n   [6] all at ./reduce.jl:815 [inlined]\n   [7]\
    \ all at ./reduce.jl:733 [inlined]\n   [8] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9] top-level scope at /tmp/tmpwbncl8tq.jl:48\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:49\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1,\
    \ 2]\n  TypeError: non-boolean (Int64) used in boolean context\n  Stacktrace:\n\
    \   [1] count at ./reduce.jl:855 [inlined]\n   [2] count at ./reduce.jl:866 [inlined]\n\
    \   [3] #5 at ./none:0 [inlined]\n   [4] iterate at ./generator.jl:47 [inlined]\n\
    \   [5] _all(::typeof(identity), ::Base.Generator{UnitRange{Int64},var\"#5#17\"\
    {Array{Array{Int64,1},1},Int64}}, ::Colon) at ./reduce.jl:819\n   [6] all at ./reduce.jl:815\
    \ [inlined]\n   [7] all at ./reduce.jl:733 [inlined]\n   [8] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9] top-level scope at /tmp/tmpwbncl8tq.jl:49\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:50\n  Test threw exception\n  Expression: candidate([[6,\
    \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1,\
    \ 10, 1, 10, 1]\n  TypeError: non-boolean (Int64) used in boolean context\n  Stacktrace:\n\
    \   [1] count at ./reduce.jl:855 [inlined]\n   [2] count at ./reduce.jl:866 [inlined]\n\
    \   [3] #5 at ./none:0 [inlined]\n   [4] iterate at ./generator.jl:47 [inlined]\n\
    \   [5] _all(::typeof(identity), ::Base.Generator{UnitRange{Int64},var\"#5#17\"\
    {Array{Array{Int64,1},1},Int64}}, ::Colon) at ./reduce.jl:819\n   [6] all at ./reduce.jl:815\
    \ [inlined]\n   [7] all at ./reduce.jl:733 [inlined]\n   [8] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9] top-level scope at /tmp/tmpwbncl8tq.jl:50\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:51\n  Test threw exception\n  Expression: candidate([[8,\
    \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1,\
    \ 7, 1]\n  TypeError: non-boolean (Int64) used in boolean context\n  Stacktrace:\n\
    \   [1] count at ./reduce.jl:855 [inlined]\n   [2] count at ./reduce.jl:866 [inlined]\n\
    \   [3] #5 at ./none:0 [inlined]\n   [4] iterate at ./generator.jl:47 [inlined]\n\
    \   [5] _all(::typeof(identity), ::Base.Generator{UnitRange{Int64},var\"#5#17\"\
    {Array{Array{Int64,1},1},Int64}}, ::Colon) at ./reduce.jl:819\n   [6] all at ./reduce.jl:815\
    \ [inlined]\n   [7] all at ./reduce.jl:733 [inlined]\n   [8] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9] top-level scope at /tmp/tmpwbncl8tq.jl:51\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:52\n  Test threw exception\n  Expression: candidate([[11,\
    \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6,\
    \ 1, 6, 1, 6, 1]\n  TypeError: non-boolean (Int64) used in boolean context\n \
    \ Stacktrace:\n   [1] count at ./reduce.jl:855 [inlined]\n   [2] count at ./reduce.jl:866\
    \ [inlined]\n   [3] #5 at ./none:0 [inlined]\n   [4] iterate at ./generator.jl:47\
    \ [inlined]\n   [5] _all(::typeof(identity), ::Base.Generator{UnitRange{Int64},var\"\
    #5#17\"{Array{Array{Int64,1},1},Int64}}, ::Colon) at ./reduce.jl:819\n   [6] all\
    \ at ./reduce.jl:815 [inlined]\n   [7] all at ./reduce.jl:733 [inlined]\n   [8]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9]\
    \ top-level scope at /tmp/tmpwbncl8tq.jl:52\n   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:53\n  Test threw exception\n  Expression: candidate([[12,\
    \ 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1,\
    \ 6, 1, 6, 1, 6, 1, 6, 1, 6]\n  TypeError: non-boolean (Int64) used in boolean\
    \ context\n  Stacktrace:\n   [1] count at ./reduce.jl:855 [inlined]\n   [2] count\
    \ at ./reduce.jl:866 [inlined]\n   [3] #5 at ./none:0 [inlined]\n   [4] iterate\
    \ at ./generator.jl:47 [inlined]\n   [5] _all(::typeof(identity), ::Base.Generator{UnitRange{Int64},var\"\
    #5#17\"{Array{Array{Int64,1},1},Int64}}, ::Colon) at ./reduce.jl:819\n   [6] all\
    \ at ./reduce.jl:815 [inlined]\n   [7] all at ./reduce.jl:733 [inlined]\n   [8]\
    \ minPath(::Array{Array{Int64,1},1}, ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9]\
    \ top-level scope at /tmp/tmpwbncl8tq.jl:53\n   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:54\n  Test threw exception\n  Expression: candidate([[2,\
    \ 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n  TypeError: non-boolean\
    \ (Int64) used in boolean context\n  Stacktrace:\n   [1] count at ./reduce.jl:855\
    \ [inlined]\n   [2] count at ./reduce.jl:866 [inlined]\n   [3] #5 at ./none:0\
    \ [inlined]\n   [4] iterate at ./generator.jl:47 [inlined]\n   [5] _all(::typeof(identity),\
    \ ::Base.Generator{UnitRange{Int64},var\"#5#17\"{Array{Array{Int64,1},1},Int64}},\
    \ ::Colon) at ./reduce.jl:819\n   [6] all at ./reduce.jl:815 [inlined]\n   [7]\
    \ all at ./reduce.jl:733 [inlined]\n   [8] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9] top-level scope at /tmp/tmpwbncl8tq.jl:54\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:55\n  Test threw exception\n  Expression: candidate([[6,\
    \ 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n  TypeError: non-boolean\
    \ (Int64) used in boolean context\n  Stacktrace:\n   [1] count at ./reduce.jl:855\
    \ [inlined]\n   [2] count at ./reduce.jl:866 [inlined]\n   [3] #5 at ./none:0\
    \ [inlined]\n   [4] iterate at ./generator.jl:47 [inlined]\n   [5] _all(::typeof(identity),\
    \ ::Base.Generator{UnitRange{Int64},var\"#5#17\"{Array{Array{Int64,1},1},Int64}},\
    \ ::Colon) at ./reduce.jl:819\n   [6] all at ./reduce.jl:815 [inlined]\n   [7]\
    \ all at ./reduce.jl:733 [inlined]\n   [8] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9] top-level scope at /tmp/tmpwbncl8tq.jl:55\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:56\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n  TypeError: non-boolean\
    \ (Int64) used in boolean context\n  Stacktrace:\n   [1] count at ./reduce.jl:855\
    \ [inlined]\n   [2] count at ./reduce.jl:866 [inlined]\n   [3] #5 at ./none:0\
    \ [inlined]\n   [4] iterate at ./generator.jl:47 [inlined]\n   [5] _all(::typeof(identity),\
    \ ::Base.Generator{UnitRange{Int64},var\"#5#17\"{Array{Array{Int64,1},1},Int64}},\
    \ ::Colon) at ./reduce.jl:819\n   [6] all at ./reduce.jl:815 [inlined]\n   [7]\
    \ all at ./reduce.jl:733 [inlined]\n   [8] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9] top-level scope at /tmp/tmpwbncl8tq.jl:56\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbncl8tq.jl:57\n  Test threw exception\n  Expression: candidate([[1,\
    \ 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n  TypeError: non-boolean\
    \ (Int64) used in boolean context\n  Stacktrace:\n   [1] count at ./reduce.jl:855\
    \ [inlined]\n   [2] count at ./reduce.jl:866 [inlined]\n   [3] #5 at ./none:0\
    \ [inlined]\n   [4] iterate at ./generator.jl:47 [inlined]\n   [5] _all(::typeof(identity),\
    \ ::Base.Generator{UnitRange{Int64},var\"#5#17\"{Array{Array{Int64,1},1},Int64}},\
    \ ::Colon) at ./reduce.jl:819\n   [6] all at ./reduce.jl:815 [inlined]\n   [7]\
    \ all at ./reduce.jl:733 [inlined]\n   [8] minPath(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmpwbncl8tq.jl:35\n   [9] top-level scope at /tmp/tmpwbncl8tq.jl:57\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpwbncl8tq.jl:46\n  \nTest Summary: | Error\
    \  Total\ntest set      |    11     11\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 11 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwbncl8tq.jl:44\n"
  exit_code: 1
  status: SyntaxError
