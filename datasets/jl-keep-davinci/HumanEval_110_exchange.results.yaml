name: HumanEval_110_exchange
language: julia
results:
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzwn1bnsw.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzwn1bnsw.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzwn1bnsw.jl:21\ntest set: Test Failed at /tmp/tmpzwn1bnsw.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzwn1bnsw.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzwn1bnsw.jl:21\ntest set: Test Failed at /tmp/tmpzwn1bnsw.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzwn1bnsw.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzwn1bnsw.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzwn1bnsw.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbdb7afid.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbdb7afid.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdb7afid.jl:21\ntest set: Test Failed at /tmp/tmpbdb7afid.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbdb7afid.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdb7afid.jl:21\ntest set: Test Failed at /tmp/tmpbdb7afid.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbdb7afid.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdb7afid.jl:21\ntest set: Test Failed at /tmp/tmpbdb7afid.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbdb7afid.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdb7afid.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbdb7afid.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpde1uoowa.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpde1uoowa.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpde1uoowa.jl:21\ntest set: Test Failed at /tmp/tmpde1uoowa.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpde1uoowa.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpde1uoowa.jl:21\ntest set: Test Failed at /tmp/tmpde1uoowa.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpde1uoowa.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpde1uoowa.jl:21\ntest set: Test Failed at /tmp/tmpde1uoowa.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpde1uoowa.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpde1uoowa.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpde1uoowa.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsdu52813.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsdu52813.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsdu52813.jl:21\ntest set: Test Failed at /tmp/tmpsdu52813.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpsdu52813.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsdu52813.jl:21\ntest set: Test Failed at /tmp/tmpsdu52813.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpsdu52813.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsdu52813.jl:21\ntest set: Test Failed at /tmp/tmpsdu52813.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpsdu52813.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsdu52813.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsdu52813.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe2k537jv.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe2k537jv.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe2k537jv.jl:21\ntest set: Test Failed at /tmp/tmpe2k537jv.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpe2k537jv.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe2k537jv.jl:21\ntest set: Test Failed at /tmp/tmpe2k537jv.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpe2k537jv.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe2k537jv.jl:21\ntest set: Test Failed at /tmp/tmpe2k537jv.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpe2k537jv.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe2k537jv.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe2k537jv.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp39v8depj.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp39v8depj.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp39v8depj.jl:21\ntest set: Test Failed at /tmp/tmp39v8depj.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp39v8depj.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp39v8depj.jl:21\ntest set: Test Failed at /tmp/tmp39v8depj.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp39v8depj.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp39v8depj.jl:21\ntest set: Test Failed at /tmp/tmp39v8depj.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp39v8depj.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp39v8depj.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp39v8depj.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp089utvyh.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp089utvyh.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp089utvyh.jl:21\\ntest set: Test Failed at /tmp/tmp089utvyh.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp089utvyh.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp089utvyh.jl:21\\ntest set: Test Failed at /tmp/tmp089utvyh.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp089utvyh.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp089utvyh.jl:21\\ntest set: Test Failed at /tmp/tmp089utvyh.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp089utvyh.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp089utvyh.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmzyptry3.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmzyptry3.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmzyptry3.jl:21\ntest set: Test Failed at /tmp/tmpmzyptry3.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmzyptry3.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmzyptry3.jl:21\ntest set: Test Failed at /tmp/tmpmzyptry3.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmzyptry3.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmzyptry3.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmzyptry3.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpevqwnfx5.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpevqwnfx5.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpevqwnfx5.jl:21\ntest set: Test Failed at /tmp/tmpevqwnfx5.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpevqwnfx5.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpevqwnfx5.jl:21\ntest set: Test Failed at /tmp/tmpevqwnfx5.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpevqwnfx5.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpevqwnfx5.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpevqwnfx5.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    elseif\
    \ all(mod.(lst1, 2) .== 0) && all(mod.(lst2, 2) .== 0)\n        return \"YES\"\
    \n    else\n        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpckl0l0ce.jl:29\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpckl0l0ce.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpckl0l0ce.jl:28\\ntest set: Test Failed at /tmp/tmpckl0l0ce.jl:31\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpckl0l0ce.jl:31\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpckl0l0ce.jl:28\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmplrrvc4tm.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplrrvc4tm.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplrrvc4tm.jl:21\\ntest set: Test Failed at /tmp/tmplrrvc4tm.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmplrrvc4tm.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplrrvc4tm.jl:21\\ntest set: Test Failed at /tmp/tmplrrvc4tm.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmplrrvc4tm.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplrrvc4tm.jl:21\\ntest set: Test Failed at /tmp/tmplrrvc4tm.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmplrrvc4tm.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplrrvc4tm.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg1r8hwn2.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg1r8hwn2.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg1r8hwn2.jl:21\ntest set: Test Failed at /tmp/tmpg1r8hwn2.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpg1r8hwn2.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg1r8hwn2.jl:21\ntest set: Test Failed at /tmp/tmpg1r8hwn2.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpg1r8hwn2.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg1r8hwn2.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg1r8hwn2.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6fxknpf8.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6fxknpf8.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6fxknpf8.jl:21\ntest set: Test Failed at /tmp/tmp6fxknpf8.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6fxknpf8.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6fxknpf8.jl:21\ntest set: Test Failed at /tmp/tmp6fxknpf8.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6fxknpf8.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6fxknpf8.jl:21\ntest set: Test Failed at /tmp/tmp6fxknpf8.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6fxknpf8.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6fxknpf8.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6fxknpf8.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmq0oh3cq.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmq0oh3cq.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmq0oh3cq.jl:21\ntest set: Test Failed at /tmp/tmpmq0oh3cq.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmq0oh3cq.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmq0oh3cq.jl:21\ntest set: Test Failed at /tmp/tmpmq0oh3cq.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmq0oh3cq.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmq0oh3cq.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmq0oh3cq.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppfyzr818.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppfyzr818.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppfyzr818.jl:21\ntest set: Test Failed at /tmp/tmppfyzr818.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmppfyzr818.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppfyzr818.jl:21\ntest set: Test Failed at /tmp/tmppfyzr818.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmppfyzr818.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppfyzr818.jl:21\ntest set: Test Failed at /tmp/tmppfyzr818.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmppfyzr818.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppfyzr818.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppfyzr818.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbjig8y3r.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbjig8y3r.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbjig8y3r.jl:21\ntest set: Test Failed at /tmp/tmpbjig8y3r.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbjig8y3r.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbjig8y3r.jl:21\ntest set: Test Failed at /tmp/tmpbjig8y3r.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbjig8y3r.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbjig8y3r.jl:21\ntest set: Test Failed at /tmp/tmpbjig8y3r.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbjig8y3r.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbjig8y3r.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbjig8y3r.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpe0fst344.jl:23\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpe0fst344.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpe0fst344.jl:21\\ntest set: Test Failed at /tmp/tmpe0fst344.jl:26\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpe0fst344.jl:26\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpe0fst344.jl:21\\ntest set: Test Failed at /tmp/tmpe0fst344.jl:27\\\
    n  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n\
    \   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpe0fst344.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpe0fst344.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4j57z9gi.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp4j57z9gi.jl:15\n   [2] top-level scope at /tmp/tmp4j57z9gi.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4j57z9gi.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4j57z9gi.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4j57z9gi.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4j57z9gi.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4j57z9gi.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4j57z9gi.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4j57z9gi.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4j57z9gi.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4j57z9gi.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4j57z9gi.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4j57z9gi.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4j57z9gi.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4j57z9gi.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4j57z9gi.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4j57z9gi.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4j57z9gi.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4j57z9gi.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4j57z9gi.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4j57z9gi.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4j57z9gi.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4j57z9gi.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4j57z9gi.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4j57z9gi.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4j57z9gi.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4j57z9gi.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4j57z9gi.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpsljkwznb.jl:27\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsljkwznb.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsljkwznb.jl:26\ntest set: Test Failed at /tmp/tmpsljkwznb.jl:29\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpsljkwznb.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsljkwznb.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsljkwznb.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2y7k8g7s.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp2y7k8g7s.jl:15\n   [2] top-level scope at /tmp/tmp2y7k8g7s.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2y7k8g7s.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp2y7k8g7s.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp2y7k8g7s.jl:15\n\
    \   [2] top-level scope at /tmp/tmp2y7k8g7s.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2y7k8g7s.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp2y7k8g7s.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp2y7k8g7s.jl:15\n\
    \   [2] top-level scope at /tmp/tmp2y7k8g7s.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2y7k8g7s.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp2y7k8g7s.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp2y7k8g7s.jl:15\n\
    \   [2] top-level scope at /tmp/tmp2y7k8g7s.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2y7k8g7s.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp2y7k8g7s.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp2y7k8g7s.jl:15\n\
    \   [2] top-level scope at /tmp/tmp2y7k8g7s.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2y7k8g7s.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp2y7k8g7s.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp2y7k8g7s.jl:15\n\
    \   [2] top-level scope at /tmp/tmp2y7k8g7s.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2y7k8g7s.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp2y7k8g7s.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp2y7k8g7s.jl:15\n\
    \   [2] top-level scope at /tmp/tmp2y7k8g7s.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2y7k8g7s.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2y7k8g7s.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpbtp8d13o.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\\
    n  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ String\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T) where\
    \ T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString)\
    \ where T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpbtp8d13o.jl:15\\n   [2] top-level scope at /tmp/tmpbtp8d13o.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbtp8d13o.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbtp8d13o.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpbtp8d13o.jl:15\\\
    n   [2] top-level scope at /tmp/tmpbtp8d13o.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbtp8d13o.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbtp8d13o.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpbtp8d13o.jl:15\\\
    n   [2] top-level scope at /tmp/tmpbtp8d13o.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbtp8d13o.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbtp8d13o.jl:24\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpbtp8d13o.jl:15\\\
    n   [2] top-level scope at /tmp/tmpbtp8d13o.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbtp8d13o.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbtp8d13o.jl:25\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpbtp8d13o.jl:15\\\
    n   [2] top-level scope at /tmp/tmpbtp8d13o.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbtp8d13o.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbtp8d13o.jl:26\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpbtp8d13o.jl:15\\\
    n   [2] top-level scope at /tmp/tmpbtp8d13o.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbtp8d13o.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbtp8d13o.jl:27\\n  Test threw exception\\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpbtp8d13o.jl:15\\\
    n   [2] top-level scope at /tmp/tmpbtp8d13o.jl:27\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbtp8d13o.jl:20\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     7      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc3ccfqca.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc3ccfqca.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc3ccfqca.jl:21\ntest set: Test Failed at /tmp/tmpc3ccfqca.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpc3ccfqca.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc3ccfqca.jl:21\ntest set: Test Failed at /tmp/tmpc3ccfqca.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpc3ccfqca.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc3ccfqca.jl:21\ntest set: Test Failed at /tmp/tmpc3ccfqca.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpc3ccfqca.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc3ccfqca.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc3ccfqca.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzx1ni0vz.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpzx1ni0vz.jl:15\n   [2] top-level scope at /tmp/tmpzx1ni0vz.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzx1ni0vz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpzx1ni0vz.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzx1ni0vz.jl:15\n\
    \   [2] top-level scope at /tmp/tmpzx1ni0vz.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzx1ni0vz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpzx1ni0vz.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzx1ni0vz.jl:15\n\
    \   [2] top-level scope at /tmp/tmpzx1ni0vz.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzx1ni0vz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpzx1ni0vz.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzx1ni0vz.jl:15\n\
    \   [2] top-level scope at /tmp/tmpzx1ni0vz.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzx1ni0vz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpzx1ni0vz.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzx1ni0vz.jl:15\n\
    \   [2] top-level scope at /tmp/tmpzx1ni0vz.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzx1ni0vz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpzx1ni0vz.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzx1ni0vz.jl:15\n\
    \   [2] top-level scope at /tmp/tmpzx1ni0vz.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzx1ni0vz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpzx1ni0vz.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzx1ni0vz.jl:15\n\
    \   [2] top-level scope at /tmp/tmpzx1ni0vz.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzx1ni0vz.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzx1ni0vz.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzqxo0f03.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzqxo0f03.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqxo0f03.jl:21\ntest set: Test Failed at /tmp/tmpzqxo0f03.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzqxo0f03.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqxo0f03.jl:21\ntest set: Test Failed at /tmp/tmpzqxo0f03.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzqxo0f03.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqxo0f03.jl:21\ntest set: Test Failed at /tmp/tmpzqxo0f03.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzqxo0f03.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqxo0f03.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzqxo0f03.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptnee_l8i.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptnee_l8i.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptnee_l8i.jl:21\ntest set: Test Failed at /tmp/tmptnee_l8i.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmptnee_l8i.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptnee_l8i.jl:21\ntest set: Test Failed at /tmp/tmptnee_l8i.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmptnee_l8i.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptnee_l8i.jl:21\ntest set: Test Failed at /tmp/tmptnee_l8i.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmptnee_l8i.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptnee_l8i.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptnee_l8i.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    else\n        for i in 1:length(lst1)\n            if mod(lst1[i],\
    \ 2) != 0\n                for j in 1:length(lst2)\n                    if mod(lst2[j],\
    \ 2) == 0\n                        lst1[i], lst2[j] = lst2[j], lst1[i]\n     \
    \                   break\n                    end\n                end\n    \
    \        end\n        end\n        if all(mod.(lst1, 2) .== 0)\n            return\
    \ \"YES\"\n        else\n            return \"NO\"\n        end\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpw3bo64pc.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpw3bo64pc.jl:15\n   [2] top-level scope at /tmp/tmpw3bo64pc.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw3bo64pc.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpw3bo64pc.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpw3bo64pc.jl:15\n\
    \   [2] top-level scope at /tmp/tmpw3bo64pc.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw3bo64pc.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpw3bo64pc.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpw3bo64pc.jl:15\n\
    \   [2] top-level scope at /tmp/tmpw3bo64pc.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw3bo64pc.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpw3bo64pc.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpw3bo64pc.jl:15\n\
    \   [2] top-level scope at /tmp/tmpw3bo64pc.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw3bo64pc.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpw3bo64pc.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpw3bo64pc.jl:15\n\
    \   [2] top-level scope at /tmp/tmpw3bo64pc.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw3bo64pc.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpw3bo64pc.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpw3bo64pc.jl:15\n\
    \   [2] top-level scope at /tmp/tmpw3bo64pc.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw3bo64pc.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpw3bo64pc.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpw3bo64pc.jl:15\n\
    \   [2] top-level scope at /tmp/tmpw3bo64pc.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw3bo64pc.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw3bo64pc.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmps7u8wocw.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmps7u8wocw.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps7u8wocw.jl:21\\ntest set: Test Failed at /tmp/tmps7u8wocw.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmps7u8wocw.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps7u8wocw.jl:21\\ntest set: Test Failed at /tmp/tmps7u8wocw.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmps7u8wocw.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps7u8wocw.jl:21\\ntest set: Test Failed at /tmp/tmps7u8wocw.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmps7u8wocw.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps7u8wocw.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpwyak46do.jl:27\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwyak46do.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwyak46do.jl:26\ntest set: Test Failed at /tmp/tmpwyak46do.jl:29\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwyak46do.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwyak46do.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwyak46do.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if length(lst1) != length(lst2)\n       \
    \ return \"NO\"\n    end\n    for i in 1:length(lst1)\n        if lst1[i] % 2\
    \ == 1\n            for j in 1:length(lst2)\n                if lst2[j] % 2 ==\
    \ 0\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n               \
    \     break\n                end\n            end\n        end\n    end\n    for\
    \ i in 1:length(lst1)\n        if lst1[i] % 2 == 1\n            return \"NO\"\n\
    \        end\n    end\n    return \"YES\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # check if all elements in lst1 are even\n\
    \    if all(isodd, lst1)\n        return \"NO\"\n    end\n    # check if all elements\
    \ in lst2 are odd\n    if all(iseven, lst2)\n        return \"NO\"\n    end\n\
    \    # check if there is an odd number in lst1\n    if any(isodd, lst1)\n    \
    \    # check if there is an even number in lst2\n        if any(iseven, lst2)\n\
    \            return \"YES\"\n        end\n    end\n    return \"NO\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3,\
    \ 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4])\
    \ == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"\
    NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t\
    @test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph7p3opsn.jl:37\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph7p3opsn.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph7p3opsn.jl:35\ntest set: Test Failed at /tmp/tmph7p3opsn.jl:39\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmph7p3opsn.jl:39\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph7p3opsn.jl:35\ntest set: Test Failed at /tmp/tmph7p3opsn.jl:42\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmph7p3opsn.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph7p3opsn.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph7p3opsn.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgx40v5j9.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgx40v5j9.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgx40v5j9.jl:21\ntest set: Test Failed at /tmp/tmpgx40v5j9.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgx40v5j9.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgx40v5j9.jl:21\ntest set: Test Failed at /tmp/tmpgx40v5j9.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgx40v5j9.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgx40v5j9.jl:21\ntest set: Test Failed at /tmp/tmpgx40v5j9.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgx40v5j9.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgx40v5j9.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgx40v5j9.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8wo1qw0i.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8wo1qw0i.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8wo1qw0i.jl:21\ntest set: Test Failed at /tmp/tmp8wo1qw0i.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp8wo1qw0i.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8wo1qw0i.jl:21\ntest set: Test Failed at /tmp/tmp8wo1qw0i.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp8wo1qw0i.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8wo1qw0i.jl:21\ntest set: Test Failed at /tmp/tmp8wo1qw0i.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp8wo1qw0i.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8wo1qw0i.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8wo1qw0i.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv7v_wioq.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv7v_wioq.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7v_wioq.jl:21\ntest set: Test Failed at /tmp/tmpv7v_wioq.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpv7v_wioq.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7v_wioq.jl:21\ntest set: Test Failed at /tmp/tmpv7v_wioq.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpv7v_wioq.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7v_wioq.jl:21\ntest set: Test Failed at /tmp/tmpv7v_wioq.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpv7v_wioq.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7v_wioq.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv7v_wioq.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw7cxiutp.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw7cxiutp.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw7cxiutp.jl:21\ntest set: Test Failed at /tmp/tmpw7cxiutp.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpw7cxiutp.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw7cxiutp.jl:21\ntest set: Test Failed at /tmp/tmpw7cxiutp.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpw7cxiutp.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw7cxiutp.jl:21\ntest set: Test Failed at /tmp/tmpw7cxiutp.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpw7cxiutp.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw7cxiutp.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw7cxiutp.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(isodd, lst1)\n        return \"NO\"\
    \n    end\n    for i in 1:length(lst1)\n        if isodd(lst1[i])\n          \
    \  for j in 1:length(lst2)\n                if iseven(lst2[j])\n             \
    \       lst1[i], lst2[j] = lst2[j], lst1[i]\n                    break\n     \
    \           end\n            end\n        end\n    end\n    if all(iseven, lst1)\n\
    \        return \"YES\"\n    else\n        return \"NO\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3,\
    \ 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4])\
    \ == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"\
    NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t\
    @test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0zhlca2k.jl:41\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0zhlca2k.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0zhlca2k.jl:37\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0zhlca2k.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpygarho1u.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpygarho1u.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpygarho1u.jl:21\ntest set: Test Failed at /tmp/tmpygarho1u.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpygarho1u.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpygarho1u.jl:21\ntest set: Test Failed at /tmp/tmpygarho1u.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpygarho1u.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpygarho1u.jl:21\ntest set: Test Failed at /tmp/tmpygarho1u.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpygarho1u.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpygarho1u.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpygarho1u.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0e4no5zv.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0e4no5zv.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0e4no5zv.jl:21\ntest set: Test Failed at /tmp/tmp0e4no5zv.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0e4no5zv.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0e4no5zv.jl:21\ntest set: Test Failed at /tmp/tmp0e4no5zv.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0e4no5zv.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0e4no5zv.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0e4no5zv.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcqel0ind.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpcqel0ind.jl:15\n   [2] top-level scope at /tmp/tmpcqel0ind.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcqel0ind.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpcqel0ind.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpcqel0ind.jl:15\n\
    \   [2] top-level scope at /tmp/tmpcqel0ind.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcqel0ind.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpcqel0ind.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpcqel0ind.jl:15\n\
    \   [2] top-level scope at /tmp/tmpcqel0ind.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcqel0ind.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpcqel0ind.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpcqel0ind.jl:15\n\
    \   [2] top-level scope at /tmp/tmpcqel0ind.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcqel0ind.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpcqel0ind.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpcqel0ind.jl:15\n\
    \   [2] top-level scope at /tmp/tmpcqel0ind.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcqel0ind.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpcqel0ind.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpcqel0ind.jl:15\n\
    \   [2] top-level scope at /tmp/tmpcqel0ind.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcqel0ind.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpcqel0ind.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpcqel0ind.jl:15\n\
    \   [2] top-level scope at /tmp/tmpcqel0ind.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcqel0ind.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcqel0ind.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmphpz1gf23.jl:23\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmphpz1gf23.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphpz1gf23.jl:21\\ntest set: Test Failed at /tmp/tmphpz1gf23.jl:26\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphpz1gf23.jl:26\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphpz1gf23.jl:21\\ntest set: Test Failed at /tmp/tmphpz1gf23.jl:27\\\
    n  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n\
    \   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphpz1gf23.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphpz1gf23.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     3      7\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpdlj0610f.jl:23\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpdlj0610f.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdlj0610f.jl:21\\ntest set: Test Failed at /tmp/tmpdlj0610f.jl:26\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdlj0610f.jl:26\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdlj0610f.jl:21\\ntest set: Test Failed at /tmp/tmpdlj0610f.jl:27\\\
    n  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n\
    \   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdlj0610f.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdlj0610f.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     3      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpo3ep_f94.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpo3ep_f94.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo3ep_f94.jl:21\ntest set: Test Failed at /tmp/tmpo3ep_f94.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpo3ep_f94.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo3ep_f94.jl:21\ntest set: Test Failed at /tmp/tmpo3ep_f94.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpo3ep_f94.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo3ep_f94.jl:21\ntest set: Test Failed at /tmp/tmpo3ep_f94.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpo3ep_f94.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo3ep_f94.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo3ep_f94.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(lst1 .% 2 .== 0)\n        return \"\
    YES\"\n    elseif all(lst2 .% 2 .== 0)\n        return \"YES\"\n    else\n   \
    \     return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpeltl5c1g.jl:27\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdmaj885c.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdmaj885c.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdmaj885c.jl:21\ntest set: Test Failed at /tmp/tmpdmaj885c.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpdmaj885c.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdmaj885c.jl:21\ntest set: Test Failed at /tmp/tmpdmaj885c.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpdmaj885c.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdmaj885c.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdmaj885c.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpn8mce707.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpn8mce707.jl:15\n   [2] top-level scope at /tmp/tmpn8mce707.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn8mce707.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpn8mce707.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpn8mce707.jl:15\n\
    \   [2] top-level scope at /tmp/tmpn8mce707.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn8mce707.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpn8mce707.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpn8mce707.jl:15\n\
    \   [2] top-level scope at /tmp/tmpn8mce707.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn8mce707.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpn8mce707.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpn8mce707.jl:15\n\
    \   [2] top-level scope at /tmp/tmpn8mce707.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn8mce707.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpn8mce707.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpn8mce707.jl:15\n\
    \   [2] top-level scope at /tmp/tmpn8mce707.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn8mce707.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpn8mce707.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpn8mce707.jl:15\n\
    \   [2] top-level scope at /tmp/tmpn8mce707.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn8mce707.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpn8mce707.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpn8mce707.jl:15\n\
    \   [2] top-level scope at /tmp/tmpn8mce707.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn8mce707.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn8mce707.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqj9nmk65.jl:27\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqj9nmk65.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqj9nmk65.jl:26\\ntest set: Test Failed at /tmp/tmpqj9nmk65.jl:29\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqj9nmk65.jl:29\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqj9nmk65.jl:26\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4r94j6re.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\\
    n  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ String\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T) where\
    \ T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString)\
    \ where T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp4r94j6re.jl:15\\n   [2] top-level scope at /tmp/tmp4r94j6re.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4r94j6re.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4r94j6re.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4r94j6re.jl:15\\\
    n   [2] top-level scope at /tmp/tmp4r94j6re.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4r94j6re.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4r94j6re.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4r94j6re.jl:15\\\
    n   [2] top-level scope at /tmp/tmp4r94j6re.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4r94j6re.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4r94j6re.jl:24\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4r94j6re.jl:15\\\
    n   [2] top-level scope at /tmp/tmp4r94j6re.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4r94j6re.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4r94j6re.jl:25\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4r94j6re.jl:15\\\
    n   [2] top-level scope at /tmp/tmp4r94j6re.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4r94j6re.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4r94j6re.jl:26\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4r94j6re.jl:15\\\
    n   [2] top-level scope at /tmp/tmp4r94j6re.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4r94j6re.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4r94j6re.jl:27\\n  Test threw exception\\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4r94j6re.jl:15\\\
    n   [2] top-level scope at /tmp/tmp4r94j6re.jl:27\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4r94j6re.jl:20\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     7      7\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb0sbrnqv.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb0sbrnqv.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0sbrnqv.jl:21\ntest set: Test Failed at /tmp/tmpb0sbrnqv.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpb0sbrnqv.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0sbrnqv.jl:21\ntest set: Test Failed at /tmp/tmpb0sbrnqv.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpb0sbrnqv.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0sbrnqv.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb0sbrnqv.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpsjnmd461.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpsjnmd461.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsjnmd461.jl:21\\ntest set: Test Failed at /tmp/tmpsjnmd461.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsjnmd461.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsjnmd461.jl:21\\ntest set: Test Failed at /tmp/tmpsjnmd461.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsjnmd461.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsjnmd461.jl:21\\ntest set: Test Failed at /tmp/tmpsjnmd461.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsjnmd461.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsjnmd461.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1bn9e4rr.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1bn9e4rr.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1bn9e4rr.jl:21\ntest set: Test Failed at /tmp/tmp1bn9e4rr.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1bn9e4rr.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1bn9e4rr.jl:21\ntest set: Test Failed at /tmp/tmp1bn9e4rr.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1bn9e4rr.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1bn9e4rr.jl:21\ntest set: Test Failed at /tmp/tmp1bn9e4rr.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1bn9e4rr.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1bn9e4rr.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1bn9e4rr.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    else\n        for i in 1:length(lst1)\n            if mod(lst1[i],\
    \ 2) != 0\n                for j in 1:length(lst2)\n                    if mod(lst2[j],\
    \ 2) == 0\n                        lst1[i], lst2[j] = lst2[j], lst1[i]\n     \
    \                   break\n                    end\n                end\n    \
    \        end\n        end\n        if all(mod.(lst1, 2) .== 0)\n            return\
    \ \"YES\"\n        else\n            return \"NO\"\n        end\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # check if lst1 is all even\n    if all(isodd,\
    \ lst1)\n        return \"NO\"\n    end\n    # check if lst2 is all odd\n    if\
    \ all(iseven, lst2)\n        return \"NO\"\n    end\n    # check if lst1 is all\
    \ even after swapping\n    for i in 1:length(lst1)\n        if isodd(lst1[i])\n\
    \            for j in 1:length(lst2)\n                if iseven(lst2[j])\n   \
    \                 lst1[i], lst2[j] = lst2[j], lst1[i]\n                    break\n\
    \                end\n            end\n        end\n    end\n    if all(iseven,\
    \ lst1)\n        return \"YES\"\n    else\n        return \"NO\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpiylouxtg.jl:47\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpiylouxtg.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiylouxtg.jl:43\\ntest set: Test Failed at /tmp/tmpiylouxtg.jl:50\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpiylouxtg.jl:50\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiylouxtg.jl:43\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4nzt93fg.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4nzt93fg.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4nzt93fg.jl:21\ntest set: Test Failed at /tmp/tmp4nzt93fg.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4nzt93fg.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4nzt93fg.jl:21\ntest set: Test Failed at /tmp/tmp4nzt93fg.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4nzt93fg.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4nzt93fg.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4nzt93fg.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpojj3yfk7.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpojj3yfk7.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpojj3yfk7.jl:21\ntest set: Test Failed at /tmp/tmpojj3yfk7.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpojj3yfk7.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpojj3yfk7.jl:21\ntest set: Test Failed at /tmp/tmpojj3yfk7.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpojj3yfk7.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpojj3yfk7.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpojj3yfk7.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplvf91bam.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplvf91bam.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplvf91bam.jl:21\ntest set: Test Failed at /tmp/tmplvf91bam.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmplvf91bam.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplvf91bam.jl:21\ntest set: Test Failed at /tmp/tmplvf91bam.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmplvf91bam.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplvf91bam.jl:21\ntest set: Test Failed at /tmp/tmplvf91bam.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmplvf91bam.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplvf91bam.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplvf91bam.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpeew5uaht.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpeew5uaht.jl:15\n   [2] top-level scope at /tmp/tmpeew5uaht.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeew5uaht.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpeew5uaht.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpeew5uaht.jl:15\n\
    \   [2] top-level scope at /tmp/tmpeew5uaht.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeew5uaht.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpeew5uaht.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpeew5uaht.jl:15\n\
    \   [2] top-level scope at /tmp/tmpeew5uaht.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeew5uaht.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpeew5uaht.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpeew5uaht.jl:15\n\
    \   [2] top-level scope at /tmp/tmpeew5uaht.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeew5uaht.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpeew5uaht.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpeew5uaht.jl:15\n\
    \   [2] top-level scope at /tmp/tmpeew5uaht.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeew5uaht.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpeew5uaht.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpeew5uaht.jl:15\n\
    \   [2] top-level scope at /tmp/tmpeew5uaht.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeew5uaht.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpeew5uaht.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpeew5uaht.jl:15\n\
    \   [2] top-level scope at /tmp/tmpeew5uaht.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeew5uaht.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeew5uaht.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprnd9cd5z.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmprnd9cd5z.jl:15\n   [2] top-level scope at /tmp/tmprnd9cd5z.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprnd9cd5z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmprnd9cd5z.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmprnd9cd5z.jl:15\n\
    \   [2] top-level scope at /tmp/tmprnd9cd5z.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprnd9cd5z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmprnd9cd5z.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmprnd9cd5z.jl:15\n\
    \   [2] top-level scope at /tmp/tmprnd9cd5z.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprnd9cd5z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmprnd9cd5z.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmprnd9cd5z.jl:15\n\
    \   [2] top-level scope at /tmp/tmprnd9cd5z.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprnd9cd5z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmprnd9cd5z.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmprnd9cd5z.jl:15\n\
    \   [2] top-level scope at /tmp/tmprnd9cd5z.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprnd9cd5z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmprnd9cd5z.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmprnd9cd5z.jl:15\n\
    \   [2] top-level scope at /tmp/tmprnd9cd5z.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprnd9cd5z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmprnd9cd5z.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmprnd9cd5z.jl:15\n\
    \   [2] top-level scope at /tmp/tmprnd9cd5z.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprnd9cd5z.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprnd9cd5z.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if length(lst1) == length(lst2)\n       \
    \ for i in 1:length(lst1)\n            if lst1[i] % 2 == 1\n                for\
    \ j in 1:length(lst2)\n                    if lst2[j] % 2 == 0\n             \
    \           lst1[i], lst2[j] = lst2[j], lst1[i]\n                        break\n\
    \                    end\n                end\n            end\n        end\n\
    \        for i in 1:length(lst1)\n            if lst1[i] % 2 == 1\n          \
    \      return \"NO\"\n            end\n        end\n        return \"YES\"\n \
    \   else\n        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpge5awk19.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpge5awk19.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpge5awk19.jl:21\ntest set: Test Failed at /tmp/tmpge5awk19.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpge5awk19.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpge5awk19.jl:21\ntest set: Test Failed at /tmp/tmpge5awk19.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpge5awk19.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpge5awk19.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpge5awk19.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    else\n        for i in 1:length(lst1)\n            if mod(lst1[i],\
    \ 2) != 0\n                for j in 1:length(lst2)\n                    if mod(lst2[j],\
    \ 2) == 0\n                        lst1[i], lst2[j] = lst2[j], lst1[i]\n     \
    \                   if all(mod.(lst1, 2) .== 0)\n                            return\
    \ \"YES\"\n                        end\n                    end\n            \
    \    end\n            end\n        end\n    end\n    return \"NO\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3,\
    \ 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4])\
    \ == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"\
    NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t\
    @test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpm4mc96nd.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpm4mc96nd.jl:15\n   [2] top-level scope at /tmp/tmpm4mc96nd.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4mc96nd.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4mc96nd.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpm4mc96nd.jl:15\n\
    \   [2] top-level scope at /tmp/tmpm4mc96nd.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4mc96nd.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4mc96nd.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpm4mc96nd.jl:15\n\
    \   [2] top-level scope at /tmp/tmpm4mc96nd.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4mc96nd.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4mc96nd.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpm4mc96nd.jl:15\n\
    \   [2] top-level scope at /tmp/tmpm4mc96nd.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4mc96nd.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4mc96nd.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpm4mc96nd.jl:15\n\
    \   [2] top-level scope at /tmp/tmpm4mc96nd.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4mc96nd.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4mc96nd.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpm4mc96nd.jl:15\n\
    \   [2] top-level scope at /tmp/tmpm4mc96nd.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4mc96nd.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4mc96nd.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpm4mc96nd.jl:15\n\
    \   [2] top-level scope at /tmp/tmpm4mc96nd.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4mc96nd.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm4mc96nd.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp6vv6bf37.jl:27\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp74vdw30r.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp74vdw30r.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp74vdw30r.jl:21\ntest set: Test Failed at /tmp/tmp74vdw30r.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp74vdw30r.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp74vdw30r.jl:21\ntest set: Test Failed at /tmp/tmp74vdw30r.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp74vdw30r.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp74vdw30r.jl:21\ntest set: Test Failed at /tmp/tmp74vdw30r.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp74vdw30r.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp74vdw30r.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp74vdw30r.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpsvqnoz93.jl:27\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpsvqnoz93.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsvqnoz93.jl:26\\ntest set: Test Failed at /tmp/tmpsvqnoz93.jl:29\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsvqnoz93.jl:29\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsvqnoz93.jl:26\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    5     2      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp4lq_xeu.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp4lq_xeu.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp4lq_xeu.jl:21\ntest set: Test Failed at /tmp/tmpp4lq_xeu.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp4lq_xeu.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp4lq_xeu.jl:21\ntest set: Test Failed at /tmp/tmpp4lq_xeu.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp4lq_xeu.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp4lq_xeu.jl:21\ntest set: Test Failed at /tmp/tmpp4lq_xeu.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp4lq_xeu.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp4lq_xeu.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp4lq_xeu.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi6390a9j.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi6390a9j.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi6390a9j.jl:21\ntest set: Test Failed at /tmp/tmpi6390a9j.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpi6390a9j.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi6390a9j.jl:21\ntest set: Test Failed at /tmp/tmpi6390a9j.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpi6390a9j.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi6390a9j.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi6390a9j.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(isodd, lst1)\n        return \"NO\"\
    \n    end\n    for i in 1:length(lst1)\n        if isodd(lst1[i])\n          \
    \  for j in 1:length(lst2)\n                if iseven(lst2[j])\n             \
    \       lst1[i], lst2[j] = lst2[j], lst1[i]\n                    break\n     \
    \           end\n            end\n        end\n    end\n    if all(iseven, lst1)\n\
    \        return \"YES\"\n    else\n        return \"NO\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3,\
    \ 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4])\
    \ == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"\
    NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t\
    @test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpds4tcol1.jl:41\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpds4tcol1.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpds4tcol1.jl:37\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     1      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    if all(x -> x % 2 ==\
    \ 0, lst1)\n        return \"YES\"\n    end\n    for i in 1:length(lst1)\n   \
    \     for j in 1:length(lst2)\n            if lst1[i] % 2 != 0 && lst2[j] % 2\
    \ == 0\n                lst1[i], lst2[j] = lst2[j], lst1[i]\n                if\
    \ all(x -> x % 2 == 0, lst1)\n                    return \"YES\"\n           \
    \     end\n            end\n        end\n    end\n    return \"NO\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3,\
    \ 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4])\
    \ == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"\
    NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t\
    @test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptiqiby76.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptiqiby76.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptiqiby76.jl:21\ntest set: Test Failed at /tmp/tmptiqiby76.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmptiqiby76.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptiqiby76.jl:21\ntest set: Test Failed at /tmp/tmptiqiby76.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmptiqiby76.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptiqiby76.jl:21\ntest set: Test Failed at /tmp/tmptiqiby76.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmptiqiby76.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptiqiby76.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptiqiby76.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp33c21kmg.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp33c21kmg.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp33c21kmg.jl:21\ntest set: Test Failed at /tmp/tmp33c21kmg.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp33c21kmg.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp33c21kmg.jl:21\ntest set: Test Failed at /tmp/tmp33c21kmg.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp33c21kmg.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp33c21kmg.jl:21\ntest set: Test Failed at /tmp/tmp33c21kmg.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp33c21kmg.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp33c21kmg.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp33c21kmg.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmporuq3r77.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmporuq3r77.jl:15\n   [2] top-level scope at /tmp/tmporuq3r77.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmporuq3r77.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmporuq3r77.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmporuq3r77.jl:15\n\
    \   [2] top-level scope at /tmp/tmporuq3r77.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmporuq3r77.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmporuq3r77.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmporuq3r77.jl:15\n\
    \   [2] top-level scope at /tmp/tmporuq3r77.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmporuq3r77.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmporuq3r77.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmporuq3r77.jl:15\n\
    \   [2] top-level scope at /tmp/tmporuq3r77.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmporuq3r77.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmporuq3r77.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmporuq3r77.jl:15\n\
    \   [2] top-level scope at /tmp/tmporuq3r77.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmporuq3r77.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmporuq3r77.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmporuq3r77.jl:15\n\
    \   [2] top-level scope at /tmp/tmporuq3r77.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmporuq3r77.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmporuq3r77.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmporuq3r77.jl:15\n\
    \   [2] top-level scope at /tmp/tmporuq3r77.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmporuq3r77.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmporuq3r77.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp91ryda_a.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp91ryda_a.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp91ryda_a.jl:21\ntest set: Test Failed at /tmp/tmp91ryda_a.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp91ryda_a.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp91ryda_a.jl:21\ntest set: Test Failed at /tmp/tmp91ryda_a.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp91ryda_a.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp91ryda_a.jl:21\ntest set: Test Failed at /tmp/tmp91ryda_a.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp91ryda_a.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp91ryda_a.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp91ryda_a.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp91b6gki6.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp91b6gki6.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp91b6gki6.jl:21\\ntest set: Test Failed at /tmp/tmp91b6gki6.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp91b6gki6.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp91b6gki6.jl:21\\ntest set: Test Failed at /tmp/tmp91b6gki6.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp91b6gki6.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp91b6gki6.jl:21\\ntest set: Test Failed at /tmp/tmp91b6gki6.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp91b6gki6.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp91b6gki6.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy3l6hd5p.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy3l6hd5p.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy3l6hd5p.jl:21\ntest set: Test Failed at /tmp/tmpy3l6hd5p.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy3l6hd5p.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy3l6hd5p.jl:21\ntest set: Test Failed at /tmp/tmpy3l6hd5p.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy3l6hd5p.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy3l6hd5p.jl:21\ntest set: Test Failed at /tmp/tmpy3l6hd5p.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy3l6hd5p.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy3l6hd5p.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy3l6hd5p.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkladkwg3.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkladkwg3.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkladkwg3.jl:21\ntest set: Test Failed at /tmp/tmpkladkwg3.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpkladkwg3.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkladkwg3.jl:21\ntest set: Test Failed at /tmp/tmpkladkwg3.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpkladkwg3.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkladkwg3.jl:21\ntest set: Test Failed at /tmp/tmpkladkwg3.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpkladkwg3.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkladkwg3.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkladkwg3.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpwtc2z_b9.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwtc2z_b9.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwtc2z_b9.jl:21\\ntest set: Test Failed at /tmp/tmpwtc2z_b9.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwtc2z_b9.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwtc2z_b9.jl:21\\ntest set: Test Failed at /tmp/tmpwtc2z_b9.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwtc2z_b9.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwtc2z_b9.jl:21\\ntest set: Test Failed at /tmp/tmpwtc2z_b9.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwtc2z_b9.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwtc2z_b9.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzk00rmie.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\\
    n  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ String\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T) where\
    \ T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString)\
    \ where T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpzk00rmie.jl:15\\n   [2] top-level scope at /tmp/tmpzk00rmie.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzk00rmie.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzk00rmie.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzk00rmie.jl:15\\\
    n   [2] top-level scope at /tmp/tmpzk00rmie.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzk00rmie.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzk00rmie.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzk00rmie.jl:15\\\
    n   [2] top-level scope at /tmp/tmpzk00rmie.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzk00rmie.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzk00rmie.jl:24\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzk00rmie.jl:15\\\
    n   [2] top-level scope at /tmp/tmpzk00rmie.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzk00rmie.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzk00rmie.jl:25\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzk00rmie.jl:15\\\
    n   [2] top-level scope at /tmp/tmpzk00rmie.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzk00rmie.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzk00rmie.jl:26\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzk00rmie.jl:15\\\
    n   [2] top-level scope at /tmp/tmpzk00rmie.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzk00rmie.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzk00rmie.jl:27\\n  Test threw exception\\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpzk00rmie.jl:15\\\
    n   [2] top-level scope at /tmp/tmpzk00rmie.jl:27\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzk00rmie.jl:20\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     7      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7w2wiaa6.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7w2wiaa6.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7w2wiaa6.jl:21\ntest set: Test Failed at /tmp/tmp7w2wiaa6.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp7w2wiaa6.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7w2wiaa6.jl:21\ntest set: Test Failed at /tmp/tmp7w2wiaa6.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp7w2wiaa6.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7w2wiaa6.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7w2wiaa6.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpk4mo2v7w.jl:27\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk4mo2v7w.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4mo2v7w.jl:26\ntest set: Test Failed at /tmp/tmpk4mo2v7w.jl:29\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpk4mo2v7w.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4mo2v7w.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk4mo2v7w.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    else\n        for i in 1:length(lst1)\n            if mod(lst1[i],\
    \ 2) != 0\n                for j in 1:length(lst2)\n                    if mod(lst2[j],\
    \ 2) == 0\n                        lst1[i], lst2[j] = lst2[j], lst1[i]\n     \
    \                   break\n                    end\n                end\n    \
    \        end\n        end\n        if all(mod.(lst1, 2) .== 0)\n            return\
    \ \"YES\"\n        else\n            return \"NO\"\n        end\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    else\n        for i in 1:length(lst1)\n            if mod(lst1[i],\
    \ 2) != 0\n                for j in 1:length(lst2)\n                    if mod(lst2[j],\
    \ 2) == 0\n                        lst1[i], lst2[j] = lst2[j], lst1[i]\n     \
    \                   break\n                    end\n                end\n    \
    \        end\n        end\n        if all(mod.(lst1, 2) .== 0)\n            return\
    \ \"YES\"\n        else\n            return \"NO\"\n        end\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if length(lst1) == length(lst2)\n       \
    \ for i in 1:length(lst1)\n            if lst1[i] % 2 == 1\n                for\
    \ j in 1:length(lst2)\n                    if lst2[j] % 2 == 0\n             \
    \           lst1[i], lst2[j] = lst2[j], lst1[i]\n                        break\n\
    \                    end\n                end\n            end\n        end\n\
    \        for i in 1:length(lst1)\n            if lst1[i] % 2 == 1\n          \
    \      return \"NO\"\n            end\n        end\n        return \"YES\"\n \
    \   else\n        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3v922nk3.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3v922nk3.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3v922nk3.jl:21\ntest set: Test Failed at /tmp/tmp3v922nk3.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3v922nk3.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3v922nk3.jl:21\ntest set: Test Failed at /tmp/tmp3v922nk3.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3v922nk3.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3v922nk3.jl:21\ntest set: Test Failed at /tmp/tmp3v922nk3.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3v922nk3.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3v922nk3.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3v922nk3.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe1csnvdz.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe1csnvdz.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe1csnvdz.jl:21\ntest set: Test Failed at /tmp/tmpe1csnvdz.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpe1csnvdz.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe1csnvdz.jl:21\ntest set: Test Failed at /tmp/tmpe1csnvdz.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpe1csnvdz.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe1csnvdz.jl:21\ntest set: Test Failed at /tmp/tmpe1csnvdz.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpe1csnvdz.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe1csnvdz.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe1csnvdz.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqs85zzn6.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqs85zzn6.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqs85zzn6.jl:21\\ntest set: Test Failed at /tmp/tmpqs85zzn6.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqs85zzn6.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqs85zzn6.jl:21\\ntest set: Test Failed at /tmp/tmpqs85zzn6.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqs85zzn6.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqs85zzn6.jl:21\\ntest set: Test Failed at /tmp/tmpqs85zzn6.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqs85zzn6.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqs85zzn6.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmplinklmd2.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmplinklmd2.jl:15\n   [2] top-level scope at /tmp/tmplinklmd2.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplinklmd2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplinklmd2.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplinklmd2.jl:15\n\
    \   [2] top-level scope at /tmp/tmplinklmd2.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplinklmd2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplinklmd2.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplinklmd2.jl:15\n\
    \   [2] top-level scope at /tmp/tmplinklmd2.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplinklmd2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplinklmd2.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplinklmd2.jl:15\n\
    \   [2] top-level scope at /tmp/tmplinklmd2.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplinklmd2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplinklmd2.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplinklmd2.jl:15\n\
    \   [2] top-level scope at /tmp/tmplinklmd2.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplinklmd2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplinklmd2.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplinklmd2.jl:15\n\
    \   [2] top-level scope at /tmp/tmplinklmd2.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplinklmd2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplinklmd2.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplinklmd2.jl:15\n\
    \   [2] top-level scope at /tmp/tmplinklmd2.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplinklmd2.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplinklmd2.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    if all(mod.(lst1, 2)\
    \ .== 0)\n        return \"YES\"\n    end\n    for i in 1:length(lst1)\n     \
    \   for j in 1:length(lst2)\n            if mod(lst1[i], 2) != 0 && mod(lst2[j],\
    \ 2) == 0\n                lst1[i], lst2[j] = lst2[j], lst1[i]\n            end\n\
    \        end\n    end\n    if all(mod.(lst1, 2) .== 0)\n        return \"YES\"\
    \n    else\n        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz87tqxrw.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz87tqxrw.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz87tqxrw.jl:21\ntest set: Test Failed at /tmp/tmpz87tqxrw.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpz87tqxrw.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz87tqxrw.jl:21\ntest set: Test Failed at /tmp/tmpz87tqxrw.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpz87tqxrw.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz87tqxrw.jl:21\ntest set: Test Failed at /tmp/tmpz87tqxrw.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpz87tqxrw.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz87tqxrw.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz87tqxrw.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif any(mod.(lst1, 2) .== 0) && any(mod.(lst2, 2) .== 0)\n \
    \       return \"YES\"\n    else\n        return \"NO\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1,\
    \ 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\
    )\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"\
    NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t\
    @test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw330p0du.jl:28\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw330p0du.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw330p0du.jl:26\ntest set: Test Failed at /tmp/tmpw330p0du.jl:30\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpw330p0du.jl:30\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw330p0du.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw330p0du.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbr8gth6l.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbr8gth6l.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbr8gth6l.jl:21\ntest set: Test Failed at /tmp/tmpbr8gth6l.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbr8gth6l.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbr8gth6l.jl:21\ntest set: Test Failed at /tmp/tmpbr8gth6l.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbr8gth6l.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbr8gth6l.jl:21\ntest set: Test Failed at /tmp/tmpbr8gth6l.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbr8gth6l.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbr8gth6l.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbr8gth6l.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu6uaxvri.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu6uaxvri.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6uaxvri.jl:21\ntest set: Test Failed at /tmp/tmpu6uaxvri.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpu6uaxvri.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6uaxvri.jl:21\ntest set: Test Failed at /tmp/tmpu6uaxvri.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpu6uaxvri.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6uaxvri.jl:21\ntest set: Test Failed at /tmp/tmpu6uaxvri.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpu6uaxvri.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6uaxvri.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu6uaxvri.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    for i in 1:length(lst1)\n        if lst1[i]\
    \ % 2 != 0\n            for j in 1:length(lst2)\n                if lst2[j] %\
    \ 2 != 0\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n          \
    \          break\n                end\n            end\n        end\n    end\n\
    \    if all(x % 2 == 0 for x in lst1)\n        return \"YES\"\n    else\n    \
    \    return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpzevatjm1.jl:35\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzevatjm1.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzevatjm1.jl:34\ntest set: Test Failed at /tmp/tmpzevatjm1.jl:37\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzevatjm1.jl:37\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzevatjm1.jl:34\ntest set: Test Failed at /tmp/tmpzevatjm1.jl:38\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzevatjm1.jl:38\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzevatjm1.jl:34\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzevatjm1.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp0fnrcqk6.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp0fnrcqk6.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0fnrcqk6.jl:21\\ntest set: Test Failed at /tmp/tmp0fnrcqk6.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp0fnrcqk6.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0fnrcqk6.jl:21\\ntest set: Test Failed at /tmp/tmp0fnrcqk6.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp0fnrcqk6.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0fnrcqk6.jl:21\\ntest set: Test Failed at /tmp/tmp0fnrcqk6.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp0fnrcqk6.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0fnrcqk6.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplnq77dfh.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplnq77dfh.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnq77dfh.jl:21\ntest set: Test Failed at /tmp/tmplnq77dfh.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmplnq77dfh.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnq77dfh.jl:21\ntest set: Test Failed at /tmp/tmplnq77dfh.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmplnq77dfh.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnq77dfh.jl:21\ntest set: Test Failed at /tmp/tmplnq77dfh.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmplnq77dfh.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnq77dfh.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplnq77dfh.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzi7srvkh.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpzi7srvkh.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzi7srvkh.jl:21\\ntest set: Test Failed at /tmp/tmpzi7srvkh.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzi7srvkh.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzi7srvkh.jl:21\\ntest set: Test Failed at /tmp/tmpzi7srvkh.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzi7srvkh.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzi7srvkh.jl:21\\ntest set: Test Failed at /tmp/tmpzi7srvkh.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzi7srvkh.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzi7srvkh.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpgurgzi_6.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpgurgzi_6.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgurgzi_6.jl:21\\ntest set: Test Failed at /tmp/tmpgurgzi_6.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgurgzi_6.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgurgzi_6.jl:21\\ntest set: Test Failed at /tmp/tmpgurgzi_6.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgurgzi_6.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgurgzi_6.jl:21\\ntest set: Test Failed at /tmp/tmpgurgzi_6.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgurgzi_6.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgurgzi_6.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpgurgzi_6.jl:19\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp_nkrq44y.jl:27\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_nkrq44y.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_nkrq44y.jl:26\ntest set: Test Failed at /tmp/tmp_nkrq44y.jl:29\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp_nkrq44y.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_nkrq44y.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_nkrq44y.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_et4ctsu.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_et4ctsu.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_et4ctsu.jl:21\ntest set: Test Failed at /tmp/tmp_et4ctsu.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp_et4ctsu.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_et4ctsu.jl:21\ntest set: Test Failed at /tmp/tmp_et4ctsu.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp_et4ctsu.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_et4ctsu.jl:21\ntest set: Test Failed at /tmp/tmp_et4ctsu.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp_et4ctsu.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_et4ctsu.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_et4ctsu.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1eqm0nu7.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1eqm0nu7.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1eqm0nu7.jl:21\ntest set: Test Failed at /tmp/tmp1eqm0nu7.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1eqm0nu7.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1eqm0nu7.jl:21\ntest set: Test Failed at /tmp/tmp1eqm0nu7.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1eqm0nu7.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1eqm0nu7.jl:21\ntest set: Test Failed at /tmp/tmp1eqm0nu7.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1eqm0nu7.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1eqm0nu7.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1eqm0nu7.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmphsugfwcg.jl:23\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmphsugfwcg.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphsugfwcg.jl:21\\ntest set: Test Failed at /tmp/tmphsugfwcg.jl:26\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphsugfwcg.jl:26\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphsugfwcg.jl:21\\ntest set: Test Failed at /tmp/tmphsugfwcg.jl:27\\\
    n  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n\
    \   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphsugfwcg.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphsugfwcg.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     3      7\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmphsugfwcg.jl:19\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxo8omu1_.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpxo8omu1_.jl:15\n   [2] top-level scope at /tmp/tmpxo8omu1_.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxo8omu1_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpxo8omu1_.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpxo8omu1_.jl:15\n\
    \   [2] top-level scope at /tmp/tmpxo8omu1_.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxo8omu1_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpxo8omu1_.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpxo8omu1_.jl:15\n\
    \   [2] top-level scope at /tmp/tmpxo8omu1_.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxo8omu1_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpxo8omu1_.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpxo8omu1_.jl:15\n\
    \   [2] top-level scope at /tmp/tmpxo8omu1_.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxo8omu1_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpxo8omu1_.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpxo8omu1_.jl:15\n\
    \   [2] top-level scope at /tmp/tmpxo8omu1_.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxo8omu1_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpxo8omu1_.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpxo8omu1_.jl:15\n\
    \   [2] top-level scope at /tmp/tmpxo8omu1_.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxo8omu1_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpxo8omu1_.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpxo8omu1_.jl:15\n\
    \   [2] top-level scope at /tmp/tmpxo8omu1_.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxo8omu1_.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxo8omu1_.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1zs28z3s.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1zs28z3s.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zs28z3s.jl:21\ntest set: Test Failed at /tmp/tmp1zs28z3s.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1zs28z3s.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zs28z3s.jl:21\ntest set: Test Failed at /tmp/tmp1zs28z3s.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1zs28z3s.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zs28z3s.jl:21\ntest set: Test Failed at /tmp/tmp1zs28z3s.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1zs28z3s.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zs28z3s.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1zs28z3s.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpob1b101q.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpob1b101q.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpob1b101q.jl:21\\ntest set: Test Failed at /tmp/tmpob1b101q.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpob1b101q.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpob1b101q.jl:21\\ntest set: Test Failed at /tmp/tmpob1b101q.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpob1b101q.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpob1b101q.jl:21\\ntest set: Test Failed at /tmp/tmpob1b101q.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpob1b101q.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpob1b101q.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmplq4gzem9.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmplq4gzem9.jl:15\n   [2] top-level scope at /tmp/tmplq4gzem9.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplq4gzem9.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplq4gzem9.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplq4gzem9.jl:15\n\
    \   [2] top-level scope at /tmp/tmplq4gzem9.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplq4gzem9.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplq4gzem9.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplq4gzem9.jl:15\n\
    \   [2] top-level scope at /tmp/tmplq4gzem9.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplq4gzem9.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplq4gzem9.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplq4gzem9.jl:15\n\
    \   [2] top-level scope at /tmp/tmplq4gzem9.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplq4gzem9.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplq4gzem9.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplq4gzem9.jl:15\n\
    \   [2] top-level scope at /tmp/tmplq4gzem9.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplq4gzem9.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplq4gzem9.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplq4gzem9.jl:15\n\
    \   [2] top-level scope at /tmp/tmplq4gzem9.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplq4gzem9.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplq4gzem9.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmplq4gzem9.jl:15\n\
    \   [2] top-level scope at /tmp/tmplq4gzem9.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplq4gzem9.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplq4gzem9.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmprx5cxmbl.jl:27\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprx5cxmbl.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprx5cxmbl.jl:26\ntest set: Test Failed at /tmp/tmprx5cxmbl.jl:29\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmprx5cxmbl.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprx5cxmbl.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprx5cxmbl.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqd6m9afv.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqd6m9afv.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqd6m9afv.jl:21\ntest set: Test Failed at /tmp/tmpqd6m9afv.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqd6m9afv.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqd6m9afv.jl:21\ntest set: Test Failed at /tmp/tmpqd6m9afv.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqd6m9afv.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqd6m9afv.jl:21\ntest set: Test Failed at /tmp/tmpqd6m9afv.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqd6m9afv.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqd6m9afv.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqd6m9afv.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf28aklxk.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf28aklxk.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf28aklxk.jl:21\ntest set: Test Failed at /tmp/tmpf28aklxk.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpf28aklxk.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf28aklxk.jl:21\ntest set: Test Failed at /tmp/tmpf28aklxk.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpf28aklxk.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf28aklxk.jl:21\ntest set: Test Failed at /tmp/tmpf28aklxk.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpf28aklxk.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf28aklxk.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf28aklxk.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(x -> x % 2 == 0, lst1)\n        return\
    \ \"YES\"\n    end\n    for i in 1:length(lst1)\n        for j in 1:length(lst2)\n\
    \            if lst1[i] % 2 != 0 && lst2[j] % 2 != 0\n                lst1[i],\
    \ lst2[j] = lst2[j], lst1[i]\n                if all(x -> x % 2 == 0, lst1)\n\
    \                    return \"YES\"\n                end\n            end\n  \
    \      end\n    end\n    return \"NO\"\nend\nusing Test\n\n@testset begin\n\n\
    candidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_n0g072g.jl:34\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_n0g072g.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_n0g072g.jl:33\ntest set: Test Failed at /tmp/tmp_n0g072g.jl:36\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp_n0g072g.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_n0g072g.jl:33\ntest set: Test Failed at /tmp/tmp_n0g072g.jl:37\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp_n0g072g.jl:37\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_n0g072g.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_n0g072g.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpiyh4ngdo.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpiyh4ngdo.jl:15\n   [2] top-level scope at /tmp/tmpiyh4ngdo.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyh4ngdo.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpiyh4ngdo.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpiyh4ngdo.jl:15\n\
    \   [2] top-level scope at /tmp/tmpiyh4ngdo.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyh4ngdo.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpiyh4ngdo.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpiyh4ngdo.jl:15\n\
    \   [2] top-level scope at /tmp/tmpiyh4ngdo.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyh4ngdo.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpiyh4ngdo.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpiyh4ngdo.jl:15\n\
    \   [2] top-level scope at /tmp/tmpiyh4ngdo.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyh4ngdo.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpiyh4ngdo.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpiyh4ngdo.jl:15\n\
    \   [2] top-level scope at /tmp/tmpiyh4ngdo.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyh4ngdo.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpiyh4ngdo.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpiyh4ngdo.jl:15\n\
    \   [2] top-level scope at /tmp/tmpiyh4ngdo.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyh4ngdo.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpiyh4ngdo.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpiyh4ngdo.jl:15\n\
    \   [2] top-level scope at /tmp/tmpiyh4ngdo.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyh4ngdo.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiyh4ngdo.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjch5x79g.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpjch5x79g.jl:15\n   [2] top-level scope at /tmp/tmpjch5x79g.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjch5x79g.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpjch5x79g.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpjch5x79g.jl:15\n\
    \   [2] top-level scope at /tmp/tmpjch5x79g.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjch5x79g.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpjch5x79g.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpjch5x79g.jl:15\n\
    \   [2] top-level scope at /tmp/tmpjch5x79g.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjch5x79g.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpjch5x79g.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpjch5x79g.jl:15\n\
    \   [2] top-level scope at /tmp/tmpjch5x79g.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjch5x79g.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpjch5x79g.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpjch5x79g.jl:15\n\
    \   [2] top-level scope at /tmp/tmpjch5x79g.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjch5x79g.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpjch5x79g.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpjch5x79g.jl:15\n\
    \   [2] top-level scope at /tmp/tmpjch5x79g.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjch5x79g.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpjch5x79g.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpjch5x79g.jl:15\n\
    \   [2] top-level scope at /tmp/tmpjch5x79g.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjch5x79g.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjch5x79g.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv7jtrj61.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv7jtrj61.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7jtrj61.jl:21\ntest set: Test Failed at /tmp/tmpv7jtrj61.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpv7jtrj61.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7jtrj61.jl:21\ntest set: Test Failed at /tmp/tmpv7jtrj61.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpv7jtrj61.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7jtrj61.jl:21\ntest set: Test Failed at /tmp/tmpv7jtrj61.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpv7jtrj61.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7jtrj61.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv7jtrj61.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpi36srknn.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpi36srknn.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi36srknn.jl:21\\ntest set: Test Failed at /tmp/tmpi36srknn.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi36srknn.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi36srknn.jl:21\\ntest set: Test Failed at /tmp/tmpi36srknn.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi36srknn.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi36srknn.jl:21\\ntest set: Test Failed at /tmp/tmpi36srknn.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi36srknn.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi36srknn.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpaj3lsb09.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpaj3lsb09.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj3lsb09.jl:21\ntest set: Test Failed at /tmp/tmpaj3lsb09.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpaj3lsb09.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj3lsb09.jl:21\ntest set: Test Failed at /tmp/tmpaj3lsb09.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpaj3lsb09.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj3lsb09.jl:21\ntest set: Test Failed at /tmp/tmpaj3lsb09.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpaj3lsb09.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj3lsb09.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaj3lsb09.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpd2lz6b9q.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpd2lz6b9q.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd2lz6b9q.jl:21\\ntest set: Test Failed at /tmp/tmpd2lz6b9q.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpd2lz6b9q.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd2lz6b9q.jl:21\\ntest set: Test Failed at /tmp/tmpd2lz6b9q.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpd2lz6b9q.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd2lz6b9q.jl:21\\ntest set: Test Failed at /tmp/tmpd2lz6b9q.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpd2lz6b9q.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd2lz6b9q.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk_8l73vx.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk_8l73vx.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk_8l73vx.jl:21\ntest set: Test Failed at /tmp/tmpk_8l73vx.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpk_8l73vx.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk_8l73vx.jl:21\ntest set: Test Failed at /tmp/tmpk_8l73vx.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpk_8l73vx.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk_8l73vx.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk_8l73vx.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnskjq4yt.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnskjq4yt.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnskjq4yt.jl:21\ntest set: Test Failed at /tmp/tmpnskjq4yt.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnskjq4yt.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnskjq4yt.jl:21\ntest set: Test Failed at /tmp/tmpnskjq4yt.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnskjq4yt.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnskjq4yt.jl:21\ntest set: Test Failed at /tmp/tmpnskjq4yt.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnskjq4yt.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnskjq4yt.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnskjq4yt.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpd6o2r9p_.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpd6o2r9p_.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd6o2r9p_.jl:21\\ntest set: Test Failed at /tmp/tmpd6o2r9p_.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpd6o2r9p_.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd6o2r9p_.jl:21\\ntest set: Test Failed at /tmp/tmpd6o2r9p_.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpd6o2r9p_.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd6o2r9p_.jl:21\\ntest set: Test Failed at /tmp/tmpd6o2r9p_.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpd6o2r9p_.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd6o2r9p_.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpum_vrl99.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpum_vrl99.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpum_vrl99.jl:21\\ntest set: Test Failed at /tmp/tmpum_vrl99.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpum_vrl99.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpum_vrl99.jl:21\\ntest set: Test Failed at /tmp/tmpum_vrl99.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpum_vrl99.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpum_vrl99.jl:21\\ntest set: Test Failed at /tmp/tmpum_vrl99.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpum_vrl99.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpum_vrl99.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3pxyl95r.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3pxyl95r.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3pxyl95r.jl:21\ntest set: Test Failed at /tmp/tmp3pxyl95r.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3pxyl95r.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3pxyl95r.jl:21\ntest set: Test Failed at /tmp/tmp3pxyl95r.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3pxyl95r.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3pxyl95r.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3pxyl95r.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_t8fld76.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_t8fld76.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_t8fld76.jl:21\ntest set: Test Failed at /tmp/tmp_t8fld76.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp_t8fld76.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_t8fld76.jl:21\ntest set: Test Failed at /tmp/tmp_t8fld76.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp_t8fld76.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_t8fld76.jl:21\ntest set: Test Failed at /tmp/tmp_t8fld76.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp_t8fld76.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_t8fld76.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_t8fld76.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpva5umf10.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpva5umf10.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpva5umf10.jl:21\ntest set: Test Failed at /tmp/tmpva5umf10.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpva5umf10.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpva5umf10.jl:21\ntest set: Test Failed at /tmp/tmpva5umf10.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpva5umf10.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpva5umf10.jl:21\ntest set: Test Failed at /tmp/tmpva5umf10.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpva5umf10.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpva5umf10.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpva5umf10.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmr328y6l.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpmr328y6l.jl:15\n   [2] top-level scope at /tmp/tmpmr328y6l.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmr328y6l.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpmr328y6l.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpmr328y6l.jl:15\n\
    \   [2] top-level scope at /tmp/tmpmr328y6l.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmr328y6l.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpmr328y6l.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpmr328y6l.jl:15\n\
    \   [2] top-level scope at /tmp/tmpmr328y6l.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmr328y6l.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpmr328y6l.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpmr328y6l.jl:15\n\
    \   [2] top-level scope at /tmp/tmpmr328y6l.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmr328y6l.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpmr328y6l.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpmr328y6l.jl:15\n\
    \   [2] top-level scope at /tmp/tmpmr328y6l.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmr328y6l.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpmr328y6l.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpmr328y6l.jl:15\n\
    \   [2] top-level scope at /tmp/tmpmr328y6l.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmr328y6l.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpmr328y6l.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpmr328y6l.jl:15\n\
    \   [2] top-level scope at /tmp/tmpmr328y6l.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmr328y6l.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmr328y6l.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgdviaaos.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpgdviaaos.jl:15\n   [2] top-level scope at /tmp/tmpgdviaaos.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgdviaaos.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpgdviaaos.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpgdviaaos.jl:15\n\
    \   [2] top-level scope at /tmp/tmpgdviaaos.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgdviaaos.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpgdviaaos.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpgdviaaos.jl:15\n\
    \   [2] top-level scope at /tmp/tmpgdviaaos.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgdviaaos.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpgdviaaos.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpgdviaaos.jl:15\n\
    \   [2] top-level scope at /tmp/tmpgdviaaos.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgdviaaos.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpgdviaaos.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpgdviaaos.jl:15\n\
    \   [2] top-level scope at /tmp/tmpgdviaaos.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgdviaaos.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpgdviaaos.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpgdviaaos.jl:15\n\
    \   [2] top-level scope at /tmp/tmpgdviaaos.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgdviaaos.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpgdviaaos.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpgdviaaos.jl:15\n\
    \   [2] top-level scope at /tmp/tmpgdviaaos.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgdviaaos.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgdviaaos.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    # You can add helper\
    \ functions here\n    if all(mod.(lst1, 2) .== 0)\n        return \"YES\"\n  \
    \  end\n    for i in 1:length(lst1)\n        if mod(lst1[i], 2) != 0\n       \
    \     for j in 1:length(lst2)\n                if mod(lst2[j], 2) == 0\n     \
    \               lst1[i], lst2[j] = lst2[j], lst1[i]\n                    if all(mod.(lst1,\
    \ 2) .== 0)\n                        return \"YES\"\n                    end\n\
    \                end\n            end\n        end\n    end\n    return \"NO\"\
    \nend\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5,\
    \ 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\
    )\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps0bribdv.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps0bribdv.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0bribdv.jl:21\ntest set: Test Failed at /tmp/tmps0bribdv.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmps0bribdv.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0bribdv.jl:21\ntest set: Test Failed at /tmp/tmps0bribdv.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmps0bribdv.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0bribdv.jl:21\ntest set: Test Failed at /tmp/tmps0bribdv.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmps0bribdv.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0bribdv.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps0bribdv.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(x -> iseven(x), lst1)\n        return\
    \ \"YES\"\n    else\n        for i in 1:length(lst1)\n            for j in 1:length(lst2)\n\
    \                if iseven(lst1[i]) && !iseven(lst2[j])\n                    lst1[i],\
    \ lst2[j] = lst2[j], lst1[i]\n                    if all(x -> iseven(x), lst1)\n\
    \                        return \"YES\"\n                    end\n           \
    \     end\n            end\n        end\n    end\n    return \"NO\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3,\
    \ 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4])\
    \ == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"\
    NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t\
    @test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvj8bk61m.jl:35\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvj8bk61m.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvj8bk61m.jl:34\ntest set: Test Failed at /tmp/tmpvj8bk61m.jl:37\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvj8bk61m.jl:37\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvj8bk61m.jl:34\ntest set: Test Failed at /tmp/tmpvj8bk61m.jl:38\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvj8bk61m.jl:38\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvj8bk61m.jl:34\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvj8bk61m.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvdlx2rba.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvdlx2rba.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvdlx2rba.jl:21\ntest set: Test Failed at /tmp/tmpvdlx2rba.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvdlx2rba.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvdlx2rba.jl:21\ntest set: Test Failed at /tmp/tmpvdlx2rba.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvdlx2rba.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvdlx2rba.jl:21\ntest set: Test Failed at /tmp/tmpvdlx2rba.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvdlx2rba.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvdlx2rba.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvdlx2rba.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_vx5be3q.jl:27\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp_vx5be3q.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_vx5be3q.jl:26\\ntest set: Test Failed at /tmp/tmp_vx5be3q.jl:29\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_vx5be3q.jl:29\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_vx5be3q.jl:26\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    5     2      7\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp26yxxlx4.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp26yxxlx4.jl:15\n   [2] top-level scope at /tmp/tmp26yxxlx4.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp26yxxlx4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp26yxxlx4.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp26yxxlx4.jl:15\n\
    \   [2] top-level scope at /tmp/tmp26yxxlx4.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp26yxxlx4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp26yxxlx4.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp26yxxlx4.jl:15\n\
    \   [2] top-level scope at /tmp/tmp26yxxlx4.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp26yxxlx4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp26yxxlx4.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp26yxxlx4.jl:15\n\
    \   [2] top-level scope at /tmp/tmp26yxxlx4.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp26yxxlx4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp26yxxlx4.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp26yxxlx4.jl:15\n\
    \   [2] top-level scope at /tmp/tmp26yxxlx4.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp26yxxlx4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp26yxxlx4.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp26yxxlx4.jl:15\n\
    \   [2] top-level scope at /tmp/tmp26yxxlx4.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp26yxxlx4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp26yxxlx4.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp26yxxlx4.jl:15\n\
    \   [2] top-level scope at /tmp/tmp26yxxlx4.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp26yxxlx4.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp26yxxlx4.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpcc_mga0c.jl:23\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpcc_mga0c.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcc_mga0c.jl:21\\ntest set: Test Failed at /tmp/tmpcc_mga0c.jl:26\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcc_mga0c.jl:26\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcc_mga0c.jl:21\\ntest set: Test Failed at /tmp/tmpcc_mga0c.jl:27\\\
    n  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n\
    \   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcc_mga0c.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcc_mga0c.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfds9th9d.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfds9th9d.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfds9th9d.jl:21\ntest set: Test Failed at /tmp/tmpfds9th9d.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpfds9th9d.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfds9th9d.jl:21\ntest set: Test Failed at /tmp/tmpfds9th9d.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpfds9th9d.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfds9th9d.jl:21\ntest set: Test Failed at /tmp/tmpfds9th9d.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpfds9th9d.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfds9th9d.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfds9th9d.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(x -> x % 2 == 0, lst1)\n        return\
    \ \"YES\"\n    end\n    for i in 1:length(lst1)\n        if lst1[i] % 2 != 0\n\
    \            for j in 1:length(lst2)\n                if lst2[j] % 2 != 0\n  \
    \                  lst1[i], lst2[j] = lst2[j], lst1[i]\n                    if\
    \ all(x -> x % 2 == 0, lst1)\n                        return \"YES\"\n       \
    \             end\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n \
    \               end\n            end\n        end\n    end\n    return \"NO\"\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5,\
    \ 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\
    )\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpb24rp94i.jl:37\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpb24rp94i.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpb24rp94i.jl:36\\ntest set: Test Failed at /tmp/tmpb24rp94i.jl:39\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpb24rp94i.jl:39\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpb24rp94i.jl:36\\ntest set: Test Failed at /tmp/tmpb24rp94i.jl:40\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpb24rp94i.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpb24rp94i.jl:36\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     3      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    else\n        for i in 1:length(lst1)\n            for j in 1:length(lst2)\n\
    \                if mod(lst1[i], 2) != 0 && mod(lst2[j], 2) == 0\n           \
    \         lst1[i], lst2[j] = lst2[j], lst1[i]\n                end\n         \
    \   end\n        end\n        if all(mod.(lst1, 2) .== 0)\n            return\
    \ \"YES\"\n        else\n            return \"NO\"\n        end\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgjgr8is6.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgjgr8is6.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgjgr8is6.jl:21\ntest set: Test Failed at /tmp/tmpgjgr8is6.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgjgr8is6.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgjgr8is6.jl:21\ntest set: Test Failed at /tmp/tmpgjgr8is6.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgjgr8is6.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgjgr8is6.jl:21\ntest set: Test Failed at /tmp/tmpgjgr8is6.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgjgr8is6.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgjgr8is6.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgjgr8is6.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpjllyjjfz.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpjllyjjfz.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjllyjjfz.jl:21\\ntest set: Test Failed at /tmp/tmpjllyjjfz.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpjllyjjfz.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjllyjjfz.jl:21\\ntest set: Test Failed at /tmp/tmpjllyjjfz.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpjllyjjfz.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjllyjjfz.jl:21\\ntest set: Test Failed at /tmp/tmpjllyjjfz.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpjllyjjfz.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjllyjjfz.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf7czr23t.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf7czr23t.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf7czr23t.jl:21\ntest set: Test Failed at /tmp/tmpf7czr23t.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpf7czr23t.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf7czr23t.jl:21\ntest set: Test Failed at /tmp/tmpf7czr23t.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpf7czr23t.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf7czr23t.jl:21\ntest set: Test Failed at /tmp/tmpf7czr23t.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpf7czr23t.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf7czr23t.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf7czr23t.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq6819d2m.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq6819d2m.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq6819d2m.jl:21\ntest set: Test Failed at /tmp/tmpq6819d2m.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpq6819d2m.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq6819d2m.jl:21\ntest set: Test Failed at /tmp/tmpq6819d2m.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpq6819d2m.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq6819d2m.jl:21\ntest set: Test Failed at /tmp/tmpq6819d2m.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpq6819d2m.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq6819d2m.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq6819d2m.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpa0y_xdoj.jl:23\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpa0y_xdoj.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa0y_xdoj.jl:21\\ntest set: Test Failed at /tmp/tmpa0y_xdoj.jl:26\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpa0y_xdoj.jl:26\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa0y_xdoj.jl:21\\ntest set: Test Failed at /tmp/tmpa0y_xdoj.jl:27\\\
    n  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n\
    \   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpa0y_xdoj.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa0y_xdoj.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     3      7\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpa0y_xdoj.jl:19\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_9wf3w3k.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp_9wf3w3k.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_9wf3w3k.jl:21\\ntest set: Test Failed at /tmp/tmp_9wf3w3k.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_9wf3w3k.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_9wf3w3k.jl:21\\ntest set: Test Failed at /tmp/tmp_9wf3w3k.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_9wf3w3k.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_9wf3w3k.jl:21\\ntest set: Test Failed at /tmp/tmp_9wf3w3k.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_9wf3w3k.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_9wf3w3k.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl5snvq52.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl5snvq52.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl5snvq52.jl:21\ntest set: Test Failed at /tmp/tmpl5snvq52.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpl5snvq52.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl5snvq52.jl:21\ntest set: Test Failed at /tmp/tmpl5snvq52.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpl5snvq52.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl5snvq52.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl5snvq52.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmodizsp3.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmodizsp3.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmodizsp3.jl:21\ntest set: Test Failed at /tmp/tmpmodizsp3.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmodizsp3.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmodizsp3.jl:21\ntest set: Test Failed at /tmp/tmpmodizsp3.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmodizsp3.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmodizsp3.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmodizsp3.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if length(lst1) == length(lst2)\n       \
    \ for i in 1:length(lst1)\n            if lst1[i] % 2 == 1\n                for\
    \ j in 1:length(lst2)\n                    if lst2[j] % 2 == 0\n             \
    \           lst1[i], lst2[j] = lst2[j], lst1[i]\n                        break\n\
    \                    end\n                end\n            end\n        end\n\
    \        for i in 1:length(lst1)\n            if lst1[i] % 2 == 1\n          \
    \      return \"NO\"\n            end\n        end\n        return \"YES\"\n \
    \   else\n        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if (length(lst1) != length(lst2))\n     \
    \   return \"NO\"\n    end\n    for i in 1:length(lst1)\n        if (lst1[i] %\
    \ 2 != 0)\n            for j in 1:length(lst2)\n                if (lst2[j] %\
    \ 2 != 0)\n                    continue\n                else\n              \
    \      lst1[i], lst2[j] = lst2[j], lst1[i]\n                    break\n      \
    \          end\n            end\n        end\n    end\n    for i in 1:length(lst1)\n\
    \        if (lst1[i] % 2 != 0)\n            return \"NO\"\n        end\n    end\n\
    \    return \"YES\"\nend\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\
    \t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp95eiod50.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp95eiod50.jl:15\n   [2] top-level scope at /tmp/tmp95eiod50.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp95eiod50.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp95eiod50.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp95eiod50.jl:15\n\
    \   [2] top-level scope at /tmp/tmp95eiod50.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp95eiod50.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp95eiod50.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp95eiod50.jl:15\n\
    \   [2] top-level scope at /tmp/tmp95eiod50.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp95eiod50.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp95eiod50.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp95eiod50.jl:15\n\
    \   [2] top-level scope at /tmp/tmp95eiod50.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp95eiod50.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp95eiod50.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp95eiod50.jl:15\n\
    \   [2] top-level scope at /tmp/tmp95eiod50.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp95eiod50.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp95eiod50.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp95eiod50.jl:15\n\
    \   [2] top-level scope at /tmp/tmp95eiod50.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp95eiod50.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp95eiod50.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp95eiod50.jl:15\n\
    \   [2] top-level scope at /tmp/tmp95eiod50.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp95eiod50.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp95eiod50.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpswqs4jlr.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpswqs4jlr.jl:15\n   [2] top-level scope at /tmp/tmpswqs4jlr.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpswqs4jlr.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpswqs4jlr.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpswqs4jlr.jl:15\n\
    \   [2] top-level scope at /tmp/tmpswqs4jlr.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpswqs4jlr.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpswqs4jlr.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpswqs4jlr.jl:15\n\
    \   [2] top-level scope at /tmp/tmpswqs4jlr.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpswqs4jlr.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpswqs4jlr.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpswqs4jlr.jl:15\n\
    \   [2] top-level scope at /tmp/tmpswqs4jlr.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpswqs4jlr.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpswqs4jlr.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpswqs4jlr.jl:15\n\
    \   [2] top-level scope at /tmp/tmpswqs4jlr.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpswqs4jlr.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpswqs4jlr.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpswqs4jlr.jl:15\n\
    \   [2] top-level scope at /tmp/tmpswqs4jlr.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpswqs4jlr.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpswqs4jlr.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpswqs4jlr.jl:15\n\
    \   [2] top-level scope at /tmp/tmpswqs4jlr.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpswqs4jlr.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpswqs4jlr.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_yqxwtmz.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp_yqxwtmz.jl:15\n   [2] top-level scope at /tmp/tmp_yqxwtmz.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_yqxwtmz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_yqxwtmz.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp_yqxwtmz.jl:15\n\
    \   [2] top-level scope at /tmp/tmp_yqxwtmz.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_yqxwtmz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_yqxwtmz.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp_yqxwtmz.jl:15\n\
    \   [2] top-level scope at /tmp/tmp_yqxwtmz.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_yqxwtmz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_yqxwtmz.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp_yqxwtmz.jl:15\n\
    \   [2] top-level scope at /tmp/tmp_yqxwtmz.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_yqxwtmz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_yqxwtmz.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp_yqxwtmz.jl:15\n\
    \   [2] top-level scope at /tmp/tmp_yqxwtmz.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_yqxwtmz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_yqxwtmz.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp_yqxwtmz.jl:15\n\
    \   [2] top-level scope at /tmp/tmp_yqxwtmz.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_yqxwtmz.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_yqxwtmz.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp_yqxwtmz.jl:15\n\
    \   [2] top-level scope at /tmp/tmp_yqxwtmz.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_yqxwtmz.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_yqxwtmz.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code goes here\n    return \"YES\"\
    \nend\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5,\
    \ 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\
    )\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpggumelbk.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpggumelbk.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpggumelbk.jl:21\ntest set: Test Failed at /tmp/tmpggumelbk.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpggumelbk.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpggumelbk.jl:21\ntest set: Test Failed at /tmp/tmpggumelbk.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpggumelbk.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpggumelbk.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpggumelbk.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqe4rhwpr.jl:23\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqe4rhwpr.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqe4rhwpr.jl:21\\ntest set: Test Failed at /tmp/tmpqe4rhwpr.jl:26\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqe4rhwpr.jl:26\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqe4rhwpr.jl:21\\ntest set: Test Failed at /tmp/tmpqe4rhwpr.jl:27\\\
    n  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n\
    \   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqe4rhwpr.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqe4rhwpr.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3b5zp2hy.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp3b5zp2hy.jl:15\n   [2] top-level scope at /tmp/tmp3b5zp2hy.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3b5zp2hy.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp3b5zp2hy.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp3b5zp2hy.jl:15\n\
    \   [2] top-level scope at /tmp/tmp3b5zp2hy.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3b5zp2hy.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp3b5zp2hy.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp3b5zp2hy.jl:15\n\
    \   [2] top-level scope at /tmp/tmp3b5zp2hy.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3b5zp2hy.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp3b5zp2hy.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp3b5zp2hy.jl:15\n\
    \   [2] top-level scope at /tmp/tmp3b5zp2hy.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3b5zp2hy.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp3b5zp2hy.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp3b5zp2hy.jl:15\n\
    \   [2] top-level scope at /tmp/tmp3b5zp2hy.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3b5zp2hy.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp3b5zp2hy.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp3b5zp2hy.jl:15\n\
    \   [2] top-level scope at /tmp/tmp3b5zp2hy.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3b5zp2hy.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp3b5zp2hy.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp3b5zp2hy.jl:15\n\
    \   [2] top-level scope at /tmp/tmp3b5zp2hy.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3b5zp2hy.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3b5zp2hy.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpb5lwro67.jl:23\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpb5lwro67.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpb5lwro67.jl:21\\ntest set: Test Failed at /tmp/tmpb5lwro67.jl:26\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpb5lwro67.jl:26\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpb5lwro67.jl:21\\ntest set: Test Failed at /tmp/tmpb5lwro67.jl:27\\\
    n  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n\
    \   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpb5lwro67.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpb5lwro67.jl:21\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0xvr_it3.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0xvr_it3.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0xvr_it3.jl:21\ntest set: Test Failed at /tmp/tmp0xvr_it3.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0xvr_it3.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0xvr_it3.jl:21\ntest set: Test Failed at /tmp/tmp0xvr_it3.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0xvr_it3.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0xvr_it3.jl:21\ntest set: Test Failed at /tmp/tmp0xvr_it3.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0xvr_it3.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0xvr_it3.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0xvr_it3.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if length(lst1) == length(lst2)\n       \
    \ for i in 1:length(lst1)\n            if lst1[i] % 2 == 1 && lst2[i] % 2 == 0\n\
    \                return \"YES\"\n            end\n        end\n    end\n    return\
    \ \"NO\"\nend\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5,\
    \ 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\
    )\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp73w8fx8d.jl:28\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp73w8fx8d.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp73w8fx8d.jl:27\ntest set: Test Failed at /tmp/tmp73w8fx8d.jl:32\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp73w8fx8d.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp73w8fx8d.jl:27\ntest set: Test Failed at /tmp/tmp73w8fx8d.jl:34\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp73w8fx8d.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp73w8fx8d.jl:27\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp73w8fx8d.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpecy17hd9.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpecy17hd9.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpecy17hd9.jl:21\ntest set: Test Failed at /tmp/tmpecy17hd9.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpecy17hd9.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpecy17hd9.jl:21\ntest set: Test Failed at /tmp/tmpecy17hd9.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpecy17hd9.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpecy17hd9.jl:21\ntest set: Test Failed at /tmp/tmpecy17hd9.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpecy17hd9.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpecy17hd9.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpecy17hd9.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(x -> x % 2 == 0, lst1)\n        return\
    \ \"YES\"\n    end\n    for i in 1:length(lst1)\n        for j in 1:length(lst2)\n\
    \            if lst1[i] % 2 != 0 && lst2[j] % 2 != 0\n                lst1[i],\
    \ lst2[j] = lst2[j], lst1[i]\n                if all(x -> x % 2 == 0, lst1)\n\
    \                    return \"YES\"\n                end\n            end\n  \
    \      end\n    end\n    return \"NO\"\nend\nusing Test\n\n@testset begin\n\n\
    candidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk_islti0.jl:34\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk_islti0.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk_islti0.jl:33\ntest set: Test Failed at /tmp/tmpk_islti0.jl:36\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpk_islti0.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk_islti0.jl:33\ntest set: Test Failed at /tmp/tmpk_islti0.jl:37\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpk_islti0.jl:37\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk_islti0.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk_islti0.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsyxstvvk.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsyxstvvk.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyxstvvk.jl:21\ntest set: Test Failed at /tmp/tmpsyxstvvk.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpsyxstvvk.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyxstvvk.jl:21\ntest set: Test Failed at /tmp/tmpsyxstvvk.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpsyxstvvk.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyxstvvk.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsyxstvvk.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5371ko_k.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5371ko_k.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5371ko_k.jl:21\ntest set: Test Failed at /tmp/tmp5371ko_k.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5371ko_k.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5371ko_k.jl:21\ntest set: Test Failed at /tmp/tmp5371ko_k.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5371ko_k.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5371ko_k.jl:21\ntest set: Test Failed at /tmp/tmp5371ko_k.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5371ko_k.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5371ko_k.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5371ko_k.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    else\n        for i in 1:length(lst1)\n            if mod(lst1[i],\
    \ 2) != 0\n                for j in 1:length(lst2)\n                    if mod(lst2[j],\
    \ 2) == 0\n                        lst1[i], lst2[j] = lst2[j], lst1[i]\n     \
    \                   break\n                    end\n                end\n    \
    \        end\n        end\n        if all(mod.(lst1, 2) .== 0)\n            return\
    \ \"YES\"\n        else\n            return \"NO\"\n        end\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4yimtl70.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmp4yimtl70.jl:15\n   [2] top-level scope at /tmp/tmp4yimtl70.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4yimtl70.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4yimtl70.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4yimtl70.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4yimtl70.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4yimtl70.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4yimtl70.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4yimtl70.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4yimtl70.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4yimtl70.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4yimtl70.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4yimtl70.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4yimtl70.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4yimtl70.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4yimtl70.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4yimtl70.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4yimtl70.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4yimtl70.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4yimtl70.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4yimtl70.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4yimtl70.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4yimtl70.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4yimtl70.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmp4yimtl70.jl:15\n\
    \   [2] top-level scope at /tmp/tmp4yimtl70.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4yimtl70.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4yimtl70.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(x -> x % 2 == 0, lst1)\n        return\
    \ \"YES\"\n    end\n    for i in 1:length(lst1)\n        for j in 1:length(lst2)\n\
    \            if lst1[i] % 2 != 0 && lst2[j] % 2 != 0\n                lst1[i],\
    \ lst2[j] = lst2[j], lst1[i]\n                if all(x -> x % 2 == 0, lst1)\n\
    \                    return \"YES\"\n                end\n            end\n  \
    \      end\n    end\n    return \"NO\"\nend\nusing Test\n\n@testset begin\n\n\
    candidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8qvda7qp.jl:34\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp8qvda7qp.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8qvda7qp.jl:33\\ntest set: Test Failed at /tmp/tmp8qvda7qp.jl:36\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8qvda7qp.jl:36\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8qvda7qp.jl:33\\ntest set: Test Failed at /tmp/tmp8qvda7qp.jl:37\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8qvda7qp.jl:37\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8qvda7qp.jl:33\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp61rpt5eo.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp61rpt5eo.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp61rpt5eo.jl:21\ntest set: Test Failed at /tmp/tmp61rpt5eo.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp61rpt5eo.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp61rpt5eo.jl:21\ntest set: Test Failed at /tmp/tmp61rpt5eo.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp61rpt5eo.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp61rpt5eo.jl:21\ntest set: Test Failed at /tmp/tmp61rpt5eo.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp61rpt5eo.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp61rpt5eo.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp61rpt5eo.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    elseif\
    \ all(mod.(lst1, 2) .== 0) && all(mod.(lst2, 2) .== 0)\n        return \"YES\"\
    \n    else\n        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpjv6chtj5.jl:29\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpjv6chtj5.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjv6chtj5.jl:28\\ntest set: Test Failed at /tmp/tmpjv6chtj5.jl:31\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpjv6chtj5.jl:31\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjv6chtj5.jl:28\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpg4wq2tf7.jl:27\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg4wq2tf7.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg4wq2tf7.jl:26\ntest set: Test Failed at /tmp/tmpg4wq2tf7.jl:29\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpg4wq2tf7.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg4wq2tf7.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg4wq2tf7.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    elseif\
    \ any(mod.(lst1, 2) .== 0) && any(mod.(lst2, 2) .== 0)\n        return \"YES\"\
    \n    else\n        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7q64z3x4.jl:30\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7q64z3x4.jl:30\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7q64z3x4.jl:28\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7q64z3x4.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if length(lst1) != length(lst2)\n       \
    \ return \"NO\"\n    end\n    for i in 1:length(lst1)\n        if lst1[i] % 2\
    \ == 1\n            for j in 1:length(lst2)\n                if lst2[j] % 2 ==\
    \ 0\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n               \
    \     break\n                end\n            end\n        end\n    end\n    for\
    \ i in 1:length(lst1)\n        if lst1[i] % 2 == 1\n            return \"NO\"\n\
    \        end\n    end\n    return \"YES\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp1fmfxd8i.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp1fmfxd8i.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1fmfxd8i.jl:21\\ntest set: Test Failed at /tmp/tmp1fmfxd8i.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp1fmfxd8i.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1fmfxd8i.jl:21\\ntest set: Test Failed at /tmp/tmp1fmfxd8i.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp1fmfxd8i.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1fmfxd8i.jl:21\\ntest set: Test Failed at /tmp/tmp1fmfxd8i.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp1fmfxd8i.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1fmfxd8i.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmp1fmfxd8i.jl:19\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps9w340f5.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps9w340f5.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps9w340f5.jl:21\ntest set: Test Failed at /tmp/tmps9w340f5.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmps9w340f5.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps9w340f5.jl:21\ntest set: Test Failed at /tmp/tmps9w340f5.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmps9w340f5.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps9w340f5.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps9w340f5.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0447_sn_.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0447_sn_.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0447_sn_.jl:21\ntest set: Test Failed at /tmp/tmp0447_sn_.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0447_sn_.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0447_sn_.jl:21\ntest set: Test Failed at /tmp/tmp0447_sn_.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0447_sn_.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0447_sn_.jl:21\ntest set: Test Failed at /tmp/tmp0447_sn_.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0447_sn_.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0447_sn_.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0447_sn_.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    elseif\
    \ all(mod.(lst1, 2) .== 0) && all(mod.(lst2, 2) .== 0)\n        return \"YES\"\
    \n    else\n        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3g_g4c9y.jl:29\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3g_g4c9y.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3g_g4c9y.jl:28\ntest set: Test Failed at /tmp/tmp3g_g4c9y.jl:31\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3g_g4c9y.jl:31\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3g_g4c9y.jl:28\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3g_g4c9y.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if length(lst1) != length(lst2)\n       \
    \ return \"NO\"\n    end\n    for i in 1:length(lst1)\n        if lst1[i] % 2\
    \ == 1\n            for j in 1:length(lst2)\n                if lst2[j] % 2 ==\
    \ 0\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n               \
    \     break\n                end\n            end\n        end\n    end\n    for\
    \ i in 1:length(lst1)\n        if lst1[i] % 2 == 1\n            return \"NO\"\n\
    \        end\n    end\n    return \"YES\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpwxem41z8.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwxem41z8.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwxem41z8.jl:21\\ntest set: Test Failed at /tmp/tmpwxem41z8.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwxem41z8.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwxem41z8.jl:21\\ntest set: Test Failed at /tmp/tmpwxem41z8.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwxem41z8.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwxem41z8.jl:21\\ntest set: Test Failed at /tmp/tmpwxem41z8.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwxem41z8.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwxem41z8.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1op6gmcq.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1op6gmcq.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1op6gmcq.jl:21\ntest set: Test Failed at /tmp/tmp1op6gmcq.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1op6gmcq.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1op6gmcq.jl:21\ntest set: Test Failed at /tmp/tmp1op6gmcq.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1op6gmcq.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1op6gmcq.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1op6gmcq.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9sfy6wj9.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9sfy6wj9.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9sfy6wj9.jl:21\ntest set: Test Failed at /tmp/tmp9sfy6wj9.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp9sfy6wj9.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9sfy6wj9.jl:21\ntest set: Test Failed at /tmp/tmp9sfy6wj9.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp9sfy6wj9.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9sfy6wj9.jl:21\ntest set: Test Failed at /tmp/tmp9sfy6wj9.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp9sfy6wj9.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9sfy6wj9.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9sfy6wj9.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgbw8kgl1.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgbw8kgl1.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgbw8kgl1.jl:21\ntest set: Test Failed at /tmp/tmpgbw8kgl1.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgbw8kgl1.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgbw8kgl1.jl:21\ntest set: Test Failed at /tmp/tmpgbw8kgl1.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgbw8kgl1.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgbw8kgl1.jl:21\ntest set: Test Failed at /tmp/tmpgbw8kgl1.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgbw8kgl1.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgbw8kgl1.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgbw8kgl1.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphvfwla7c.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphvfwla7c.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphvfwla7c.jl:21\ntest set: Test Failed at /tmp/tmphvfwla7c.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmphvfwla7c.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphvfwla7c.jl:21\ntest set: Test Failed at /tmp/tmphvfwla7c.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmphvfwla7c.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphvfwla7c.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphvfwla7c.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpia5fct36.jl:27\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpia5fct36.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpia5fct36.jl:26\\ntest set: Test Failed at /tmp/tmpia5fct36.jl:29\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpia5fct36.jl:29\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpia5fct36.jl:26\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpp8ojdbh8.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpp8ojdbh8.jl:15\n   [2] top-level scope at /tmp/tmpp8ojdbh8.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp8ojdbh8.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp8ojdbh8.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp8ojdbh8.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp8ojdbh8.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp8ojdbh8.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp8ojdbh8.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp8ojdbh8.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp8ojdbh8.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp8ojdbh8.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp8ojdbh8.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp8ojdbh8.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp8ojdbh8.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp8ojdbh8.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp8ojdbh8.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp8ojdbh8.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp8ojdbh8.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp8ojdbh8.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp8ojdbh8.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp8ojdbh8.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp8ojdbh8.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp8ojdbh8.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp8ojdbh8.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp8ojdbh8.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp8ojdbh8.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp8ojdbh8.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp8ojdbh8.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpivn7crsb.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpivn7crsb.jl:15\n   [2] top-level scope at /tmp/tmpivn7crsb.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpivn7crsb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpivn7crsb.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpivn7crsb.jl:15\n\
    \   [2] top-level scope at /tmp/tmpivn7crsb.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpivn7crsb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpivn7crsb.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpivn7crsb.jl:15\n\
    \   [2] top-level scope at /tmp/tmpivn7crsb.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpivn7crsb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpivn7crsb.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpivn7crsb.jl:15\n\
    \   [2] top-level scope at /tmp/tmpivn7crsb.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpivn7crsb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpivn7crsb.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpivn7crsb.jl:15\n\
    \   [2] top-level scope at /tmp/tmpivn7crsb.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpivn7crsb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpivn7crsb.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpivn7crsb.jl:15\n\
    \   [2] top-level scope at /tmp/tmpivn7crsb.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpivn7crsb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpivn7crsb.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpivn7crsb.jl:15\n\
    \   [2] top-level scope at /tmp/tmpivn7crsb.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpivn7crsb.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpivn7crsb.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(x -> x % 2 == 0, lst1)\n        return\
    \ \"YES\"\n    end\n    for i in 1:length(lst1)\n        if lst1[i] % 2 != 0\n\
    \            for j in 1:length(lst2)\n                if lst2[j] % 2 != 0\n  \
    \                  lst1[i], lst2[j] = lst2[j], lst1[i]\n                    if\
    \ all(x -> x % 2 == 0, lst1)\n                        return \"YES\"\n       \
    \             end\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n \
    \               end\n            end\n        end\n    end\n    return \"NO\"\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5,\
    \ 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\
    )\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmprg6te58v.jl:37\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmprg6te58v.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprg6te58v.jl:36\\ntest set: Test Failed at /tmp/tmprg6te58v.jl:39\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmprg6te58v.jl:39\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprg6te58v.jl:36\\ntest set: Test Failed at /tmp/tmprg6te58v.jl:40\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmprg6te58v.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprg6te58v.jl:36\\nTest Summary: | Pass  Fail \
    \ '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if length(lst1) == length(lst2)\n       \
    \ for i in 1:length(lst1)\n            if lst1[i] % 2 == 1 && lst2[i] % 2 == 0\n\
    \                return \"YES\"\n            end\n        end\n    end\n    return\
    \ \"NO\"\nend\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5,\
    \ 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\
    )\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmptx_rueog.jl:28\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmptx_rueog.jl:28\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptx_rueog.jl:27\\ntest set: Test Failed at /tmp/tmptx_rueog.jl:32\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmptx_rueog.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptx_rueog.jl:27\\ntest set: Test Failed at /tmp/tmptx_rueog.jl:34\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmptx_rueog.jl:34\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptx_rueog.jl:27\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     3      7\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpa8c39pig.jl:22\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\n   Evaluated: \"NO\" == \"YES\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpa8c39pig.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa8c39pig.jl:21\\ntest set: Test Failed at /tmp/tmpa8c39pig.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n   Evaluated:\
    \ \"NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpa8c39pig.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa8c39pig.jl:21\\ntest set: Test Failed at /tmp/tmpa8c39pig.jl:25\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\\n   Evaluated: \"NO\"\
    \ == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpa8c39pig.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa8c39pig.jl:21\\ntest set: Test Failed at /tmp/tmpa8c39pig.jl:28\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpa8c39pig.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa8c39pig.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     4      7\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpukey1uco.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\\\
    n  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ String\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T) where\
    \ T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString)\
    \ where T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpukey1uco.jl:15\\n   [2] top-level scope at /tmp/tmpukey1uco.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpukey1uco.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpukey1uco.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpukey1uco.jl:15\\\
    n   [2] top-level scope at /tmp/tmpukey1uco.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpukey1uco.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpukey1uco.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpukey1uco.jl:15\\\
    n   [2] top-level scope at /tmp/tmpukey1uco.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpukey1uco.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpukey1uco.jl:24\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpukey1uco.jl:15\\\
    n   [2] top-level scope at /tmp/tmpukey1uco.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpukey1uco.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpukey1uco.jl:25\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpukey1uco.jl:15\\\
    n   [2] top-level scope at /tmp/tmpukey1uco.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpukey1uco.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpukey1uco.jl:26\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpukey1uco.jl:15\\\
    n   [2] top-level scope at /tmp/tmpukey1uco.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpukey1uco.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpukey1uco.jl:27\\n  Test threw exception\\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpukey1uco.jl:15\\\
    n   [2] top-level scope at /tmp/tmpukey1uco.jl:27\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpukey1uco.jl:20\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfqqwibnv.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfqqwibnv.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfqqwibnv.jl:21\ntest set: Test Failed at /tmp/tmpfqqwibnv.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpfqqwibnv.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfqqwibnv.jl:21\ntest set: Test Failed at /tmp/tmpfqqwibnv.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpfqqwibnv.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfqqwibnv.jl:21\ntest set: Test Failed at /tmp/tmpfqqwibnv.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpfqqwibnv.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfqqwibnv.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfqqwibnv.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmppikcgbx2.jl:23\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmppikcgbx2.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppikcgbx2.jl:21\\ntest set: Test Failed at /tmp/tmppikcgbx2.jl:26\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmppikcgbx2.jl:26\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppikcgbx2.jl:21\\ntest set: Test Failed at /tmp/tmppikcgbx2.jl:27\\\
    n  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\\n\
    \   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmppikcgbx2.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppikcgbx2.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4  '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    \"\"\"\n    >>> exchange([1, 2, 3, 4], [1,\
    \ 2, 3, 4])\n    \"YES\"\n    >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])\n    \"\
    NO\"\n    \"\"\"\n    # YOUR CODE HERE\n    for i in lst1\n        if i % 2 ==\
    \ 1\n            for j in lst2\n                if j % 2 == 0\n              \
    \      return \"YES\"\n                end\n            end\n        end\n   \
    \ end\n    return \"NO\"\nend\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\
    \t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_fql680k.jl:38\\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\\n   Evaluated: \"YES\" == \"NO\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp_fql680k.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_fql680k.jl:36\\ntest set: Test Failed at /tmp/tmp_fql680k.jl:41\\\
    n  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\\n   Evaluated: \"YES\"\
    \ == \"NO\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_fql680k.jl:41\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_fql680k.jl:36\\ntest set: Test Failed at /tmp/tmp_fql680k.jl:43\\\
    n  Expression: candidate([100, 200], [200, 200]) == \"YES\"\\n   Evaluated: \"\
    NO\" == \"YES\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_fql680k.jl:43\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_fql680k.jl:36\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp76585lt4.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp76585lt4.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp76585lt4.jl:21\ntest set: Test Failed at /tmp/tmp76585lt4.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp76585lt4.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp76585lt4.jl:21\ntest set: Test Failed at /tmp/tmp76585lt4.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp76585lt4.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp76585lt4.jl:21\ntest set: Test Failed at /tmp/tmp76585lt4.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp76585lt4.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp76585lt4.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp76585lt4.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp12csot8y.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp12csot8y.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp12csot8y.jl:21\ntest set: Test Failed at /tmp/tmp12csot8y.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp12csot8y.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp12csot8y.jl:21\ntest set: Test Failed at /tmp/tmp12csot8y.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp12csot8y.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp12csot8y.jl:21\ntest set: Test Failed at /tmp/tmp12csot8y.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp12csot8y.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp12csot8y.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp12csot8y.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeok520xr.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeok520xr.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeok520xr.jl:21\ntest set: Test Failed at /tmp/tmpeok520xr.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpeok520xr.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeok520xr.jl:21\ntest set: Test Failed at /tmp/tmpeok520xr.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmpeok520xr.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeok520xr.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeok520xr.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    else\n        for i in 1:length(lst1)\n            for j in 1:length(lst2)\n\
    \                if mod(lst1[i], 2) == 1 && mod(lst2[j], 2) == 0\n           \
    \         lst1[i], lst2[j] = lst2[j], lst1[i]\n                    if all(mod.(lst1,\
    \ 2) .== 0)\n                        return \"YES\"\n                    end\n\
    \                end\n            end\n        end\n    end\n    return \"NO\"\
    \nend\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5,\
    \ 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\
    )\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4])\
    \ == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpp4falv21.jl:21\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] exchange(::Array{Int64,1},\
    \ ::Array{Int64,1}) at /tmp/tmpp4falv21.jl:15\n   [2] top-level scope at /tmp/tmpp4falv21.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp4falv21.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp4falv21.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp4falv21.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp4falv21.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp4falv21.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp4falv21.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp4falv21.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp4falv21.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp4falv21.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp4falv21.jl:24\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 4]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp4falv21.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp4falv21.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp4falv21.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp4falv21.jl:25\n  Test threw exception\n  Expression: candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp4falv21.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp4falv21.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp4falv21.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp4falv21.jl:26\n  Test threw exception\n  Expression: candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp4falv21.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp4falv21.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp4falv21.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpp4falv21.jl:27\n  Test threw exception\n  Expression: candidate([100,\
    \ 200], [200, 200]) == \"YES\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] exchange(::Array{Int64,1}, ::Array{Int64,1}) at /tmp/tmpp4falv21.jl:15\n\
    \   [2] top-level scope at /tmp/tmpp4falv21.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp4falv21.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     7      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp4falv21.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3481lr67.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3481lr67.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3481lr67.jl:21\ntest set: Test Failed at /tmp/tmp3481lr67.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3481lr67.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3481lr67.jl:21\ntest set: Test Failed at /tmp/tmp3481lr67.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3481lr67.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3481lr67.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3481lr67.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmprha3h2dn.jl:27\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprha3h2dn.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprha3h2dn.jl:26\ntest set: Test Failed at /tmp/tmprha3h2dn.jl:29\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmprha3h2dn.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprha3h2dn.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprha3h2dn.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp56gy45hg.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp56gy45hg.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56gy45hg.jl:21\ntest set: Test Failed at /tmp/tmp56gy45hg.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp56gy45hg.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56gy45hg.jl:21\ntest set: Test Failed at /tmp/tmp56gy45hg.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp56gy45hg.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56gy45hg.jl:21\ntest set: Test Failed at /tmp/tmp56gy45hg.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp56gy45hg.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56gy45hg.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp56gy45hg.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm6xpazn7.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm6xpazn7.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm6xpazn7.jl:21\ntest set: Test Failed at /tmp/tmpm6xpazn7.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpm6xpazn7.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm6xpazn7.jl:21\ntest set: Test Failed at /tmp/tmpm6xpazn7.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpm6xpazn7.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm6xpazn7.jl:21\ntest set: Test Failed at /tmp/tmpm6xpazn7.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpm6xpazn7.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm6xpazn7.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm6xpazn7.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    if all(mod.(lst1, 2) .== 0)\n        return\
    \ \"YES\"\n    elseif all(mod.(lst2, 2) .== 0)\n        return \"YES\"\n    else\n\
    \        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4,\
    \ 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5,\
    \ 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5,\
    \ 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpdjf5a3s1.jl:27\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdjf5a3s1.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdjf5a3s1.jl:26\ntest set: Test Failed at /tmp/tmpdjf5a3s1.jl:29\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpdjf5a3s1.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdjf5a3s1.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdjf5a3s1.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy_uqnwed.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy_uqnwed.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy_uqnwed.jl:21\ntest set: Test Failed at /tmp/tmpy_uqnwed.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy_uqnwed.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy_uqnwed.jl:21\ntest set: Test Failed at /tmp/tmpy_uqnwed.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy_uqnwed.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy_uqnwed.jl:21\ntest set: Test Failed at /tmp/tmpy_uqnwed.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy_uqnwed.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy_uqnwed.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy_uqnwed.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    if all(mod.(lst1, 2)\
    \ .== 0)\n        return \"YES\"\n    end\n    for i in 1:length(lst1)\n     \
    \   if mod(lst1[i], 2) != 0\n            for j in 1:length(lst2)\n           \
    \     if mod(lst2[j], 2) == 0\n                    lst1[i], lst2[j] = lst2[j],\
    \ lst1[i]\n                    break\n                end\n            end\n \
    \       end\n    end\n    if all(mod.(lst1, 2) .== 0)\n        return \"YES\"\n\
    \    else\n        return \"NO\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\
    )\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1,\
    \ 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4])\
    \ == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3,\
    \ 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200],\
    \ [200, 200]) == \"YES\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # YOUR CODE HERE\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptqf_01jm.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptqf_01jm.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqf_01jm.jl:21\ntest set: Test Failed at /tmp/tmptqf_01jm.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmptqf_01jm.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqf_01jm.jl:21\ntest set: Test Failed at /tmp/tmptqf_01jm.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmptqf_01jm.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqf_01jm.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptqf_01jm.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4c0y0p58.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4c0y0p58.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4c0y0p58.jl:21\ntest set: Test Failed at /tmp/tmp4c0y0p58.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4c0y0p58.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4c0y0p58.jl:21\ntest set: Test Failed at /tmp/tmp4c0y0p58.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4c0y0p58.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4c0y0p58.jl:21\ntest set: Test Failed at /tmp/tmp4c0y0p58.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4c0y0p58.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4c0y0p58.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4c0y0p58.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # Your code here\n    return \"NO\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvmfk8akz.jl:22\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n   Evaluated: \"NO\" == \"YES\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvmfk8akz.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvmfk8akz.jl:21\ntest set: Test Failed at /tmp/tmpvmfk8akz.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\"\n   Evaluated:\
    \ \"NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvmfk8akz.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvmfk8akz.jl:21\ntest set: Test Failed at /tmp/tmpvmfk8akz.jl:25\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n   Evaluated: \"NO\"\
    \ == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvmfk8akz.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvmfk8akz.jl:21\ntest set: Test Failed at /tmp/tmpvmfk8akz.jl:28\n\
    \  Expression: candidate([100, 200], [200, 200]) == \"YES\"\n   Evaluated: \"\
    NO\" == \"YES\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvmfk8akz.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvmfk8akz.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     4      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvmfk8akz.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    and determines whether it is possible to perform an exchange\
    \ of elements\n    between them to make lst1 a list of only even numbers.\n  \
    \  There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    \    If it is possible to exchange elements between the lst1 and lst2 to make\n\
    \    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return\
    \ \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the\
    \ input lists will be non-empty.\n    \"\"\"\nfunction exchange(lst1::Vector{Int64},\
    \ lst2::Vector{Int64})::String \n    # your code here\n    return \"YES\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2,\
    \ 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3,\
    \ 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t\
    @test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3],\
    \ [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1,\
    \ 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps71h4e_r.jl:23\n  Expression: candidate([1,\
    \ 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n   Evaluated: \"YES\" == \"NO\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps71h4e_r.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps71h4e_r.jl:21\ntest set: Test Failed at /tmp/tmps71h4e_r.jl:26\n\
    \  Expression: candidate([5, 7, 3], [2, 6, 3]) == \"NO\"\n   Evaluated: \"YES\"\
    \ == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmps71h4e_r.jl:26\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps71h4e_r.jl:21\ntest set: Test Failed at /tmp/tmps71h4e_r.jl:27\n\
    \  Expression: candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n \
    \  Evaluated: \"YES\" == \"NO\"\nStacktrace:\n [1] top-level scope at /tmp/tmps71h4e_r.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps71h4e_r.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps71h4e_r.jl:19\n"
  exit_code: 1
  status: SyntaxError
