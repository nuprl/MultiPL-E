name: HumanEval_68_pluck
language: julia
results:
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for (i,\
    \ x) in enumerate(arr)\n        if x % 2 == 0\n            push!(evens, [x, i])\n\
    \        end\n    end\n    if isempty(evens)\n        return []\n    end\n   \
    \ return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgcqu1rli.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpgcqu1rli.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgcqu1rli.jl:53\ntest set: Test Failed at /tmp/tmpgcqu1rli.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgcqu1rli.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgcqu1rli.jl:53\ntest set: Test Failed at /tmp/tmpgcqu1rli.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpgcqu1rli.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgcqu1rli.jl:53\ntest set: Test Failed at /tmp/tmpgcqu1rli.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpgcqu1rli.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgcqu1rli.jl:53\ntest set: Test Failed at /tmp/tmpgcqu1rli.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpgcqu1rli.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgcqu1rli.jl:53\ntest set: Test Failed at /tmp/tmpgcqu1rli.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpgcqu1rli.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgcqu1rli.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgcqu1rli.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ arr[i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    min_even = minimum(even_nums)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even\n            return [min_even, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp77ukq56v.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp77ukq56v.jl:59\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp77ukq56v.jl:58\ntest set: Test Failed at /tmp/tmp77ukq56v.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp77ukq56v.jl:60\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp77ukq56v.jl:58\ntest set: Test Failed at /tmp/tmp77ukq56v.jl:62\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp77ukq56v.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp77ukq56v.jl:58\ntest set: Test Failed at /tmp/tmp77ukq56v.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp77ukq56v.jl:63\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp77ukq56v.jl:58\ntest set: Test Failed at /tmp/tmp77ukq56v.jl:64\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp77ukq56v.jl:64\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp77ukq56v.jl:58\ntest set: Test Failed at /tmp/tmp77ukq56v.jl:65\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp77ukq56v.jl:65\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp77ukq56v.jl:58\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp77ukq56v.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_idx = findall(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_idx)\n        return []\n    end\n\
    \    even_vals = arr[even_idx]\n    min_val = minimum(even_vals)\n    min_idx\
    \ = findfirst(x -> x == min_val, even_vals)\n    return [min_val, even_idx[min_idx]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp46lal0lz.jl:52\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp46lal0lz.jl:52\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp46lal0lz.jl:51\\ntest set: Test Failed at /tmp/tmp46lal0lz.jl:53\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp46lal0lz.jl:53\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp46lal0lz.jl:51\\ntest set: Test Failed at /tmp/tmp46lal0lz.jl:55\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp46lal0lz.jl:55\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp46lal0lz.jl:51\\ntest set: Test Failed at /tmp/tmp46lal0lz.jl:56\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp46lal0lz.jl:56\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp46lal0lz.jl:51\\ntest set: Test Failed at /tmp/tmp46lal0lz.jl:57\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp46lal0lz.jl:57\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp46lal0lz.jl:51\\ntest set: Test Failed at /tmp/tmp46lal0lz.jl:58\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp46lal0lz.jl:58\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp46lal0lz.jl:51\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = Inf\n    min_even_index\
    \ = 0\n    for (i, v) in enumerate(arr)\n        if v % 2 == 0 && v < min_even\n\
    \            min_even = v\n            min_even_index = i\n        end\n    end\n\
    \    if min_even == Inf\n        return []\n    end\n    return [min_even, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8rtdsphz.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp8rtdsphz.jl:56\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8rtdsphz.jl:55\ntest set: Test Failed at /tmp/tmp8rtdsphz.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8rtdsphz.jl:57\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8rtdsphz.jl:55\ntest set: Test Failed at /tmp/tmp8rtdsphz.jl:59\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp8rtdsphz.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8rtdsphz.jl:55\ntest set: Test Failed at /tmp/tmp8rtdsphz.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp8rtdsphz.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8rtdsphz.jl:55\ntest set: Test Failed at /tmp/tmp8rtdsphz.jl:61\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp8rtdsphz.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8rtdsphz.jl:55\ntest set: Test Failed at /tmp/tmp8rtdsphz.jl:62\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp8rtdsphz.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8rtdsphz.jl:55\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8rtdsphz.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8i_s8don.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp8i_s8don.jl:43\\\
    n   [2] top-level scope at /tmp/tmp8i_s8don.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i_s8don.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i_s8don.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp8i_s8don.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp8i_s8don.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i_s8don.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i_s8don.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp8i_s8don.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp8i_s8don.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i_s8don.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i_s8don.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp8i_s8don.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp8i_s8don.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i_s8don.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i_s8don.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp8i_s8don.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp8i_s8don.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i_s8don.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8i_s8don.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp8i_s8don.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp8i_s8don.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8i_s8don.jl:50\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1ukwbs9p.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp1ukwbs9p.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp1ukwbs9p.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ukwbs9p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1ukwbs9p.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1ukwbs9p.jl:43\n   [2] top-level scope at /tmp/tmp1ukwbs9p.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ukwbs9p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1ukwbs9p.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1ukwbs9p.jl:43\n   [2] top-level scope at /tmp/tmp1ukwbs9p.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ukwbs9p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1ukwbs9p.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1ukwbs9p.jl:43\n   [2] top-level scope at /tmp/tmp1ukwbs9p.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ukwbs9p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1ukwbs9p.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1ukwbs9p.jl:43\n   [2] top-level scope at /tmp/tmp1ukwbs9p.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ukwbs9p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1ukwbs9p.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1ukwbs9p.jl:43\n   [2] top-level scope at /tmp/tmp1ukwbs9p.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ukwbs9p.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1ukwbs9p.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    smallest_even = minimum(even_nodes)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpoiwrqqco.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpoiwrqqco.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpoiwrqqco.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoiwrqqco.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpoiwrqqco.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpoiwrqqco.jl:43\n   [2] top-level scope at /tmp/tmpoiwrqqco.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoiwrqqco.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpoiwrqqco.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpoiwrqqco.jl:43\n   [2] top-level scope at /tmp/tmpoiwrqqco.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoiwrqqco.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpoiwrqqco.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpoiwrqqco.jl:43\n   [2] top-level scope at /tmp/tmpoiwrqqco.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoiwrqqco.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpoiwrqqco.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpoiwrqqco.jl:43\n   [2] top-level scope at /tmp/tmpoiwrqqco.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoiwrqqco.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpoiwrqqco.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpoiwrqqco.jl:43\n   [2] top-level scope at /tmp/tmpoiwrqqco.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoiwrqqco.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoiwrqqco.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = [x for\
    \ x in arr if x % 2 == 0]\n    if isempty(even_values)\n        return []\n  \
    \  end\n    smallest_even = minimum(even_values)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpc05x87rd.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpc05x87rd.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpc05x87rd.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc05x87rd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpc05x87rd.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpc05x87rd.jl:43\n   [2] top-level scope at /tmp/tmpc05x87rd.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc05x87rd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpc05x87rd.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpc05x87rd.jl:43\n   [2] top-level scope at /tmp/tmpc05x87rd.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc05x87rd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpc05x87rd.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpc05x87rd.jl:43\n   [2] top-level scope at /tmp/tmpc05x87rd.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc05x87rd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpc05x87rd.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpc05x87rd.jl:43\n   [2] top-level scope at /tmp/tmpc05x87rd.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc05x87rd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpc05x87rd.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpc05x87rd.jl:43\n   [2] top-level scope at /tmp/tmpc05x87rd.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc05x87rd.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc05x87rd.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for (i, node) in enumerate(arr)\n        if node % 2 == 0\n            push!(even_nodes,\
    \ [node, i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    return sort!(even_nodes)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmps5mbjpon.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmps5mbjpon.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps5mbjpon.jl:53\ntest set: Test Failed at /tmp/tmps5mbjpon.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmps5mbjpon.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps5mbjpon.jl:53\ntest set: Test Failed at /tmp/tmps5mbjpon.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmps5mbjpon.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps5mbjpon.jl:53\ntest set: Test Failed at /tmp/tmps5mbjpon.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmps5mbjpon.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps5mbjpon.jl:53\ntest set: Test Failed at /tmp/tmps5mbjpon.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmps5mbjpon.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps5mbjpon.jl:53\ntest set: Test Failed at /tmp/tmps5mbjpon.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmps5mbjpon.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps5mbjpon.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps5mbjpon.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpim85dhkv.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpim85dhkv.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim85dhkv.jl:42\ntest set: Test Failed at /tmp/tmpim85dhkv.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpim85dhkv.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim85dhkv.jl:42\ntest set: Test Failed at /tmp/tmpim85dhkv.jl:46\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: Int64[]\
    \ == [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpim85dhkv.jl:46\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim85dhkv.jl:42\ntest set: Test Failed at /tmp/tmpim85dhkv.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpim85dhkv.jl:47\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim85dhkv.jl:42\ntest set: Test Failed at /tmp/tmpim85dhkv.jl:48\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: Int64[] ==\
    \ [4, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpim85dhkv.jl:48\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim85dhkv.jl:42\ntest set: Test Failed at /tmp/tmpim85dhkv.jl:49\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: Int64[] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpim85dhkv.jl:49\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim85dhkv.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpim85dhkv.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    smallest_even = minimum(evens)\n    smallest_index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, smallest_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpbr25xlc4.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpbr25xlc4.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpbr25xlc4.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbr25xlc4.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbr25xlc4.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbr25xlc4.jl:43\n   [2] top-level scope at /tmp/tmpbr25xlc4.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbr25xlc4.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbr25xlc4.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbr25xlc4.jl:43\n   [2] top-level scope at /tmp/tmpbr25xlc4.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbr25xlc4.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbr25xlc4.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbr25xlc4.jl:43\n   [2] top-level scope at /tmp/tmpbr25xlc4.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbr25xlc4.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbr25xlc4.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbr25xlc4.jl:43\n   [2] top-level scope at /tmp/tmpbr25xlc4.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbr25xlc4.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbr25xlc4.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbr25xlc4.jl:43\n   [2] top-level scope at /tmp/tmpbr25xlc4.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbr25xlc4.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbr25xlc4.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgyk9qboy.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpgyk9qboy.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgyk9qboy.jl:46\ntest set: Test Failed at /tmp/tmpgyk9qboy.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgyk9qboy.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgyk9qboy.jl:46\ntest set: Test Failed at /tmp/tmpgyk9qboy.jl:50\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpgyk9qboy.jl:50\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgyk9qboy.jl:46\ntest set: Test Failed at /tmp/tmpgyk9qboy.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpgyk9qboy.jl:51\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgyk9qboy.jl:46\ntest set: Test Failed at /tmp/tmpgyk9qboy.jl:52\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpgyk9qboy.jl:52\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgyk9qboy.jl:46\ntest set: Test Failed at /tmp/tmpgyk9qboy.jl:53\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpgyk9qboy.jl:53\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgyk9qboy.jl:46\ntest set: Error During Test at\
    \ /tmp/tmpgyk9qboy.jl:54\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  ArgumentError: reducing over an empty collection\
    \ is not allowed\n  Stacktrace:\n   [1] _empty_reduce_error() at ./reduce.jl:295\n\
    \   [2] reduce_empty(::Function, ::Type{T} where T) at ./reduce.jl:305\n   [3]\
    \ mapreduce_empty(::typeof(identity), ::Function, ::Type{T} where T) at ./reduce.jl:335\n\
    \   [4] _mapreduce at ./reduce.jl:392 [inlined]\n   [5] _mapreduce_dim at ./reducedim.jl:312\
    \ [inlined]\n   [6] #mapreduce#580 at ./reducedim.jl:307 [inlined]\n   [7] mapreduce\
    \ at ./reducedim.jl:307 [inlined]\n   [8] _minimum at ./reducedim.jl:657 [inlined]\n\
    \   [9] _minimum at ./reducedim.jl:656 [inlined]\n   [10] #minimum#589 at ./reducedim.jl:652\
    \ [inlined]\n   [11] minimum at ./reducedim.jl:652 [inlined]\n   [12] pluck(::Array{Int64,1})\
    \ at /tmp/tmpgyk9qboy.jl:38\n   [13] top-level scope at /tmp/tmpgyk9qboy.jl:54\n\
    \   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [15] top-level scope at /tmp/tmpgyk9qboy.jl:46\n  \nTest Summary: | Pass \
    \ Fail  Error  Total\ntest set      |    1     6      1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgyk9qboy.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Base case\n    if length(arr) == 0\n        return []\n    end\n   \
    \ \n    # Find the smallest even value\n    evens = filter(x -> x % 2 == 0, arr)\n\
    \    if length(evens) == 0\n        return []\n    end\n    min_even = minimum(evens)\n\
    \    \n    # Find the index of the smallest even value\n    min_even_index = findfirst(arr,\
    \ min_even)\n    \n    return [min_even, min_even_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfpo8erhz.jl:57\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpfpo8erhz.jl:48\\\
    n   [2] top-level scope at /tmp/tmpfpo8erhz.jl:57\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfpo8erhz.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfpo8erhz.jl:58\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfpo8erhz.jl:48\\n   [2] top-level scope\
    \ at /tmp/tmpfpo8erhz.jl:58\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfpo8erhz.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfpo8erhz.jl:60\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfpo8erhz.jl:48\\n   [2] top-level scope\
    \ at /tmp/tmpfpo8erhz.jl:60\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfpo8erhz.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfpo8erhz.jl:61\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfpo8erhz.jl:48\\n   [2] top-level scope\
    \ at /tmp/tmpfpo8erhz.jl:61\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfpo8erhz.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfpo8erhz.jl:62\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfpo8erhz.jl:48\\n   [2] top-level scope\
    \ at /tmp/tmpfpo8erhz.jl:62\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfpo8erhz.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfpo8erhz.jl:63\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfpo8erhz.jl:48\\n   [2] top-level scope\
    \ at /tmp/tmpfpo8erhz.jl:63\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfpo8erhz.jl:56\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp82urw9s5.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp82urw9s5.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp82urw9s5.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp82urw9s5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp82urw9s5.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp82urw9s5.jl:43\n   [2] top-level scope at /tmp/tmp82urw9s5.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp82urw9s5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp82urw9s5.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp82urw9s5.jl:43\n   [2] top-level scope at /tmp/tmp82urw9s5.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp82urw9s5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp82urw9s5.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp82urw9s5.jl:43\n   [2] top-level scope at /tmp/tmp82urw9s5.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp82urw9s5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp82urw9s5.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp82urw9s5.jl:43\n   [2] top-level scope at /tmp/tmp82urw9s5.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp82urw9s5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp82urw9s5.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp82urw9s5.jl:43\n   [2] top-level scope at /tmp/tmp82urw9s5.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp82urw9s5.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp82urw9s5.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_index = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0\n            if arr[i] < min_even\n                min_even = arr[i]\n   \
    \             min_even_index = i\n            end\n        end\n    end\n    if\
    \ min_even_index == -1\n        return []\n    end\n    return [min_even, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpoq04mp5b.jl:58\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpoq04mp5b.jl:58\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoq04mp5b.jl:57\\ntest set: Test Failed at /tmp/tmpoq04mp5b.jl:59\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpoq04mp5b.jl:59\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoq04mp5b.jl:57\\ntest set: Test Failed at /tmp/tmpoq04mp5b.jl:61\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpoq04mp5b.jl:61\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoq04mp5b.jl:57\\ntest set: Test Failed at /tmp/tmpoq04mp5b.jl:62\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpoq04mp5b.jl:62\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoq04mp5b.jl:57\\ntest set: Test Failed at /tmp/tmpoq04mp5b.jl:63\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpoq04mp5b.jl:63\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoq04mp5b.jl:57\\ntest set: Test Failed at /tmp/tmpoq04mp5b.jl:64\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpoq04mp5b.jl:64\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoq04mp5b.jl:57\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmprt87lqzm.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmprt87lqzm.jl:36\\\
    n   [2] top-level scope at /tmp/tmprt87lqzm.jl:42\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprt87lqzm.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprt87lqzm.jl:43\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmprt87lqzm.jl:36\\\
    n   [2] top-level scope at /tmp/tmprt87lqzm.jl:43\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprt87lqzm.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprt87lqzm.jl:44\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmprt87lqzm.jl:36\\\
    n   [2] top-level scope at /tmp/tmprt87lqzm.jl:44\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprt87lqzm.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprt87lqzm.jl:45\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmprt87lqzm.jl:36\\\
    n   [2] top-level scope at /tmp/tmprt87lqzm.jl:45\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprt87lqzm.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprt87lqzm.jl:46\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmprt87lqzm.jl:36\\\
    n   [2] top-level scope at /tmp/tmprt87lqzm.jl:46\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprt87lqzm.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprt87lqzm.jl:47\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmprt87lqzm.jl:36\\\
    n   [2] top-level scope at /tmp/tmprt87lqzm.jl:47\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprt87lqzm.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprt87lqzm.jl:48\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmprt87lqzm.jl:36\\\
    n   [2] top-level scope at /tmp/tmprt87lqzm.jl:48\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprt87lqzm.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprt87lqzm.jl:49\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmprt87lqzm.jl:36\\\
    n   [2] top-level scope at /tmp/tmprt87lqzm.jl:49\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprt87lqzm.jl:41\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     8      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(even_values,\
    \ [v, i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    sort!(even_values, by = x -> x[1])\n    return even_values[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmphgryoc_q.jl:55\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmphgryoc_q.jl:55\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphgryoc_q.jl:54\\ntest set: Test Failed at /tmp/tmphgryoc_q.jl:56\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmphgryoc_q.jl:56\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphgryoc_q.jl:54\\ntest set: Test Failed at /tmp/tmphgryoc_q.jl:58\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmphgryoc_q.jl:58\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphgryoc_q.jl:54\\ntest set: Test Failed at /tmp/tmphgryoc_q.jl:59\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmphgryoc_q.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphgryoc_q.jl:54\\ntest set: Test Failed at /tmp/tmphgryoc_q.jl:60\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmphgryoc_q.jl:60\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphgryoc_q.jl:54\\ntest set: Test Failed at /tmp/tmphgryoc_q.jl:61\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmphgryoc_q.jl:61\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphgryoc_q.jl:54\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpg1h3_r1l.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpg1h3_r1l.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpg1h3_r1l.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg1h3_r1l.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg1h3_r1l.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg1h3_r1l.jl:43\n   [2] top-level scope at /tmp/tmpg1h3_r1l.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg1h3_r1l.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg1h3_r1l.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg1h3_r1l.jl:43\n   [2] top-level scope at /tmp/tmpg1h3_r1l.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg1h3_r1l.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg1h3_r1l.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg1h3_r1l.jl:43\n   [2] top-level scope at /tmp/tmpg1h3_r1l.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg1h3_r1l.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg1h3_r1l.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg1h3_r1l.jl:43\n   [2] top-level scope at /tmp/tmpg1h3_r1l.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg1h3_r1l.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg1h3_r1l.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg1h3_r1l.jl:43\n   [2] top-level scope at /tmp/tmpg1h3_r1l.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg1h3_r1l.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg1h3_r1l.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: Implement me!\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp0v3xn335.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0v3xn335.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0v3xn335.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0v3xn335.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0v3xn335.jl:43\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0v3xn335.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0v3xn335.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0v3xn335.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0v3xn335.jl:44\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0v3xn335.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0v3xn335.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0v3xn335.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0v3xn335.jl:45\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0v3xn335.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0v3xn335.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0v3xn335.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0v3xn335.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0v3xn335.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0v3xn335.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0v3xn335.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0v3xn335.jl:47\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0v3xn335.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0v3xn335.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0v3xn335.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0v3xn335.jl:48\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0v3xn335.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0v3xn335.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0v3xn335.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0v3xn335.jl:49\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0v3xn335.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0v3xn335.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0v3xn335.jl:41\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0v3xn335.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxa2_5mdu.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpxa2_5mdu.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpxa2_5mdu.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxa2_5mdu.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxa2_5mdu.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxa2_5mdu.jl:43\n   [2] top-level scope at /tmp/tmpxa2_5mdu.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxa2_5mdu.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxa2_5mdu.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxa2_5mdu.jl:43\n   [2] top-level scope at /tmp/tmpxa2_5mdu.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxa2_5mdu.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxa2_5mdu.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxa2_5mdu.jl:43\n   [2] top-level scope at /tmp/tmpxa2_5mdu.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxa2_5mdu.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxa2_5mdu.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxa2_5mdu.jl:43\n   [2] top-level scope at /tmp/tmpxa2_5mdu.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxa2_5mdu.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxa2_5mdu.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxa2_5mdu.jl:43\n   [2] top-level scope at /tmp/tmpxa2_5mdu.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxa2_5mdu.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxa2_5mdu.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    smallest_even = minimum(even_nodes)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmy9fwafl.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpmy9fwafl.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpmy9fwafl.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmy9fwafl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmy9fwafl.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmy9fwafl.jl:43\n   [2] top-level scope at /tmp/tmpmy9fwafl.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmy9fwafl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmy9fwafl.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmy9fwafl.jl:43\n   [2] top-level scope at /tmp/tmpmy9fwafl.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmy9fwafl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmy9fwafl.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmy9fwafl.jl:43\n   [2] top-level scope at /tmp/tmpmy9fwafl.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmy9fwafl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmy9fwafl.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmy9fwafl.jl:43\n   [2] top-level scope at /tmp/tmpmy9fwafl.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmy9fwafl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmy9fwafl.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmy9fwafl.jl:43\n   [2] top-level scope at /tmp/tmpmy9fwafl.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmy9fwafl.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmy9fwafl.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmbsomkca.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpmbsomkca.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpmbsomkca.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmbsomkca.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmbsomkca.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmbsomkca.jl:43\n   [2] top-level scope at /tmp/tmpmbsomkca.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmbsomkca.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmbsomkca.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmbsomkca.jl:43\n   [2] top-level scope at /tmp/tmpmbsomkca.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmbsomkca.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmbsomkca.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmbsomkca.jl:43\n   [2] top-level scope at /tmp/tmpmbsomkca.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmbsomkca.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmbsomkca.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmbsomkca.jl:43\n   [2] top-level scope at /tmp/tmpmbsomkca.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmbsomkca.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpmbsomkca.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmbsomkca.jl:43\n   [2] top-level scope at /tmp/tmpmbsomkca.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmbsomkca.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmbsomkca.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    evens = sort(evens)\n    evens[1]\n    return [evens[1], findfirst(arr, evens[1])]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwqx5rlpv.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpwqx5rlpv.jl:44\n   [2] top-level scope at\
    \ /tmp/tmpwqx5rlpv.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwqx5rlpv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwqx5rlpv.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwqx5rlpv.jl:44\n   [2] top-level scope at /tmp/tmpwqx5rlpv.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwqx5rlpv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwqx5rlpv.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwqx5rlpv.jl:44\n   [2] top-level scope at /tmp/tmpwqx5rlpv.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwqx5rlpv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwqx5rlpv.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwqx5rlpv.jl:44\n   [2] top-level scope at /tmp/tmpwqx5rlpv.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwqx5rlpv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwqx5rlpv.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwqx5rlpv.jl:44\n   [2] top-level scope at /tmp/tmpwqx5rlpv.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwqx5rlpv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwqx5rlpv.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwqx5rlpv.jl:44\n   [2] top-level scope at /tmp/tmpwqx5rlpv.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwqx5rlpv.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwqx5rlpv.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp48cry1o7.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp48cry1o7.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp48cry1o7.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp48cry1o7.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp48cry1o7.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp48cry1o7.jl:43\n   [2] top-level scope at /tmp/tmp48cry1o7.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp48cry1o7.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp48cry1o7.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp48cry1o7.jl:43\n   [2] top-level scope at /tmp/tmp48cry1o7.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp48cry1o7.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp48cry1o7.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp48cry1o7.jl:43\n   [2] top-level scope at /tmp/tmp48cry1o7.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp48cry1o7.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp48cry1o7.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp48cry1o7.jl:43\n   [2] top-level scope at /tmp/tmp48cry1o7.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp48cry1o7.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp48cry1o7.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp48cry1o7.jl:43\n   [2] top-level scope at /tmp/tmp48cry1o7.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp48cry1o7.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp48cry1o7.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7nt5bcoi.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp7nt5bcoi.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7nt5bcoi.jl:54\ntest set: Test Failed at /tmp/tmp7nt5bcoi.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7nt5bcoi.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7nt5bcoi.jl:54\ntest set: Test Failed at /tmp/tmp7nt5bcoi.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp7nt5bcoi.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7nt5bcoi.jl:54\ntest set: Test Failed at /tmp/tmp7nt5bcoi.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp7nt5bcoi.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7nt5bcoi.jl:54\ntest set: Test Failed at /tmp/tmp7nt5bcoi.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp7nt5bcoi.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7nt5bcoi.jl:54\ntest set: Test Failed at /tmp/tmp7nt5bcoi.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp7nt5bcoi.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7nt5bcoi.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7nt5bcoi.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpts20k8b1.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpts20k8b1.jl:36\n\
    \   [2] top-level scope at /tmp/tmpts20k8b1.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpts20k8b1.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpts20k8b1.jl:43\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpts20k8b1.jl:36\n\
    \   [2] top-level scope at /tmp/tmpts20k8b1.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpts20k8b1.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpts20k8b1.jl:44\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpts20k8b1.jl:36\n\
    \   [2] top-level scope at /tmp/tmpts20k8b1.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpts20k8b1.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpts20k8b1.jl:45\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpts20k8b1.jl:36\n\
    \   [2] top-level scope at /tmp/tmpts20k8b1.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpts20k8b1.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpts20k8b1.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpts20k8b1.jl:36\n\
    \   [2] top-level scope at /tmp/tmpts20k8b1.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpts20k8b1.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpts20k8b1.jl:47\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpts20k8b1.jl:36\n\
    \   [2] top-level scope at /tmp/tmpts20k8b1.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpts20k8b1.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpts20k8b1.jl:48\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpts20k8b1.jl:36\n\
    \   [2] top-level scope at /tmp/tmpts20k8b1.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpts20k8b1.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpts20k8b1.jl:49\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpts20k8b1.jl:36\n\
    \   [2] top-level scope at /tmp/tmpts20k8b1.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpts20k8b1.jl:41\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpts20k8b1.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpknosx644.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpknosx644.jl:43\\\
    n   [2] top-level scope at /tmp/tmpknosx644.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpknosx644.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpknosx644.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpknosx644.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpknosx644.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpknosx644.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpknosx644.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpknosx644.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpknosx644.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpknosx644.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpknosx644.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpknosx644.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpknosx644.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpknosx644.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpknosx644.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpknosx644.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpknosx644.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpknosx644.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpknosx644.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpknosx644.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpknosx644.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpknosx644.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmphryzc7hi.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmphryzc7hi.jl:43\n   [2] top-level scope at\
    \ /tmp/tmphryzc7hi.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphryzc7hi.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphryzc7hi.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphryzc7hi.jl:43\n   [2] top-level scope at /tmp/tmphryzc7hi.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphryzc7hi.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphryzc7hi.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphryzc7hi.jl:43\n   [2] top-level scope at /tmp/tmphryzc7hi.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphryzc7hi.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphryzc7hi.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphryzc7hi.jl:43\n   [2] top-level scope at /tmp/tmphryzc7hi.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphryzc7hi.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphryzc7hi.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphryzc7hi.jl:43\n   [2] top-level scope at /tmp/tmphryzc7hi.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphryzc7hi.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphryzc7hi.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphryzc7hi.jl:43\n   [2] top-level scope at /tmp/tmphryzc7hi.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphryzc7hi.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphryzc7hi.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphc2uvvwh.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmphc2uvvwh.jl:43\n   [2] top-level scope at\
    \ /tmp/tmphc2uvvwh.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphc2uvvwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphc2uvvwh.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphc2uvvwh.jl:43\n   [2] top-level scope at /tmp/tmphc2uvvwh.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphc2uvvwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphc2uvvwh.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphc2uvvwh.jl:43\n   [2] top-level scope at /tmp/tmphc2uvvwh.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphc2uvvwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphc2uvvwh.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphc2uvvwh.jl:43\n   [2] top-level scope at /tmp/tmphc2uvvwh.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphc2uvvwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphc2uvvwh.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphc2uvvwh.jl:43\n   [2] top-level scope at /tmp/tmphc2uvvwh.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphc2uvvwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphc2uvvwh.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphc2uvvwh.jl:43\n   [2] top-level scope at /tmp/tmphc2uvvwh.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphc2uvvwh.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphc2uvvwh.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp7hme3nnx.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp7hme3nnx.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7hme3nnx.jl:42\ntest set: Test Failed at /tmp/tmp7hme3nnx.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7hme3nnx.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7hme3nnx.jl:42\ntest set: Test Failed at /tmp/tmp7hme3nnx.jl:46\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: Int64[]\
    \ == [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp7hme3nnx.jl:46\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7hme3nnx.jl:42\ntest set: Test Failed at /tmp/tmp7hme3nnx.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp7hme3nnx.jl:47\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7hme3nnx.jl:42\ntest set: Test Failed at /tmp/tmp7hme3nnx.jl:48\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: Int64[] ==\
    \ [4, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp7hme3nnx.jl:48\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7hme3nnx.jl:42\ntest set: Test Failed at /tmp/tmp7hme3nnx.jl:49\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: Int64[] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp7hme3nnx.jl:49\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7hme3nnx.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7hme3nnx.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpdbbcltas.jl:59\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpdbbcltas.jl:59\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdbbcltas.jl:58\\ntest set: Test Failed at /tmp/tmpdbbcltas.jl:60\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpdbbcltas.jl:60\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdbbcltas.jl:58\\ntest set: Test Failed at /tmp/tmpdbbcltas.jl:62\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdbbcltas.jl:62\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdbbcltas.jl:58\\ntest set: Test Failed at /tmp/tmpdbbcltas.jl:63\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdbbcltas.jl:63\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdbbcltas.jl:58\\ntest set: Test Failed at /tmp/tmpdbbcltas.jl:64\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdbbcltas.jl:64\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdbbcltas.jl:58\\ntest set: Test Failed at /tmp/tmpdbbcltas.jl:65\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdbbcltas.jl:65\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdbbcltas.jl:58\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpkmd0dmwj.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpkmd0dmwj.jl:43\\\
    n   [2] top-level scope at /tmp/tmpkmd0dmwj.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpkmd0dmwj.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpkmd0dmwj.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpkmd0dmwj.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpkmd0dmwj.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpkmd0dmwj.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpkmd0dmwj.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpkmd0dmwj.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpkmd0dmwj.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpkmd0dmwj.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpkmd0dmwj.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpkmd0dmwj.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpkmd0dmwj.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpkmd0dmwj.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpkmd0dmwj.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpkmd0dmwj.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpkmd0dmwj.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpkmd0dmwj.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpkmd0dmwj.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpkmd0dmwj.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpkmd0dmwj.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpkmd0dmwj.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwwwuma42.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpwwwuma42.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpwwwuma42.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwwwuma42.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpwwwuma42.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwwwuma42.jl:43\n   [2] top-level scope at /tmp/tmpwwwuma42.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwwwuma42.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpwwwuma42.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwwwuma42.jl:43\n   [2] top-level scope at /tmp/tmpwwwuma42.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwwwuma42.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpwwwuma42.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwwwuma42.jl:43\n   [2] top-level scope at /tmp/tmpwwwuma42.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwwwuma42.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpwwwuma42.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwwwuma42.jl:43\n   [2] top-level scope at /tmp/tmpwwwuma42.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwwwuma42.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpwwwuma42.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwwwuma42.jl:43\n   [2] top-level scope at /tmp/tmpwwwuma42.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwwwuma42.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwwwuma42.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    return [min_even, findfirst(arr,\
    \ min_even)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcaut8hxg.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpcaut8hxg.jl:40\n   [2] top-level scope at\
    \ /tmp/tmpcaut8hxg.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcaut8hxg.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpcaut8hxg.jl:48\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcaut8hxg.jl:40\n   [2] top-level scope at /tmp/tmpcaut8hxg.jl:48\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcaut8hxg.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpcaut8hxg.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcaut8hxg.jl:40\n   [2] top-level scope at /tmp/tmpcaut8hxg.jl:50\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcaut8hxg.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpcaut8hxg.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcaut8hxg.jl:40\n   [2] top-level scope at /tmp/tmpcaut8hxg.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcaut8hxg.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpcaut8hxg.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcaut8hxg.jl:40\n   [2] top-level scope at /tmp/tmpcaut8hxg.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcaut8hxg.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpcaut8hxg.jl:53\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcaut8hxg.jl:40\n   [2] top-level scope at /tmp/tmpcaut8hxg.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcaut8hxg.jl:46\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcaut8hxg.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    return minimum(evens)\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmp90my2_.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpmp90my2_.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmp90my2_.jl:53\ntest set: Test Failed at /tmp/tmpmp90my2_.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmp90my2_.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmp90my2_.jl:53\ntest set: Test Failed at /tmp/tmpmp90my2_.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpmp90my2_.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmp90my2_.jl:53\ntest set: Test Failed at /tmp/tmpmp90my2_.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpmp90my2_.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmp90my2_.jl:53\ntest set: Test Failed at /tmp/tmpmp90my2_.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpmp90my2_.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmp90my2_.jl:53\ntest set: Test Failed at /tmp/tmpmp90my2_.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpmp90my2_.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmp90my2_.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmp90my2_.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp6gscei2g.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp6gscei2g.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp6gscei2g.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6gscei2g.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp6gscei2g.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6gscei2g.jl:43\n   [2] top-level scope at /tmp/tmp6gscei2g.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6gscei2g.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp6gscei2g.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6gscei2g.jl:43\n   [2] top-level scope at /tmp/tmp6gscei2g.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6gscei2g.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp6gscei2g.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6gscei2g.jl:43\n   [2] top-level scope at /tmp/tmp6gscei2g.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6gscei2g.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp6gscei2g.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6gscei2g.jl:43\n   [2] top-level scope at /tmp/tmp6gscei2g.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6gscei2g.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp6gscei2g.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6gscei2g.jl:43\n   [2] top-level scope at /tmp/tmp6gscei2g.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6gscei2g.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6gscei2g.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2yos8zz9.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2yos8zz9.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2yos8zz9.jl:54\ntest set: Test Failed at /tmp/tmp2yos8zz9.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp2yos8zz9.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2yos8zz9.jl:54\ntest set: Test Failed at /tmp/tmp2yos8zz9.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp2yos8zz9.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2yos8zz9.jl:54\ntest set: Test Failed at /tmp/tmp2yos8zz9.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp2yos8zz9.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2yos8zz9.jl:54\ntest set: Test Failed at /tmp/tmp2yos8zz9.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp2yos8zz9.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2yos8zz9.jl:54\ntest set: Test Failed at /tmp/tmp2yos8zz9.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp2yos8zz9.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2yos8zz9.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2yos8zz9.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8xbh37a6.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp8xbh37a6.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp8xbh37a6.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8xbh37a6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8xbh37a6.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8xbh37a6.jl:43\n   [2] top-level scope at /tmp/tmp8xbh37a6.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8xbh37a6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8xbh37a6.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8xbh37a6.jl:43\n   [2] top-level scope at /tmp/tmp8xbh37a6.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8xbh37a6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8xbh37a6.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8xbh37a6.jl:43\n   [2] top-level scope at /tmp/tmp8xbh37a6.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8xbh37a6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8xbh37a6.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8xbh37a6.jl:43\n   [2] top-level scope at /tmp/tmp8xbh37a6.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8xbh37a6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8xbh37a6.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8xbh37a6.jl:43\n   [2] top-level scope at /tmp/tmp8xbh37a6.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8xbh37a6.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8xbh37a6.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_index = findfirst(arr, min_even)\n   \
    \ return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpxnl34lm_.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpxnl34lm_.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpxnl34lm_.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnl34lm_.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnl34lm_.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxnl34lm_.jl:43\n   [2] top-level scope at /tmp/tmpxnl34lm_.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnl34lm_.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnl34lm_.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxnl34lm_.jl:43\n   [2] top-level scope at /tmp/tmpxnl34lm_.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnl34lm_.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnl34lm_.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxnl34lm_.jl:43\n   [2] top-level scope at /tmp/tmpxnl34lm_.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnl34lm_.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnl34lm_.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxnl34lm_.jl:43\n   [2] top-level scope at /tmp/tmpxnl34lm_.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnl34lm_.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnl34lm_.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxnl34lm_.jl:43\n   [2] top-level scope at /tmp/tmpxnl34lm_.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnl34lm_.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxnl34lm_.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    evens\
    \ = sort(evens)\n    evens = evens[1]\n    return [evens, findfirst(arr, evens)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5vpomh5u.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp5vpomh5u.jl:44\n   [2] top-level scope at\
    \ /tmp/tmp5vpomh5u.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5vpomh5u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5vpomh5u.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5vpomh5u.jl:44\n   [2] top-level scope at /tmp/tmp5vpomh5u.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5vpomh5u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5vpomh5u.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5vpomh5u.jl:44\n   [2] top-level scope at /tmp/tmp5vpomh5u.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5vpomh5u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5vpomh5u.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5vpomh5u.jl:44\n   [2] top-level scope at /tmp/tmp5vpomh5u.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5vpomh5u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5vpomh5u.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5vpomh5u.jl:44\n   [2] top-level scope at /tmp/tmp5vpomh5u.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5vpomh5u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5vpomh5u.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5vpomh5u.jl:44\n   [2] top-level scope at /tmp/tmp5vpomh5u.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5vpomh5u.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5vpomh5u.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsp63v616.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpsp63v616.jl:36\n\
    \   [2] top-level scope at /tmp/tmpsp63v616.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsp63v616.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpsp63v616.jl:43\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpsp63v616.jl:36\n\
    \   [2] top-level scope at /tmp/tmpsp63v616.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsp63v616.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpsp63v616.jl:44\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpsp63v616.jl:36\n\
    \   [2] top-level scope at /tmp/tmpsp63v616.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsp63v616.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpsp63v616.jl:45\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpsp63v616.jl:36\n\
    \   [2] top-level scope at /tmp/tmpsp63v616.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsp63v616.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpsp63v616.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpsp63v616.jl:36\n\
    \   [2] top-level scope at /tmp/tmpsp63v616.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsp63v616.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpsp63v616.jl:47\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpsp63v616.jl:36\n\
    \   [2] top-level scope at /tmp/tmpsp63v616.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsp63v616.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpsp63v616.jl:48\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpsp63v616.jl:36\n\
    \   [2] top-level scope at /tmp/tmpsp63v616.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsp63v616.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpsp63v616.jl:49\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpsp63v616.jl:36\n\
    \   [2] top-level scope at /tmp/tmpsp63v616.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsp63v616.jl:41\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsp63v616.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeb9ch_su.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpeb9ch_su.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeb9ch_su.jl:54\ntest set: Test Failed at /tmp/tmpeb9ch_su.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeb9ch_su.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeb9ch_su.jl:54\ntest set: Test Failed at /tmp/tmpeb9ch_su.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpeb9ch_su.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeb9ch_su.jl:54\ntest set: Test Failed at /tmp/tmpeb9ch_su.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpeb9ch_su.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeb9ch_su.jl:54\ntest set: Test Failed at /tmp/tmpeb9ch_su.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpeb9ch_su.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeb9ch_su.jl:54\ntest set: Test Failed at /tmp/tmpeb9ch_su.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpeb9ch_su.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeb9ch_su.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeb9ch_su.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    sorted_even_nums = sort(even_nums, by = x -> x[1])\n    return\
    \ sorted_even_nums[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpxpg87131.jl:55\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpxpg87131.jl:55\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxpg87131.jl:54\\ntest set: Test Failed at /tmp/tmpxpg87131.jl:56\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpxpg87131.jl:56\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxpg87131.jl:54\\ntest set: Test Failed at /tmp/tmpxpg87131.jl:58\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxpg87131.jl:58\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxpg87131.jl:54\\ntest set: Test Failed at /tmp/tmpxpg87131.jl:59\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxpg87131.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxpg87131.jl:54\\ntest set: Test Failed at /tmp/tmpxpg87131.jl:60\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxpg87131.jl:60\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxpg87131.jl:54\\ntest set: Test Failed at /tmp/tmpxpg87131.jl:61\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxpg87131.jl:61\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxpg87131.jl:54\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpm0r9up5x.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpm0r9up5x.jl:43\\\
    n   [2] top-level scope at /tmp/tmpm0r9up5x.jl:50\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm0r9up5x.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm0r9up5x.jl:51\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpm0r9up5x.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpm0r9up5x.jl:51\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm0r9up5x.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm0r9up5x.jl:53\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpm0r9up5x.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpm0r9up5x.jl:53\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm0r9up5x.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm0r9up5x.jl:54\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpm0r9up5x.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpm0r9up5x.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm0r9up5x.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm0r9up5x.jl:55\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpm0r9up5x.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpm0r9up5x.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm0r9up5x.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpm0r9up5x.jl:56\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpm0r9up5x.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpm0r9up5x.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpm0r9up5x.jl:49\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpuma9tewm.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpuma9tewm.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpuma9tewm.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuma9tewm.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuma9tewm.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuma9tewm.jl:43\n   [2] top-level scope at /tmp/tmpuma9tewm.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuma9tewm.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuma9tewm.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuma9tewm.jl:43\n   [2] top-level scope at /tmp/tmpuma9tewm.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuma9tewm.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuma9tewm.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuma9tewm.jl:43\n   [2] top-level scope at /tmp/tmpuma9tewm.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuma9tewm.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuma9tewm.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuma9tewm.jl:43\n   [2] top-level scope at /tmp/tmpuma9tewm.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuma9tewm.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuma9tewm.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuma9tewm.jl:43\n   [2] top-level scope at /tmp/tmpuma9tewm.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuma9tewm.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuma9tewm.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj2018r6c.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpj2018r6c.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpj2018r6c.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2018r6c.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj2018r6c.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj2018r6c.jl:43\n   [2] top-level scope at /tmp/tmpj2018r6c.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2018r6c.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj2018r6c.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj2018r6c.jl:43\n   [2] top-level scope at /tmp/tmpj2018r6c.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2018r6c.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj2018r6c.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj2018r6c.jl:43\n   [2] top-level scope at /tmp/tmpj2018r6c.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2018r6c.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj2018r6c.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj2018r6c.jl:43\n   [2] top-level scope at /tmp/tmpj2018r6c.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2018r6c.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj2018r6c.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj2018r6c.jl:43\n   [2] top-level scope at /tmp/tmpj2018r6c.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2018r6c.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj2018r6c.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    return sort!(even_nodes)[1]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpffuiamv2.jl:54\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpffuiamv2.jl:54\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpffuiamv2.jl:53\\ntest set: Test Failed at /tmp/tmpffuiamv2.jl:55\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpffuiamv2.jl:55\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpffuiamv2.jl:53\\ntest set: Test Failed at /tmp/tmpffuiamv2.jl:57\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpffuiamv2.jl:57\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpffuiamv2.jl:53\\ntest set: Test Failed at /tmp/tmpffuiamv2.jl:58\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpffuiamv2.jl:58\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpffuiamv2.jl:53\\ntest set: Test Failed at /tmp/tmpffuiamv2.jl:59\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpffuiamv2.jl:59\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpffuiamv2.jl:53\\ntest set: Test Failed at /tmp/tmpffuiamv2.jl:60\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpffuiamv2.jl:60\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpffuiamv2.jl:53\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmps2alt5_1.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmps2alt5_1.jl:43\n   [2] top-level scope at\
    \ /tmp/tmps2alt5_1.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps2alt5_1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps2alt5_1.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps2alt5_1.jl:43\n   [2] top-level scope at /tmp/tmps2alt5_1.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps2alt5_1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps2alt5_1.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps2alt5_1.jl:43\n   [2] top-level scope at /tmp/tmps2alt5_1.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps2alt5_1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps2alt5_1.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps2alt5_1.jl:43\n   [2] top-level scope at /tmp/tmps2alt5_1.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps2alt5_1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps2alt5_1.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps2alt5_1.jl:43\n   [2] top-level scope at /tmp/tmps2alt5_1.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps2alt5_1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps2alt5_1.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps2alt5_1.jl:43\n   [2] top-level scope at /tmp/tmps2alt5_1.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps2alt5_1.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps2alt5_1.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [i for i\
    \ in arr if i % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmppy9lt892.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmppy9lt892.jl:43\n   [2] top-level scope at\
    \ /tmp/tmppy9lt892.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppy9lt892.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppy9lt892.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppy9lt892.jl:43\n   [2] top-level scope at /tmp/tmppy9lt892.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppy9lt892.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppy9lt892.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppy9lt892.jl:43\n   [2] top-level scope at /tmp/tmppy9lt892.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppy9lt892.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppy9lt892.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppy9lt892.jl:43\n   [2] top-level scope at /tmp/tmppy9lt892.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppy9lt892.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppy9lt892.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppy9lt892.jl:43\n   [2] top-level scope at /tmp/tmppy9lt892.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppy9lt892.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppy9lt892.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppy9lt892.jl:43\n   [2] top-level scope at /tmp/tmppy9lt892.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppy9lt892.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppy9lt892.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpdoul91rq.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpdoul91rq.jl:36\\\
    n   [2] top-level scope at /tmp/tmpdoul91rq.jl:42\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdoul91rq.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdoul91rq.jl:43\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpdoul91rq.jl:36\\\
    n   [2] top-level scope at /tmp/tmpdoul91rq.jl:43\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdoul91rq.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdoul91rq.jl:44\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpdoul91rq.jl:36\\\
    n   [2] top-level scope at /tmp/tmpdoul91rq.jl:44\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdoul91rq.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdoul91rq.jl:45\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpdoul91rq.jl:36\\\
    n   [2] top-level scope at /tmp/tmpdoul91rq.jl:45\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdoul91rq.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdoul91rq.jl:46\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpdoul91rq.jl:36\\\
    n   [2] top-level scope at /tmp/tmpdoul91rq.jl:46\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdoul91rq.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdoul91rq.jl:47\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpdoul91rq.jl:36\\\
    n   [2] top-level scope at /tmp/tmpdoul91rq.jl:47\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdoul91rq.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdoul91rq.jl:48\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpdoul91rq.jl:36\\\
    n   [2] top-level scope at /tmp/tmpdoul91rq.jl:48\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdoul91rq.jl:41\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdoul91rq.jl:49\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpdoul91rq.jl:36\\\
    n   [2] top-level scope at /tmp/tmpdoul91rq.jl:49\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdoul91rq.jl:41\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     8      8\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_index = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0\n            if arr[i] < min_even\n                min_even = arr[i]\n   \
    \             min_even_index = i\n            end\n        end\n    end\n    if\
    \ min_even_index == -1\n        return []\n    end\n    return [min_even, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpku2lib2o.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpku2lib2o.jl:58\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpku2lib2o.jl:57\ntest set: Test Failed at /tmp/tmpku2lib2o.jl:59\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpku2lib2o.jl:59\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpku2lib2o.jl:57\ntest set: Test Failed at /tmp/tmpku2lib2o.jl:61\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpku2lib2o.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpku2lib2o.jl:57\ntest set: Test Failed at /tmp/tmpku2lib2o.jl:62\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpku2lib2o.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpku2lib2o.jl:57\ntest set: Test Failed at /tmp/tmpku2lib2o.jl:63\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpku2lib2o.jl:63\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpku2lib2o.jl:57\ntest set: Test Failed at /tmp/tmpku2lib2o.jl:64\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpku2lib2o.jl:64\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpku2lib2o.jl:57\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpku2lib2o.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_idx = findall(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_idx)\n        return []\n    end\n\
    \    min_even = minimum(arr[even_idx])\n    min_even_idx = findall(x -> x == min_even,\
    \ arr)\n    return [min_even, min_even_idx[1]]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpwzcqr2e3.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwzcqr2e3.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwzcqr2e3.jl:50\ntest set: Test Failed at /tmp/tmpwzcqr2e3.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwzcqr2e3.jl:52\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwzcqr2e3.jl:50\ntest set: Test Failed at /tmp/tmpwzcqr2e3.jl:54\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpwzcqr2e3.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwzcqr2e3.jl:50\ntest set: Test Failed at /tmp/tmpwzcqr2e3.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpwzcqr2e3.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwzcqr2e3.jl:50\ntest set: Test Failed at /tmp/tmpwzcqr2e3.jl:56\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpwzcqr2e3.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwzcqr2e3.jl:50\ntest set: Test Failed at /tmp/tmpwzcqr2e3.jl:57\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpwzcqr2e3.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwzcqr2e3.jl:50\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwzcqr2e3.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nums)\n        return\
    \ []\n    end\n    even_nums = sort(even_nums, by = x -> x[1])\n    return even_nums[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4cbvel9l.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4cbvel9l.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4cbvel9l.jl:54\ntest set: Test Failed at /tmp/tmp4cbvel9l.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4cbvel9l.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4cbvel9l.jl:54\ntest set: Test Failed at /tmp/tmp4cbvel9l.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4cbvel9l.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4cbvel9l.jl:54\ntest set: Test Failed at /tmp/tmp4cbvel9l.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp4cbvel9l.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4cbvel9l.jl:54\ntest set: Test Failed at /tmp/tmp4cbvel9l.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4cbvel9l.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4cbvel9l.jl:54\ntest set: Test Failed at /tmp/tmp4cbvel9l.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4cbvel9l.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4cbvel9l.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4cbvel9l.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [node for\
    \ node in arr if node % 2 == 0]\n    if isempty(even_nodes)\n        return []\n\
    \    end\n    min_even_node = minimum(even_nodes)\n    min_even_node_idx = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_idx]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpdp85wgm3.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpdp85wgm3.jl:43\\\
    n   [2] top-level scope at /tmp/tmpdp85wgm3.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdp85wgm3.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdp85wgm3.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpdp85wgm3.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpdp85wgm3.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdp85wgm3.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdp85wgm3.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpdp85wgm3.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpdp85wgm3.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdp85wgm3.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdp85wgm3.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpdp85wgm3.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpdp85wgm3.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdp85wgm3.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdp85wgm3.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpdp85wgm3.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpdp85wgm3.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdp85wgm3.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpdp85wgm3.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpdp85wgm3.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpdp85wgm3.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpdp85wgm3.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpl13nhfk2.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpl13nhfk2.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpl13nhfk2.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl13nhfk2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpl13nhfk2.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpl13nhfk2.jl:43\n   [2] top-level scope at /tmp/tmpl13nhfk2.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl13nhfk2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpl13nhfk2.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpl13nhfk2.jl:43\n   [2] top-level scope at /tmp/tmpl13nhfk2.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl13nhfk2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpl13nhfk2.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpl13nhfk2.jl:43\n   [2] top-level scope at /tmp/tmpl13nhfk2.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl13nhfk2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpl13nhfk2.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpl13nhfk2.jl:43\n   [2] top-level scope at /tmp/tmpl13nhfk2.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl13nhfk2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpl13nhfk2.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpl13nhfk2.jl:43\n   [2] top-level scope at /tmp/tmpl13nhfk2.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl13nhfk2.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl13nhfk2.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_even_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even_value\n            return [min_even_value, i]\n\
    \        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_fo5djwa.jl:59\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp_fo5djwa.jl:59\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_fo5djwa.jl:58\\ntest set: Test Failed at /tmp/tmp_fo5djwa.jl:60\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_fo5djwa.jl:60\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_fo5djwa.jl:58\\ntest set: Test Failed at /tmp/tmp_fo5djwa.jl:62\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_fo5djwa.jl:62\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_fo5djwa.jl:58\\ntest set: Test Failed at /tmp/tmp_fo5djwa.jl:63\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_fo5djwa.jl:63\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_fo5djwa.jl:58\\ntest set: Test Failed at /tmp/tmp_fo5djwa.jl:64\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_fo5djwa.jl:64\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_fo5djwa.jl:58\\ntest set: Test Failed at /tmp/tmp_fo5djwa.jl:65\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_fo5djwa.jl:65\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_fo5djwa.jl:58\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgfpa_77y.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpgfpa_77y.jl:43\\\
    n   [2] top-level scope at /tmp/tmpgfpa_77y.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgfpa_77y.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpgfpa_77y.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpgfpa_77y.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpgfpa_77y.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgfpa_77y.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpgfpa_77y.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpgfpa_77y.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpgfpa_77y.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgfpa_77y.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpgfpa_77y.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpgfpa_77y.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpgfpa_77y.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgfpa_77y.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpgfpa_77y.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpgfpa_77y.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpgfpa_77y.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgfpa_77y.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpgfpa_77y.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpgfpa_77y.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpgfpa_77y.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgfpa_77y.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfpxqhd2u.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpfpxqhd2u.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpfpxqhd2u.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfpxqhd2u.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpfpxqhd2u.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfpxqhd2u.jl:43\n   [2] top-level scope at /tmp/tmpfpxqhd2u.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfpxqhd2u.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpfpxqhd2u.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfpxqhd2u.jl:43\n   [2] top-level scope at /tmp/tmpfpxqhd2u.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfpxqhd2u.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpfpxqhd2u.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfpxqhd2u.jl:43\n   [2] top-level scope at /tmp/tmpfpxqhd2u.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfpxqhd2u.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpfpxqhd2u.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfpxqhd2u.jl:43\n   [2] top-level scope at /tmp/tmpfpxqhd2u.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfpxqhd2u.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpfpxqhd2u.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfpxqhd2u.jl:43\n   [2] top-level scope at /tmp/tmpfpxqhd2u.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfpxqhd2u.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfpxqhd2u.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_8yimbf5.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp_8yimbf5.jl:43\\\
    n   [2] top-level scope at /tmp/tmp_8yimbf5.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_8yimbf5.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_8yimbf5.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_8yimbf5.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp_8yimbf5.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_8yimbf5.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_8yimbf5.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_8yimbf5.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp_8yimbf5.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_8yimbf5.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_8yimbf5.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_8yimbf5.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp_8yimbf5.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_8yimbf5.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_8yimbf5.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_8yimbf5.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp_8yimbf5.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_8yimbf5.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_8yimbf5.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_8yimbf5.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp_8yimbf5.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_8yimbf5.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: Write your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpcmck_65u.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpcmck_65u.jl:36\n\
    \   [2] top-level scope at /tmp/tmpcmck_65u.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcmck_65u.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpcmck_65u.jl:43\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpcmck_65u.jl:36\n\
    \   [2] top-level scope at /tmp/tmpcmck_65u.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcmck_65u.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpcmck_65u.jl:44\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpcmck_65u.jl:36\n\
    \   [2] top-level scope at /tmp/tmpcmck_65u.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcmck_65u.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpcmck_65u.jl:45\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpcmck_65u.jl:36\n\
    \   [2] top-level scope at /tmp/tmpcmck_65u.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcmck_65u.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpcmck_65u.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpcmck_65u.jl:36\n\
    \   [2] top-level scope at /tmp/tmpcmck_65u.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcmck_65u.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpcmck_65u.jl:47\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpcmck_65u.jl:36\n\
    \   [2] top-level scope at /tmp/tmpcmck_65u.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcmck_65u.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpcmck_65u.jl:48\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpcmck_65u.jl:36\n\
    \   [2] top-level scope at /tmp/tmpcmck_65u.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcmck_65u.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpcmck_65u.jl:49\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpcmck_65u.jl:36\n\
    \   [2] top-level scope at /tmp/tmpcmck_65u.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcmck_65u.jl:41\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcmck_65u.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqfkhs4wg.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpqfkhs4wg.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpqfkhs4wg.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqfkhs4wg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqfkhs4wg.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqfkhs4wg.jl:43\n   [2] top-level scope at /tmp/tmpqfkhs4wg.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqfkhs4wg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqfkhs4wg.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqfkhs4wg.jl:43\n   [2] top-level scope at /tmp/tmpqfkhs4wg.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqfkhs4wg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqfkhs4wg.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqfkhs4wg.jl:43\n   [2] top-level scope at /tmp/tmpqfkhs4wg.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqfkhs4wg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqfkhs4wg.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqfkhs4wg.jl:43\n   [2] top-level scope at /tmp/tmpqfkhs4wg.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqfkhs4wg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqfkhs4wg.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqfkhs4wg.jl:43\n   [2] top-level scope at /tmp/tmpqfkhs4wg.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqfkhs4wg.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqfkhs4wg.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpb2b856as.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpb2b856as.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpb2b856as.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb2b856as.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpb2b856as.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpb2b856as.jl:43\n   [2] top-level scope at /tmp/tmpb2b856as.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb2b856as.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpb2b856as.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpb2b856as.jl:43\n   [2] top-level scope at /tmp/tmpb2b856as.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb2b856as.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpb2b856as.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpb2b856as.jl:43\n   [2] top-level scope at /tmp/tmpb2b856as.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb2b856as.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpb2b856as.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpb2b856as.jl:43\n   [2] top-level scope at /tmp/tmpb2b856as.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb2b856as.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpb2b856as.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpb2b856as.jl:43\n   [2] top-level scope at /tmp/tmpb2b856as.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb2b856as.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb2b856as.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxjd1jgij.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpxjd1jgij.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpxjd1jgij.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxjd1jgij.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxjd1jgij.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxjd1jgij.jl:43\n   [2] top-level scope at /tmp/tmpxjd1jgij.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxjd1jgij.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxjd1jgij.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxjd1jgij.jl:43\n   [2] top-level scope at /tmp/tmpxjd1jgij.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxjd1jgij.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxjd1jgij.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxjd1jgij.jl:43\n   [2] top-level scope at /tmp/tmpxjd1jgij.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxjd1jgij.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxjd1jgij.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxjd1jgij.jl:43\n   [2] top-level scope at /tmp/tmpxjd1jgij.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxjd1jgij.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxjd1jgij.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxjd1jgij.jl:43\n   [2] top-level scope at /tmp/tmpxjd1jgij.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxjd1jgij.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxjd1jgij.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzx5slmwy.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpzx5slmwy.jl:43\\\
    n   [2] top-level scope at /tmp/tmpzx5slmwy.jl:50\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzx5slmwy.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzx5slmwy.jl:51\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpzx5slmwy.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpzx5slmwy.jl:51\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzx5slmwy.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzx5slmwy.jl:53\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpzx5slmwy.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpzx5slmwy.jl:53\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzx5slmwy.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzx5slmwy.jl:54\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpzx5slmwy.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpzx5slmwy.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzx5slmwy.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzx5slmwy.jl:55\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpzx5slmwy.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpzx5slmwy.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzx5slmwy.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzx5slmwy.jl:56\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpzx5slmwy.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpzx5slmwy.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzx5slmwy.jl:49\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_idx = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n\
    \            if arr[i] < min_even\n                min_even = arr[i]\n       \
    \         min_even_idx = i\n            end\n        end\n    end\n    if min_even_idx\
    \ == -1\n        return []\n    end\n    return [min_even, min_even_idx]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpsufmd54d.jl:58\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpsufmd54d.jl:58\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsufmd54d.jl:57\\ntest set: Test Failed at /tmp/tmpsufmd54d.jl:59\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpsufmd54d.jl:59\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsufmd54d.jl:57\\ntest set: Test Failed at /tmp/tmpsufmd54d.jl:61\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsufmd54d.jl:61\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsufmd54d.jl:57\\ntest set: Test Failed at /tmp/tmpsufmd54d.jl:62\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsufmd54d.jl:62\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsufmd54d.jl:57\\ntest set: Test Failed at /tmp/tmpsufmd54d.jl:63\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsufmd54d.jl:63\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsufmd54d.jl:57\\ntest set: Test Failed at /tmp/tmpsufmd54d.jl:64\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsufmd54d.jl:64\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsufmd54d.jl:57\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_idx = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\
    \ && arr[i] < min_even\n            min_even = arr[i]\n            min_even_idx\
    \ = i\n        end\n    end\n    if min_even_idx == -1\n        return []\n  \
    \  end\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpdd0rghux.jl:56\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpdd0rghux.jl:56\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdd0rghux.jl:55\\ntest set: Test Failed at /tmp/tmpdd0rghux.jl:57\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpdd0rghux.jl:57\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdd0rghux.jl:55\\ntest set: Test Failed at /tmp/tmpdd0rghux.jl:59\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdd0rghux.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdd0rghux.jl:55\\ntest set: Test Failed at /tmp/tmpdd0rghux.jl:60\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdd0rghux.jl:60\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdd0rghux.jl:55\\ntest set: Test Failed at /tmp/tmpdd0rghux.jl:61\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdd0rghux.jl:61\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdd0rghux.jl:55\\ntest set: Test Failed at /tmp/tmpdd0rghux.jl:62\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdd0rghux.jl:62\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdd0rghux.jl:55\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmps_pdxx4b.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmps_pdxx4b.jl:43\n   [2] top-level scope at\
    \ /tmp/tmps_pdxx4b.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps_pdxx4b.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps_pdxx4b.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps_pdxx4b.jl:43\n   [2] top-level scope at /tmp/tmps_pdxx4b.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps_pdxx4b.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps_pdxx4b.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps_pdxx4b.jl:43\n   [2] top-level scope at /tmp/tmps_pdxx4b.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps_pdxx4b.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps_pdxx4b.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps_pdxx4b.jl:43\n   [2] top-level scope at /tmp/tmps_pdxx4b.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps_pdxx4b.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps_pdxx4b.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps_pdxx4b.jl:43\n   [2] top-level scope at /tmp/tmps_pdxx4b.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps_pdxx4b.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmps_pdxx4b.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmps_pdxx4b.jl:43\n   [2] top-level scope at /tmp/tmps_pdxx4b.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmps_pdxx4b.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps_pdxx4b.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxj2ury5z.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpxj2ury5z.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpxj2ury5z.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxj2ury5z.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxj2ury5z.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxj2ury5z.jl:43\n   [2] top-level scope at /tmp/tmpxj2ury5z.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxj2ury5z.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxj2ury5z.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxj2ury5z.jl:43\n   [2] top-level scope at /tmp/tmpxj2ury5z.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxj2ury5z.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxj2ury5z.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxj2ury5z.jl:43\n   [2] top-level scope at /tmp/tmpxj2ury5z.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxj2ury5z.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxj2ury5z.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxj2ury5z.jl:43\n   [2] top-level scope at /tmp/tmpxj2ury5z.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxj2ury5z.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxj2ury5z.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxj2ury5z.jl:43\n   [2] top-level scope at /tmp/tmpxj2ury5z.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxj2ury5z.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxj2ury5z.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp6tuh44io.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp6tuh44io.jl:43\\\
    n   [2] top-level scope at /tmp/tmp6tuh44io.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tuh44io.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tuh44io.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp6tuh44io.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp6tuh44io.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tuh44io.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tuh44io.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp6tuh44io.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp6tuh44io.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tuh44io.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tuh44io.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp6tuh44io.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp6tuh44io.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tuh44io.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tuh44io.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp6tuh44io.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp6tuh44io.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tuh44io.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tuh44io.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp6tuh44io.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp6tuh44io.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tuh44io.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = []\n    for (index, value) in enumerate(arr)\n        if\
    \ value % 2 == 0\n            push!(even_values, [value, index])\n        end\n\
    \    end\n    if isempty(even_values)\n        return []\n    end\n    return\
    \ minimum(even_values)\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdolwgspx.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpdolwgspx.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdolwgspx.jl:50\ntest set: Test Failed at /tmp/tmpdolwgspx.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdolwgspx.jl:52\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdolwgspx.jl:50\ntest set: Test Failed at /tmp/tmpdolwgspx.jl:54\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdolwgspx.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdolwgspx.jl:50\ntest set: Test Failed at /tmp/tmpdolwgspx.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpdolwgspx.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdolwgspx.jl:50\ntest set: Test Failed at /tmp/tmpdolwgspx.jl:56\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdolwgspx.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdolwgspx.jl:50\ntest set: Test Failed at /tmp/tmpdolwgspx.jl:57\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdolwgspx.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdolwgspx.jl:50\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdolwgspx.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_even = minimum(even_nums)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp11t_rfgk.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp11t_rfgk.jl:43\\\
    n   [2] top-level scope at /tmp/tmp11t_rfgk.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp11t_rfgk.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp11t_rfgk.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp11t_rfgk.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp11t_rfgk.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp11t_rfgk.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp11t_rfgk.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp11t_rfgk.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp11t_rfgk.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp11t_rfgk.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp11t_rfgk.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp11t_rfgk.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp11t_rfgk.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp11t_rfgk.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp11t_rfgk.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp11t_rfgk.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp11t_rfgk.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp11t_rfgk.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp11t_rfgk.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp11t_rfgk.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp11t_rfgk.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp11t_rfgk.jl:50\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp84ovzi0j.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp84ovzi0j.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp84ovzi0j.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp84ovzi0j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp84ovzi0j.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp84ovzi0j.jl:43\n   [2] top-level scope at /tmp/tmp84ovzi0j.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp84ovzi0j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp84ovzi0j.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp84ovzi0j.jl:43\n   [2] top-level scope at /tmp/tmp84ovzi0j.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp84ovzi0j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp84ovzi0j.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp84ovzi0j.jl:43\n   [2] top-level scope at /tmp/tmp84ovzi0j.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp84ovzi0j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp84ovzi0j.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp84ovzi0j.jl:43\n   [2] top-level scope at /tmp/tmp84ovzi0j.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp84ovzi0j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp84ovzi0j.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp84ovzi0j.jl:43\n   [2] top-level scope at /tmp/tmp84ovzi0j.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp84ovzi0j.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp84ovzi0j.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4irajp21.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4irajp21.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4irajp21.jl:54\ntest set: Test Failed at /tmp/tmp4irajp21.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4irajp21.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4irajp21.jl:54\ntest set: Test Failed at /tmp/tmp4irajp21.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4irajp21.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4irajp21.jl:54\ntest set: Test Failed at /tmp/tmp4irajp21.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp4irajp21.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4irajp21.jl:54\ntest set: Test Failed at /tmp/tmp4irajp21.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4irajp21.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4irajp21.jl:54\ntest set: Test Failed at /tmp/tmp4irajp21.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4irajp21.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4irajp21.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4irajp21.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpjuk4zepm.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpjuk4zepm.jl:40\n   [2] top-level scope at\
    \ /tmp/tmpjuk4zepm.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjuk4zepm.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpjuk4zepm.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjuk4zepm.jl:40\n   [2] top-level scope at /tmp/tmpjuk4zepm.jl:49\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjuk4zepm.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpjuk4zepm.jl:51\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjuk4zepm.jl:40\n   [2] top-level scope at /tmp/tmpjuk4zepm.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjuk4zepm.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpjuk4zepm.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjuk4zepm.jl:40\n   [2] top-level scope at /tmp/tmpjuk4zepm.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjuk4zepm.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpjuk4zepm.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjuk4zepm.jl:40\n   [2] top-level scope at /tmp/tmpjuk4zepm.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjuk4zepm.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpjuk4zepm.jl:54\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjuk4zepm.jl:40\n   [2] top-level scope at /tmp/tmpjuk4zepm.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjuk4zepm.jl:47\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjuk4zepm.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr .== min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpog6a6o8x.jl:51\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpog6a6o8x.jl:51\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpog6a6o8x.jl:50\\ntest set: Test Failed at /tmp/tmpog6a6o8x.jl:52\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpog6a6o8x.jl:52\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpog6a6o8x.jl:50\\ntest set: Test Failed at /tmp/tmpog6a6o8x.jl:54\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpog6a6o8x.jl:54\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpog6a6o8x.jl:50\\ntest set: Test Failed at /tmp/tmpog6a6o8x.jl:55\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpog6a6o8x.jl:55\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpog6a6o8x.jl:50\\ntest set: Test Failed at /tmp/tmpog6a6o8x.jl:56\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpog6a6o8x.jl:56\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpog6a6o8x.jl:50\\ntest set: Test Failed at /tmp/tmpog6a6o8x.jl:57\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpog6a6o8x.jl:57\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpog6a6o8x.jl:50\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp7wqb5hhl.jl:51\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp7wqb5hhl.jl:51\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7wqb5hhl.jl:50\\ntest set: Test Failed at /tmp/tmp7wqb5hhl.jl:52\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp7wqb5hhl.jl:52\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7wqb5hhl.jl:50\\ntest set: Test Failed at /tmp/tmp7wqb5hhl.jl:54\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7wqb5hhl.jl:54\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7wqb5hhl.jl:50\\ntest set: Test Failed at /tmp/tmp7wqb5hhl.jl:55\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7wqb5hhl.jl:55\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7wqb5hhl.jl:50\\ntest set: Test Failed at /tmp/tmp7wqb5hhl.jl:56\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7wqb5hhl.jl:56\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7wqb5hhl.jl:50\\ntest set: Test Failed at /tmp/tmp7wqb5hhl.jl:57\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7wqb5hhl.jl:57\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7wqb5hhl.jl:50\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqrz8a4_f.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpqrz8a4_f.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpqrz8a4_f.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqrz8a4_f.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqrz8a4_f.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqrz8a4_f.jl:43\n   [2] top-level scope at /tmp/tmpqrz8a4_f.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqrz8a4_f.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqrz8a4_f.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqrz8a4_f.jl:43\n   [2] top-level scope at /tmp/tmpqrz8a4_f.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqrz8a4_f.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqrz8a4_f.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqrz8a4_f.jl:43\n   [2] top-level scope at /tmp/tmpqrz8a4_f.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqrz8a4_f.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqrz8a4_f.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqrz8a4_f.jl:43\n   [2] top-level scope at /tmp/tmpqrz8a4_f.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqrz8a4_f.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpqrz8a4_f.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpqrz8a4_f.jl:43\n   [2] top-level scope at /tmp/tmpqrz8a4_f.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqrz8a4_f.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqrz8a4_f.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpa5fvpgxx.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpa5fvpgxx.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa5fvpgxx.jl:50\ntest set: Test Failed at /tmp/tmpa5fvpgxx.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa5fvpgxx.jl:52\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa5fvpgxx.jl:50\ntest set: Test Failed at /tmp/tmpa5fvpgxx.jl:54\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpa5fvpgxx.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa5fvpgxx.jl:50\ntest set: Test Failed at /tmp/tmpa5fvpgxx.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpa5fvpgxx.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa5fvpgxx.jl:50\ntest set: Test Failed at /tmp/tmpa5fvpgxx.jl:56\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpa5fvpgxx.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa5fvpgxx.jl:50\ntest set: Test Failed at /tmp/tmpa5fvpgxx.jl:57\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpa5fvpgxx.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa5fvpgxx.jl:50\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa5fvpgxx.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvuovx8cp.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpvuovx8cp.jl:36\n\
    \   [2] top-level scope at /tmp/tmpvuovx8cp.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvuovx8cp.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpvuovx8cp.jl:43\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpvuovx8cp.jl:36\n\
    \   [2] top-level scope at /tmp/tmpvuovx8cp.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvuovx8cp.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpvuovx8cp.jl:44\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpvuovx8cp.jl:36\n\
    \   [2] top-level scope at /tmp/tmpvuovx8cp.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvuovx8cp.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpvuovx8cp.jl:45\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpvuovx8cp.jl:36\n\
    \   [2] top-level scope at /tmp/tmpvuovx8cp.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvuovx8cp.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpvuovx8cp.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpvuovx8cp.jl:36\n\
    \   [2] top-level scope at /tmp/tmpvuovx8cp.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvuovx8cp.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpvuovx8cp.jl:47\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpvuovx8cp.jl:36\n\
    \   [2] top-level scope at /tmp/tmpvuovx8cp.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvuovx8cp.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpvuovx8cp.jl:48\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpvuovx8cp.jl:36\n\
    \   [2] top-level scope at /tmp/tmpvuovx8cp.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvuovx8cp.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpvuovx8cp.jl:49\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpvuovx8cp.jl:36\n\
    \   [2] top-level scope at /tmp/tmpvuovx8cp.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvuovx8cp.jl:41\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvuovx8cp.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    \"Given an array representing a branch\
    \ of a tree that has non-negative integer nodes\n    your task is to pluck one\
    \ of the nodes and return it.\n    The plucked node should be the node with the\
    \ smallest even value.\n    If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpki3xjkh7.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpki3xjkh7.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpq8lj6oy0.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpq8lj6oy0.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpq8lj6oy0.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8lj6oy0.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8lj6oy0.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq8lj6oy0.jl:43\n   [2] top-level scope at /tmp/tmpq8lj6oy0.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8lj6oy0.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8lj6oy0.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq8lj6oy0.jl:43\n   [2] top-level scope at /tmp/tmpq8lj6oy0.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8lj6oy0.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8lj6oy0.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq8lj6oy0.jl:43\n   [2] top-level scope at /tmp/tmpq8lj6oy0.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8lj6oy0.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8lj6oy0.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq8lj6oy0.jl:43\n   [2] top-level scope at /tmp/tmpq8lj6oy0.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8lj6oy0.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8lj6oy0.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq8lj6oy0.jl:43\n   [2] top-level scope at /tmp/tmpq8lj6oy0.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8lj6oy0.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq8lj6oy0.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzywk0jwh.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzywk0jwh.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzywk0jwh.jl:54\ntest set: Test Failed at /tmp/tmpzywk0jwh.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzywk0jwh.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzywk0jwh.jl:54\ntest set: Test Failed at /tmp/tmpzywk0jwh.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzywk0jwh.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzywk0jwh.jl:54\ntest set: Test Failed at /tmp/tmpzywk0jwh.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpzywk0jwh.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzywk0jwh.jl:54\ntest set: Test Failed at /tmp/tmpzywk0jwh.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzywk0jwh.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzywk0jwh.jl:54\ntest set: Test Failed at /tmp/tmpzywk0jwh.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzywk0jwh.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzywk0jwh.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzywk0jwh.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_even = minimum(even_nums)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpeq0uf0pv.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpeq0uf0pv.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpeq0uf0pv.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeq0uf0pv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpeq0uf0pv.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpeq0uf0pv.jl:43\n   [2] top-level scope at /tmp/tmpeq0uf0pv.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeq0uf0pv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpeq0uf0pv.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpeq0uf0pv.jl:43\n   [2] top-level scope at /tmp/tmpeq0uf0pv.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeq0uf0pv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpeq0uf0pv.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpeq0uf0pv.jl:43\n   [2] top-level scope at /tmp/tmpeq0uf0pv.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeq0uf0pv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpeq0uf0pv.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpeq0uf0pv.jl:43\n   [2] top-level scope at /tmp/tmpeq0uf0pv.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeq0uf0pv.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpeq0uf0pv.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpeq0uf0pv.jl:43\n   [2] top-level scope at /tmp/tmpeq0uf0pv.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeq0uf0pv.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeq0uf0pv.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3jpz7txd.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp3jpz7txd.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp3jpz7txd.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3jpz7txd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp3jpz7txd.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3jpz7txd.jl:43\n   [2] top-level scope at /tmp/tmp3jpz7txd.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3jpz7txd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp3jpz7txd.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3jpz7txd.jl:43\n   [2] top-level scope at /tmp/tmp3jpz7txd.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3jpz7txd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp3jpz7txd.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3jpz7txd.jl:43\n   [2] top-level scope at /tmp/tmp3jpz7txd.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3jpz7txd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp3jpz7txd.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3jpz7txd.jl:43\n   [2] top-level scope at /tmp/tmp3jpz7txd.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3jpz7txd.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp3jpz7txd.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3jpz7txd.jl:43\n   [2] top-level scope at /tmp/tmp3jpz7txd.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3jpz7txd.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3jpz7txd.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_vals = []\n\
    \    even_inds = []\n    for (i, val) in enumerate(arr)\n        if val % 2 ==\
    \ 0\n            push!(even_vals, val)\n            push!(even_inds, i)\n    \
    \    end\n    end\n    if length(even_vals) == 0\n        return []\n    end\n\
    \    min_val = minimum(even_vals)\n    min_ind = even_inds[findfirst(even_vals,\
    \ min_val)]\n    return [min_val, min_ind]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp6ysvh2_9.jl:58\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Any,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp6ysvh2_9.jl:50\n   [2] top-level scope at\
    \ /tmp/tmp6ysvh2_9.jl:58\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ysvh2_9.jl:57\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ysvh2_9.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Any,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6ysvh2_9.jl:50\n   [2] top-level scope at /tmp/tmp6ysvh2_9.jl:59\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ysvh2_9.jl:57\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ysvh2_9.jl:61\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Any,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6ysvh2_9.jl:50\n   [2] top-level scope at /tmp/tmp6ysvh2_9.jl:61\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ysvh2_9.jl:57\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ysvh2_9.jl:62\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Any,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6ysvh2_9.jl:50\n   [2] top-level scope at /tmp/tmp6ysvh2_9.jl:62\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ysvh2_9.jl:57\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ysvh2_9.jl:63\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Any,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6ysvh2_9.jl:50\n   [2] top-level scope at /tmp/tmp6ysvh2_9.jl:63\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ysvh2_9.jl:57\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ysvh2_9.jl:64\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Any,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp6ysvh2_9.jl:50\n   [2] top-level scope at /tmp/tmp6ysvh2_9.jl:64\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ysvh2_9.jl:57\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ysvh2_9.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpuvw88wlq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpuvw88wlq.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpuvw88wlq.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuvw88wlq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuvw88wlq.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuvw88wlq.jl:43\n   [2] top-level scope at /tmp/tmpuvw88wlq.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuvw88wlq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuvw88wlq.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuvw88wlq.jl:43\n   [2] top-level scope at /tmp/tmpuvw88wlq.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuvw88wlq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuvw88wlq.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuvw88wlq.jl:43\n   [2] top-level scope at /tmp/tmpuvw88wlq.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuvw88wlq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuvw88wlq.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuvw88wlq.jl:43\n   [2] top-level scope at /tmp/tmpuvw88wlq.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuvw88wlq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpuvw88wlq.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpuvw88wlq.jl:43\n   [2] top-level scope at /tmp/tmpuvw88wlq.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuvw88wlq.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuvw88wlq.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    return [smallest_even, findfirst(arr, smallest_even)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg_p3q0ya.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpg_p3q0ya.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpg_p3q0ya.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg_p3q0ya.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpg_p3q0ya.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg_p3q0ya.jl:43\n   [2] top-level scope at /tmp/tmpg_p3q0ya.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg_p3q0ya.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpg_p3q0ya.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg_p3q0ya.jl:43\n   [2] top-level scope at /tmp/tmpg_p3q0ya.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg_p3q0ya.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpg_p3q0ya.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg_p3q0ya.jl:43\n   [2] top-level scope at /tmp/tmpg_p3q0ya.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg_p3q0ya.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpg_p3q0ya.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg_p3q0ya.jl:43\n   [2] top-level scope at /tmp/tmpg_p3q0ya.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg_p3q0ya.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpg_p3q0ya.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg_p3q0ya.jl:43\n   [2] top-level scope at /tmp/tmpg_p3q0ya.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg_p3q0ya.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg_p3q0ya.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if arr[i] % 2 == 0]\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_idx = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp27b7fn1l.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp27b7fn1l.jl:43\\\
    n   [2] top-level scope at /tmp/tmp27b7fn1l.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp27b7fn1l.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp27b7fn1l.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp27b7fn1l.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp27b7fn1l.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp27b7fn1l.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp27b7fn1l.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp27b7fn1l.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp27b7fn1l.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp27b7fn1l.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp27b7fn1l.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp27b7fn1l.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp27b7fn1l.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp27b7fn1l.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp27b7fn1l.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp27b7fn1l.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp27b7fn1l.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp27b7fn1l.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp27b7fn1l.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp27b7fn1l.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmp27b7fn1l.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp27b7fn1l.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmp27b7fn1l.jl:48\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpze9sbo8h.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpze9sbo8h.jl:36\n\
    \   [2] top-level scope at /tmp/tmpze9sbo8h.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpze9sbo8h.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpze9sbo8h.jl:43\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpze9sbo8h.jl:36\n\
    \   [2] top-level scope at /tmp/tmpze9sbo8h.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpze9sbo8h.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpze9sbo8h.jl:44\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpze9sbo8h.jl:36\n\
    \   [2] top-level scope at /tmp/tmpze9sbo8h.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpze9sbo8h.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpze9sbo8h.jl:45\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpze9sbo8h.jl:36\n\
    \   [2] top-level scope at /tmp/tmpze9sbo8h.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpze9sbo8h.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpze9sbo8h.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpze9sbo8h.jl:36\n\
    \   [2] top-level scope at /tmp/tmpze9sbo8h.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpze9sbo8h.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpze9sbo8h.jl:47\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpze9sbo8h.jl:36\n\
    \   [2] top-level scope at /tmp/tmpze9sbo8h.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpze9sbo8h.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpze9sbo8h.jl:48\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpze9sbo8h.jl:36\n\
    \   [2] top-level scope at /tmp/tmpze9sbo8h.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpze9sbo8h.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpze9sbo8h.jl:49\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpze9sbo8h.jl:36\n\
    \   [2] top-level scope at /tmp/tmpze9sbo8h.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpze9sbo8h.jl:41\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpze9sbo8h.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even_value = Inf\n\
    \    min_even_index = Inf\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0 && arr[i] < min_even_value\n            min_even_value = arr[i]\n        \
    \    min_even_index = i\n        end\n    end\n    if min_even_value == Inf\n\
    \        return []\n    end\n    return [min_even_value, min_even_index]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp9dw45xdu.jl:56\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp9dw45xdu.jl:56\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9dw45xdu.jl:55\\ntest set: Test Failed at /tmp/tmp9dw45xdu.jl:57\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9dw45xdu.jl:57\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9dw45xdu.jl:55\\ntest set: Test Failed at /tmp/tmp9dw45xdu.jl:59\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9dw45xdu.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9dw45xdu.jl:55\\ntest set: Test Failed at /tmp/tmp9dw45xdu.jl:60\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9dw45xdu.jl:60\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9dw45xdu.jl:55\\ntest set: Test Failed at /tmp/tmp9dw45xdu.jl:61\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9dw45xdu.jl:61\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9dw45xdu.jl:55\\ntest set: Test Failed at /tmp/tmp9dw45xdu.jl:62\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9dw45xdu.jl:62\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9dw45xdu.jl:55\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if min_even == Inf\n        return []\n    end\n \
    \   return [min_even, findfirst(arr, min_even)]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp3770u0c3.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp3770u0c3.jl:42\n   [2] top-level scope at\
    \ /tmp/tmp3770u0c3.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3770u0c3.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3770u0c3.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3770u0c3.jl:42\n   [2] top-level scope at /tmp/tmp3770u0c3.jl:50\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3770u0c3.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3770u0c3.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3770u0c3.jl:42\n   [2] top-level scope at /tmp/tmp3770u0c3.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3770u0c3.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3770u0c3.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3770u0c3.jl:42\n   [2] top-level scope at /tmp/tmp3770u0c3.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3770u0c3.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3770u0c3.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3770u0c3.jl:42\n   [2] top-level scope at /tmp/tmp3770u0c3.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3770u0c3.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3770u0c3.jl:55\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3770u0c3.jl:42\n   [2] top-level scope at /tmp/tmp3770u0c3.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3770u0c3.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3770u0c3.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  ArgumentError: reducing over an empty collection\
    \ is not allowed\n  Stacktrace:\n   [1] _empty_reduce_error() at ./reduce.jl:295\n\
    \   [2] reduce_empty(::Function, ::Type{T} where T) at ./reduce.jl:305\n   [3]\
    \ mapreduce_empty(::typeof(identity), ::Function, ::Type{T} where T) at ./reduce.jl:335\n\
    \   [4] _mapreduce at ./reduce.jl:392 [inlined]\n   [5] _mapreduce_dim at ./reducedim.jl:312\
    \ [inlined]\n   [6] #mapreduce#580 at ./reducedim.jl:307 [inlined]\n   [7] mapreduce\
    \ at ./reducedim.jl:307 [inlined]\n   [8] _minimum at ./reducedim.jl:657 [inlined]\n\
    \   [9] _minimum at ./reducedim.jl:656 [inlined]\n   [10] #minimum#589 at ./reducedim.jl:652\
    \ [inlined]\n   [11] minimum at ./reducedim.jl:652 [inlined]\n   [12] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3770u0c3.jl:38\n   [13] top-level scope at /tmp/tmp3770u0c3.jl:56\n\
    \   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [15] top-level scope at /tmp/tmp3770u0c3.jl:48\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      7      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3770u0c3.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    even_nums = sort(even_nums, by = x -> x[1])\n    return even_nums[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8fcsuw3y.jl:55\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp8fcsuw3y.jl:55\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fcsuw3y.jl:54\\ntest set: Test Failed at /tmp/tmp8fcsuw3y.jl:56\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8fcsuw3y.jl:56\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fcsuw3y.jl:54\\ntest set: Test Failed at /tmp/tmp8fcsuw3y.jl:58\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8fcsuw3y.jl:58\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fcsuw3y.jl:54\\ntest set: Test Failed at /tmp/tmp8fcsuw3y.jl:59\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8fcsuw3y.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fcsuw3y.jl:54\\ntest set: Test Failed at /tmp/tmp8fcsuw3y.jl:60\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8fcsuw3y.jl:60\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fcsuw3y.jl:54\\ntest set: Test Failed at /tmp/tmp8fcsuw3y.jl:61\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8fcsuw3y.jl:61\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fcsuw3y.jl:54\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i = 1:length(arr)\n        if arr[i] ==\
    \ min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxffnx5kt.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpxffnx5kt.jl:59\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxffnx5kt.jl:58\ntest set: Test Failed at /tmp/tmpxffnx5kt.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxffnx5kt.jl:60\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxffnx5kt.jl:58\ntest set: Test Failed at /tmp/tmpxffnx5kt.jl:62\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpxffnx5kt.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxffnx5kt.jl:58\ntest set: Test Failed at /tmp/tmpxffnx5kt.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpxffnx5kt.jl:63\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxffnx5kt.jl:58\ntest set: Test Failed at /tmp/tmpxffnx5kt.jl:64\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpxffnx5kt.jl:64\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxffnx5kt.jl:58\ntest set: Test Failed at /tmp/tmpxffnx5kt.jl:65\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpxffnx5kt.jl:65\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxffnx5kt.jl:58\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxffnx5kt.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    if length(arr) ==\
    \ 1\n        if arr[1] % 2 == 0\n            return [arr[1], 1]\n        else\n\
    \            return []\n        end\n    end\n    evens = []\n    for i in 1:length(arr)\n\
    \        if arr[i] % 2 == 0\n            push!(evens, [arr[i], i])\n        end\n\
    \    end\n    if length(evens) == 0\n        return []\n    end\n    evens = sort(evens,\
    \ by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmprbfnsrzh.jl:62\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmprbfnsrzh.jl:62\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprbfnsrzh.jl:61\ntest set: Test Failed at /tmp/tmprbfnsrzh.jl:63\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmprbfnsrzh.jl:63\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprbfnsrzh.jl:61\ntest set: Test Failed at /tmp/tmprbfnsrzh.jl:65\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmprbfnsrzh.jl:65\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprbfnsrzh.jl:61\ntest set: Test Failed at /tmp/tmprbfnsrzh.jl:66\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmprbfnsrzh.jl:66\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprbfnsrzh.jl:61\ntest set: Test Failed at /tmp/tmprbfnsrzh.jl:67\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmprbfnsrzh.jl:67\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprbfnsrzh.jl:61\ntest set: Test Failed at /tmp/tmprbfnsrzh.jl:68\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmprbfnsrzh.jl:68\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprbfnsrzh.jl:61\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprbfnsrzh.jl:59\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [node for\
    \ node in arr if node % 2 == 0]\n    if isempty(even_nodes)\n        return []\n\
    \    end\n    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpficta9ls.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpficta9ls.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpficta9ls.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpficta9ls.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpficta9ls.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpficta9ls.jl:43\n   [2] top-level scope at /tmp/tmpficta9ls.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpficta9ls.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpficta9ls.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpficta9ls.jl:43\n   [2] top-level scope at /tmp/tmpficta9ls.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpficta9ls.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpficta9ls.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpficta9ls.jl:43\n   [2] top-level scope at /tmp/tmpficta9ls.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpficta9ls.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpficta9ls.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpficta9ls.jl:43\n   [2] top-level scope at /tmp/tmpficta9ls.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpficta9ls.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpficta9ls.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpficta9ls.jl:43\n   [2] top-level scope at /tmp/tmpficta9ls.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpficta9ls.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpficta9ls.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if isempty(min_even)\n        return []\n    end\n\
    \    return [min_even, findfirst(arr, min_even)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpk4qih91s.jl:49\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpk4qih91s.jl:42\\\
    n   [2] top-level scope at /tmp/tmpk4qih91s.jl:49\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpk4qih91s.jl:48\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpk4qih91s.jl:50\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpk4qih91s.jl:42\\n   [2] top-level scope\
    \ at /tmp/tmpk4qih91s.jl:50\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpk4qih91s.jl:48\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpk4qih91s.jl:52\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpk4qih91s.jl:42\\n   [2] top-level scope\
    \ at /tmp/tmpk4qih91s.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpk4qih91s.jl:48\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpk4qih91s.jl:53\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpk4qih91s.jl:42\\n   [2] top-level scope\
    \ at /tmp/tmpk4qih91s.jl:53\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpk4qih91s.jl:48\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpk4qih91s.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpk4qih91s.jl:42\\n   [2] top-level scope\
    \ at /tmp/tmpk4qih91s.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpk4qih91s.jl:48\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpk4qih91s.jl:55\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpk4qih91s.jl:42\\n   [2] top-level scope\
    \ at /tmp/tmpk4qih91s.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpk4qih91s.jl:48\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpk4qih91s.jl:56\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\\n  ArgumentError: reducing over an empty collection\
    \ is not allowed\\n  Stacktrace:\\n   [1] _empty_reduce_error() at ./reduce.jl:295\\\
    n   [2] reduce_empty(::Function, ::Type{T} where T) at ./reduce.jl:305\\n   [3]\
    \ mapreduce_empty(::typeof(identity), ::Function, ::Type{T} where T) at ./reduce.jl:335\\\
    n   [4] _mapreduce at ./reduce.jl:392 [inlined]\\n   [5] _mapreduce_dim at ./reducedim.jl:312\
    \ [inlined]\\n   [6] #mapreduce#580 at ./reducedim.jl:307 [inlined]\\n   [7] mapreduce\
    \ at ./reducedim.jl:307 [inlined]\\n   [8] _minimum at ./reducedim.jl:657 [inlined]\\\
    n   [9] _minimum at ./reducedim.jl:656 [inlined]\\n   [10] #minimum#589 at ./reducedim.jl:652\
    \ [inlined]\\n   [11] minimum at ./reducedim.jl:652 [inlined]\\n   [12] pluck(::Array{Int64,1})\
    \ at /tmp/tmpk4qih91s.jl:38\\n   [13] top-level scope at /tmp/tmpk4qih91s.jl:56\\\
    n   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpk4qih91s.jl:48\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_index = 0\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0 && arr[i] < min_even\n            min_even = arr[i]\n            min_even_index\
    \ = i\n        end\n    end\n    if min_even == Inf\n        return []\n    end\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmppfk8hw51.jl:56\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmppfk8hw51.jl:56\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppfk8hw51.jl:55\\ntest set: Test Failed at /tmp/tmppfk8hw51.jl:57\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmppfk8hw51.jl:57\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppfk8hw51.jl:55\\ntest set: Test Failed at /tmp/tmppfk8hw51.jl:59\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmppfk8hw51.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppfk8hw51.jl:55\\ntest set: Test Failed at /tmp/tmppfk8hw51.jl:60\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmppfk8hw51.jl:60\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppfk8hw51.jl:55\\ntest set: Test Failed at /tmp/tmppfk8hw51.jl:61\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmppfk8hw51.jl:61\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppfk8hw51.jl:55\\ntest set: Test Failed at /tmp/tmppfk8hw51.jl:62\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmppfk8hw51.jl:62\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppfk8hw51.jl:55\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v,\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    sort!(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpusmw2co0.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpusmw2co0.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpusmw2co0.jl:54\ntest set: Test Failed at /tmp/tmpusmw2co0.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpusmw2co0.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpusmw2co0.jl:54\ntest set: Test Failed at /tmp/tmpusmw2co0.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpusmw2co0.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpusmw2co0.jl:54\ntest set: Test Failed at /tmp/tmpusmw2co0.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpusmw2co0.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpusmw2co0.jl:54\ntest set: Test Failed at /tmp/tmpusmw2co0.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpusmw2co0.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpusmw2co0.jl:54\ntest set: Test Failed at /tmp/tmpusmw2co0.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpusmw2co0.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpusmw2co0.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpusmw2co0.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_idx = 0\n    for (i, x) in enumerate(arr)\n        if x % 2 == 0\
    \ && x < min_even\n            min_even = x\n            min_even_idx = i\n  \
    \      end\n    end\n    if min_even == Inf\n        return []\n    end\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq81w5izf.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpq81w5izf.jl:56\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq81w5izf.jl:55\ntest set: Test Failed at /tmp/tmpq81w5izf.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpq81w5izf.jl:57\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq81w5izf.jl:55\ntest set: Test Failed at /tmp/tmpq81w5izf.jl:59\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpq81w5izf.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq81w5izf.jl:55\ntest set: Test Failed at /tmp/tmpq81w5izf.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpq81w5izf.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq81w5izf.jl:55\ntest set: Test Failed at /tmp/tmpq81w5izf.jl:61\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpq81w5izf.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq81w5izf.jl:55\ntest set: Test Failed at /tmp/tmpq81w5izf.jl:62\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpq81w5izf.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq81w5izf.jl:55\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq81w5izf.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    evens_min\
    \ = minimum(evens)\n    return [evens_min, findfirst(arr, evens_min)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmprssrf2rw.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmprssrf2rw.jl:43\\\
    n   [2] top-level scope at /tmp/tmprssrf2rw.jl:50\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprssrf2rw.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprssrf2rw.jl:51\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmprssrf2rw.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmprssrf2rw.jl:51\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprssrf2rw.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprssrf2rw.jl:53\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmprssrf2rw.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmprssrf2rw.jl:53\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprssrf2rw.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprssrf2rw.jl:54\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmprssrf2rw.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmprssrf2rw.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprssrf2rw.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprssrf2rw.jl:55\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmprssrf2rw.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmprssrf2rw.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprssrf2rw.jl:49\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprssrf2rw.jl:56\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmprssrf2rw.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmprssrf2rw.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprssrf2rw.jl:49\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpsregv4pc.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpsregv4pc.jl:43\\\
    n   [2] top-level scope at /tmp/tmpsregv4pc.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsregv4pc.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsregv4pc.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpsregv4pc.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpsregv4pc.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsregv4pc.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsregv4pc.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpsregv4pc.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpsregv4pc.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsregv4pc.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsregv4pc.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpsregv4pc.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpsregv4pc.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsregv4pc.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsregv4pc.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpsregv4pc.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpsregv4pc.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsregv4pc.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsregv4pc.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpsregv4pc.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpsregv4pc.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsregv4pc.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_snwyhjl.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp_snwyhjl.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp_snwyhjl.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_snwyhjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp_snwyhjl.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp_snwyhjl.jl:43\n   [2] top-level scope at /tmp/tmp_snwyhjl.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_snwyhjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp_snwyhjl.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp_snwyhjl.jl:43\n   [2] top-level scope at /tmp/tmp_snwyhjl.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_snwyhjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp_snwyhjl.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp_snwyhjl.jl:43\n   [2] top-level scope at /tmp/tmp_snwyhjl.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_snwyhjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp_snwyhjl.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp_snwyhjl.jl:43\n   [2] top-level scope at /tmp/tmp_snwyhjl.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_snwyhjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp_snwyhjl.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp_snwyhjl.jl:43\n   [2] top-level scope at /tmp/tmp_snwyhjl.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_snwyhjl.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_snwyhjl.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(even_values,\
    \ [v, i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    return sort!(even_values)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp4qw4u86o.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4qw4u86o.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qw4u86o.jl:53\ntest set: Test Failed at /tmp/tmp4qw4u86o.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4qw4u86o.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qw4u86o.jl:53\ntest set: Test Failed at /tmp/tmp4qw4u86o.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4qw4u86o.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qw4u86o.jl:53\ntest set: Test Failed at /tmp/tmp4qw4u86o.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp4qw4u86o.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qw4u86o.jl:53\ntest set: Test Failed at /tmp/tmp4qw4u86o.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4qw4u86o.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qw4u86o.jl:53\ntest set: Test Failed at /tmp/tmp4qw4u86o.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4qw4u86o.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qw4u86o.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4qw4u86o.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1u_ud5p6.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp1u_ud5p6.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp1u_ud5p6.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1u_ud5p6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1u_ud5p6.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1u_ud5p6.jl:43\n   [2] top-level scope at /tmp/tmp1u_ud5p6.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1u_ud5p6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1u_ud5p6.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1u_ud5p6.jl:43\n   [2] top-level scope at /tmp/tmp1u_ud5p6.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1u_ud5p6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1u_ud5p6.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1u_ud5p6.jl:43\n   [2] top-level scope at /tmp/tmp1u_ud5p6.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1u_ud5p6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1u_ud5p6.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1u_ud5p6.jl:43\n   [2] top-level scope at /tmp/tmp1u_ud5p6.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1u_ud5p6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp1u_ud5p6.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1u_ud5p6.jl:43\n   [2] top-level scope at /tmp/tmp1u_ud5p6.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1u_ud5p6.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1u_ud5p6.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp742vpfl9.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp742vpfl9.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp742vpfl9.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp742vpfl9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp742vpfl9.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp742vpfl9.jl:43\n   [2] top-level scope at /tmp/tmp742vpfl9.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp742vpfl9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp742vpfl9.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp742vpfl9.jl:43\n   [2] top-level scope at /tmp/tmp742vpfl9.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp742vpfl9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp742vpfl9.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp742vpfl9.jl:43\n   [2] top-level scope at /tmp/tmp742vpfl9.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp742vpfl9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp742vpfl9.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp742vpfl9.jl:43\n   [2] top-level scope at /tmp/tmp742vpfl9.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp742vpfl9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp742vpfl9.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp742vpfl9.jl:43\n   [2] top-level scope at /tmp/tmp742vpfl9.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp742vpfl9.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp742vpfl9.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp8wo46g05.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp8wo46g05.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp8wo46g05.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8wo46g05.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8wo46g05.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8wo46g05.jl:43\n   [2] top-level scope at /tmp/tmp8wo46g05.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8wo46g05.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8wo46g05.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8wo46g05.jl:43\n   [2] top-level scope at /tmp/tmp8wo46g05.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8wo46g05.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8wo46g05.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8wo46g05.jl:43\n   [2] top-level scope at /tmp/tmp8wo46g05.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8wo46g05.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8wo46g05.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8wo46g05.jl:43\n   [2] top-level scope at /tmp/tmp8wo46g05.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8wo46g05.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8wo46g05.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8wo46g05.jl:43\n   [2] top-level scope at /tmp/tmp8wo46g05.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8wo46g05.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8wo46g05.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp5w16md1q.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp5w16md1q.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp5w16md1q.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5w16md1q.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5w16md1q.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5w16md1q.jl:43\n   [2] top-level scope at /tmp/tmp5w16md1q.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5w16md1q.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5w16md1q.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5w16md1q.jl:43\n   [2] top-level scope at /tmp/tmp5w16md1q.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5w16md1q.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5w16md1q.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5w16md1q.jl:43\n   [2] top-level scope at /tmp/tmp5w16md1q.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5w16md1q.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5w16md1q.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5w16md1q.jl:43\n   [2] top-level scope at /tmp/tmp5w16md1q.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5w16md1q.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5w16md1q.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5w16md1q.jl:43\n   [2] top-level scope at /tmp/tmp5w16md1q.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5w16md1q.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5w16md1q.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if min_even == Inf\n        return []\n    end\n \
    \   return [min_even, findfirst(arr, min_even)[1]]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp5oq9m8px.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp5oq9m8px.jl:42\n   [2] top-level scope at\
    \ /tmp/tmp5oq9m8px.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5oq9m8px.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5oq9m8px.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5oq9m8px.jl:42\n   [2] top-level scope at /tmp/tmp5oq9m8px.jl:50\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5oq9m8px.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5oq9m8px.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5oq9m8px.jl:42\n   [2] top-level scope at /tmp/tmp5oq9m8px.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5oq9m8px.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5oq9m8px.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5oq9m8px.jl:42\n   [2] top-level scope at /tmp/tmp5oq9m8px.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5oq9m8px.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5oq9m8px.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5oq9m8px.jl:42\n   [2] top-level scope at /tmp/tmp5oq9m8px.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5oq9m8px.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5oq9m8px.jl:55\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5oq9m8px.jl:42\n   [2] top-level scope at /tmp/tmp5oq9m8px.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5oq9m8px.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp5oq9m8px.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  ArgumentError: reducing over an empty collection\
    \ is not allowed\n  Stacktrace:\n   [1] _empty_reduce_error() at ./reduce.jl:295\n\
    \   [2] reduce_empty(::Function, ::Type{T} where T) at ./reduce.jl:305\n   [3]\
    \ mapreduce_empty(::typeof(identity), ::Function, ::Type{T} where T) at ./reduce.jl:335\n\
    \   [4] _mapreduce at ./reduce.jl:392 [inlined]\n   [5] _mapreduce_dim at ./reducedim.jl:312\
    \ [inlined]\n   [6] #mapreduce#580 at ./reducedim.jl:307 [inlined]\n   [7] mapreduce\
    \ at ./reducedim.jl:307 [inlined]\n   [8] _minimum at ./reducedim.jl:657 [inlined]\n\
    \   [9] _minimum at ./reducedim.jl:656 [inlined]\n   [10] #minimum#589 at ./reducedim.jl:652\
    \ [inlined]\n   [11] minimum at ./reducedim.jl:652 [inlined]\n   [12] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5oq9m8px.jl:38\n   [13] top-level scope at /tmp/tmp5oq9m8px.jl:56\n\
    \   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [15] top-level scope at /tmp/tmp5oq9m8px.jl:48\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      7      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5oq9m8px.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_idx = findall(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_idx)\n        return []\n    end\n\
    \    min_even = minimum(arr[even_idx])\n    min_even_idx = findall(x -> x == min_even,\
    \ arr)\n    return [min_even, min_even_idx[1]]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp3jvyp3m1.jl:51\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp3jvyp3m1.jl:51\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jvyp3m1.jl:50\\ntest set: Test Failed at /tmp/tmp3jvyp3m1.jl:52\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp3jvyp3m1.jl:52\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jvyp3m1.jl:50\\ntest set: Test Failed at /tmp/tmp3jvyp3m1.jl:54\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3jvyp3m1.jl:54\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jvyp3m1.jl:50\\ntest set: Test Failed at /tmp/tmp3jvyp3m1.jl:55\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3jvyp3m1.jl:55\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jvyp3m1.jl:50\\ntest set: Test Failed at /tmp/tmp3jvyp3m1.jl:56\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3jvyp3m1.jl:56\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jvyp3m1.jl:50\\ntest set: Test Failed at /tmp/tmp3jvyp3m1.jl:57\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3jvyp3m1.jl:57\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jvyp3m1.jl:50\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvgqvqrp3.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpvgqvqrp3.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvgqvqrp3.jl:54\ntest set: Test Failed at /tmp/tmpvgqvqrp3.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvgqvqrp3.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvgqvqrp3.jl:54\ntest set: Test Failed at /tmp/tmpvgqvqrp3.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpvgqvqrp3.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvgqvqrp3.jl:54\ntest set: Test Failed at /tmp/tmpvgqvqrp3.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpvgqvqrp3.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvgqvqrp3.jl:54\ntest set: Test Failed at /tmp/tmpvgqvqrp3.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpvgqvqrp3.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvgqvqrp3.jl:54\ntest set: Test Failed at /tmp/tmpvgqvqrp3.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpvgqvqrp3.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvgqvqrp3.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvgqvqrp3.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    return [min_even, findall(arr .== min_even)[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkf0x99xk.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpkf0x99xk.jl:50\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkf0x99xk.jl:49\ntest set: Test Failed at /tmp/tmpkf0x99xk.jl:51\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpkf0x99xk.jl:51\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkf0x99xk.jl:49\ntest set: Test Failed at /tmp/tmpkf0x99xk.jl:53\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpkf0x99xk.jl:53\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkf0x99xk.jl:49\ntest set: Test Failed at /tmp/tmpkf0x99xk.jl:54\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpkf0x99xk.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkf0x99xk.jl:49\ntest set: Test Failed at /tmp/tmpkf0x99xk.jl:55\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpkf0x99xk.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkf0x99xk.jl:49\ntest set: Test Failed at /tmp/tmpkf0x99xk.jl:56\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpkf0x99xk.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkf0x99xk.jl:49\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkf0x99xk.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp2_cjqyqg.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp2_cjqyqg.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp2_cjqyqg.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2_cjqyqg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2_cjqyqg.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2_cjqyqg.jl:43\n   [2] top-level scope at /tmp/tmp2_cjqyqg.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2_cjqyqg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2_cjqyqg.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2_cjqyqg.jl:43\n   [2] top-level scope at /tmp/tmp2_cjqyqg.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2_cjqyqg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2_cjqyqg.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2_cjqyqg.jl:43\n   [2] top-level scope at /tmp/tmp2_cjqyqg.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2_cjqyqg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2_cjqyqg.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2_cjqyqg.jl:43\n   [2] top-level scope at /tmp/tmp2_cjqyqg.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2_cjqyqg.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2_cjqyqg.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2_cjqyqg.jl:43\n   [2] top-level scope at /tmp/tmp2_cjqyqg.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2_cjqyqg.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2_cjqyqg.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for (i,\
    \ x) in enumerate(arr)\n        if x % 2 == 0\n            push!(evens, [x, i])\n\
    \        end\n    end\n    if isempty(evens)\n        return []\n    end\n   \
    \ return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5dq12cna.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5dq12cna.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dq12cna.jl:53\ntest set: Test Failed at /tmp/tmp5dq12cna.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5dq12cna.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dq12cna.jl:53\ntest set: Test Failed at /tmp/tmp5dq12cna.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp5dq12cna.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dq12cna.jl:53\ntest set: Test Failed at /tmp/tmp5dq12cna.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp5dq12cna.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dq12cna.jl:53\ntest set: Test Failed at /tmp/tmp5dq12cna.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp5dq12cna.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dq12cna.jl:53\ntest set: Test Failed at /tmp/tmp5dq12cna.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp5dq12cna.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dq12cna.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5dq12cna.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # find the smallest even value\n    evens = filter(x -> x % 2 == 0, arr)\n\
    \    if isempty(evens)\n        return []\n    end\n    min_even = minimum(evens)\n\
    \    # find the index of the smallest even value\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpieq_amuq.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpieq_amuq.jl:42\n   [2] top-level scope at\
    \ /tmp/tmpieq_amuq.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpieq_amuq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpieq_amuq.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpieq_amuq.jl:42\n   [2] top-level scope at /tmp/tmpieq_amuq.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpieq_amuq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpieq_amuq.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpieq_amuq.jl:42\n   [2] top-level scope at /tmp/tmpieq_amuq.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpieq_amuq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpieq_amuq.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpieq_amuq.jl:42\n   [2] top-level scope at /tmp/tmpieq_amuq.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpieq_amuq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpieq_amuq.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpieq_amuq.jl:42\n   [2] top-level scope at /tmp/tmpieq_amuq.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpieq_amuq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpieq_amuq.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpieq_amuq.jl:42\n   [2] top-level scope at /tmp/tmpieq_amuq.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpieq_amuq.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpieq_amuq.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    smallest_even_index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, smallest_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpm9sgcu7a.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpm9sgcu7a.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpm9sgcu7a.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm9sgcu7a.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm9sgcu7a.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm9sgcu7a.jl:43\n   [2] top-level scope at /tmp/tmpm9sgcu7a.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm9sgcu7a.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm9sgcu7a.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm9sgcu7a.jl:43\n   [2] top-level scope at /tmp/tmpm9sgcu7a.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm9sgcu7a.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm9sgcu7a.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm9sgcu7a.jl:43\n   [2] top-level scope at /tmp/tmpm9sgcu7a.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm9sgcu7a.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm9sgcu7a.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm9sgcu7a.jl:43\n   [2] top-level scope at /tmp/tmpm9sgcu7a.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm9sgcu7a.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm9sgcu7a.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm9sgcu7a.jl:43\n   [2] top-level scope at /tmp/tmpm9sgcu7a.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm9sgcu7a.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm9sgcu7a.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpbawwv09m.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbawwv09m.jl:43\\\
    n   [2] top-level scope at /tmp/tmpbawwv09m.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbawwv09m.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbawwv09m.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbawwv09m.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpbawwv09m.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbawwv09m.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbawwv09m.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbawwv09m.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpbawwv09m.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbawwv09m.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbawwv09m.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbawwv09m.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpbawwv09m.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbawwv09m.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbawwv09m.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbawwv09m.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpbawwv09m.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbawwv09m.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbawwv09m.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbawwv09m.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpbawwv09m.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbawwv09m.jl:50\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmphtbvqcjl.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmphtbvqcjl.jl:43\n   [2] top-level scope at\
    \ /tmp/tmphtbvqcjl.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphtbvqcjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphtbvqcjl.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphtbvqcjl.jl:43\n   [2] top-level scope at /tmp/tmphtbvqcjl.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphtbvqcjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphtbvqcjl.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphtbvqcjl.jl:43\n   [2] top-level scope at /tmp/tmphtbvqcjl.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphtbvqcjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphtbvqcjl.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphtbvqcjl.jl:43\n   [2] top-level scope at /tmp/tmphtbvqcjl.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphtbvqcjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphtbvqcjl.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphtbvqcjl.jl:43\n   [2] top-level scope at /tmp/tmphtbvqcjl.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphtbvqcjl.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphtbvqcjl.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphtbvqcjl.jl:43\n   [2] top-level scope at /tmp/tmphtbvqcjl.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphtbvqcjl.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphtbvqcjl.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if length(even_values) == 0\n        return\
    \ []\n    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpyhw20x58.jl:59\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpyhw20x58.jl:59\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyhw20x58.jl:58\\ntest set: Test Failed at /tmp/tmpyhw20x58.jl:60\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpyhw20x58.jl:60\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyhw20x58.jl:58\\ntest set: Test Failed at /tmp/tmpyhw20x58.jl:62\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyhw20x58.jl:62\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyhw20x58.jl:58\\ntest set: Test Failed at /tmp/tmpyhw20x58.jl:63\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyhw20x58.jl:63\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyhw20x58.jl:58\\ntest set: Test Failed at /tmp/tmpyhw20x58.jl:64\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyhw20x58.jl:64\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyhw20x58.jl:58\\ntest set: Test Failed at /tmp/tmpyhw20x58.jl:65\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyhw20x58.jl:65\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyhw20x58.jl:58\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpyhw20x58.jl:56\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9ufkuj0v.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp9ufkuj0v.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp9ufkuj0v.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ufkuj0v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ufkuj0v.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9ufkuj0v.jl:43\n   [2] top-level scope at /tmp/tmp9ufkuj0v.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ufkuj0v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ufkuj0v.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9ufkuj0v.jl:43\n   [2] top-level scope at /tmp/tmp9ufkuj0v.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ufkuj0v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ufkuj0v.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9ufkuj0v.jl:43\n   [2] top-level scope at /tmp/tmp9ufkuj0v.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ufkuj0v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ufkuj0v.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9ufkuj0v.jl:43\n   [2] top-level scope at /tmp/tmp9ufkuj0v.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ufkuj0v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ufkuj0v.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9ufkuj0v.jl:43\n   [2] top-level scope at /tmp/tmp9ufkuj0v.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ufkuj0v.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ufkuj0v.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # find the smallest even value\n    evens = filter(x -> x % 2 == 0, arr)\n\
    \    if isempty(evens)\n        return []\n    end\n    min_even = minimum(evens)\n\
    \    # find the index of the smallest even value\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpi56oocnq.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpi56oocnq.jl:42\n   [2] top-level scope at\
    \ /tmp/tmpi56oocnq.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi56oocnq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpi56oocnq.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi56oocnq.jl:42\n   [2] top-level scope at /tmp/tmpi56oocnq.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi56oocnq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpi56oocnq.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi56oocnq.jl:42\n   [2] top-level scope at /tmp/tmpi56oocnq.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi56oocnq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpi56oocnq.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi56oocnq.jl:42\n   [2] top-level scope at /tmp/tmpi56oocnq.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi56oocnq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpi56oocnq.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi56oocnq.jl:42\n   [2] top-level scope at /tmp/tmpi56oocnq.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi56oocnq.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpi56oocnq.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi56oocnq.jl:42\n   [2] top-level scope at /tmp/tmpi56oocnq.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi56oocnq.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi56oocnq.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    evens\
    \ = sort(evens)\n    even = evens[1]\n    return [even, findfirst(arr, even)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcxnftd5s.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpcxnftd5s.jl:44\n   [2] top-level scope at\
    \ /tmp/tmpcxnftd5s.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcxnftd5s.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpcxnftd5s.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcxnftd5s.jl:44\n   [2] top-level scope at /tmp/tmpcxnftd5s.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcxnftd5s.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpcxnftd5s.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcxnftd5s.jl:44\n   [2] top-level scope at /tmp/tmpcxnftd5s.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcxnftd5s.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpcxnftd5s.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcxnftd5s.jl:44\n   [2] top-level scope at /tmp/tmpcxnftd5s.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcxnftd5s.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpcxnftd5s.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcxnftd5s.jl:44\n   [2] top-level scope at /tmp/tmpcxnftd5s.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcxnftd5s.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpcxnftd5s.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcxnftd5s.jl:44\n   [2] top-level scope at /tmp/tmpcxnftd5s.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcxnftd5s.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcxnftd5s.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_idx = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjyjpt9v3.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpjyjpt9v3.jl:39\n   [2] top-level scope at\
    \ /tmp/tmpjyjpt9v3.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjyjpt9v3.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpjyjpt9v3.jl:48\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjyjpt9v3.jl:39\n   [2] top-level scope at /tmp/tmpjyjpt9v3.jl:48\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjyjpt9v3.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpjyjpt9v3.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjyjpt9v3.jl:39\n   [2] top-level scope at /tmp/tmpjyjpt9v3.jl:50\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjyjpt9v3.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpjyjpt9v3.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjyjpt9v3.jl:39\n   [2] top-level scope at /tmp/tmpjyjpt9v3.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjyjpt9v3.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpjyjpt9v3.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjyjpt9v3.jl:39\n   [2] top-level scope at /tmp/tmpjyjpt9v3.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjyjpt9v3.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpjyjpt9v3.jl:53\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjyjpt9v3.jl:39\n   [2] top-level scope at /tmp/tmpjyjpt9v3.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjyjpt9v3.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpjyjpt9v3.jl:54\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  ArgumentError: reducing over an empty collection\
    \ is not allowed\n  Stacktrace:\n   [1] _empty_reduce_error() at ./reduce.jl:295\n\
    \   [2] reduce_empty(::Function, ::Type{T} where T) at ./reduce.jl:305\n   [3]\
    \ mapreduce_empty(::typeof(identity), ::Function, ::Type{T} where T) at ./reduce.jl:335\n\
    \   [4] _mapreduce at ./reduce.jl:392 [inlined]\n   [5] _mapreduce_dim at ./reducedim.jl:312\
    \ [inlined]\n   [6] #mapreduce#580 at ./reducedim.jl:307 [inlined]\n   [7] mapreduce\
    \ at ./reducedim.jl:307 [inlined]\n   [8] _minimum at ./reducedim.jl:657 [inlined]\n\
    \   [9] _minimum at ./reducedim.jl:656 [inlined]\n   [10] #minimum#589 at ./reducedim.jl:652\
    \ [inlined]\n   [11] minimum at ./reducedim.jl:652 [inlined]\n   [12] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjyjpt9v3.jl:38\n   [13] top-level scope at /tmp/tmpjyjpt9v3.jl:54\n\
    \   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [15] top-level scope at /tmp/tmpjyjpt9v3.jl:46\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      7      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjyjpt9v3.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [i for i\
    \ in arr if i % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpwyb7d977.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpwyb7d977.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpwyb7d977.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwyb7d977.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwyb7d977.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwyb7d977.jl:43\n   [2] top-level scope at /tmp/tmpwyb7d977.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwyb7d977.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwyb7d977.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwyb7d977.jl:43\n   [2] top-level scope at /tmp/tmpwyb7d977.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwyb7d977.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwyb7d977.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwyb7d977.jl:43\n   [2] top-level scope at /tmp/tmpwyb7d977.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwyb7d977.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwyb7d977.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwyb7d977.jl:43\n   [2] top-level scope at /tmp/tmpwyb7d977.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwyb7d977.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpwyb7d977.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpwyb7d977.jl:43\n   [2] top-level scope at /tmp/tmpwyb7d977.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwyb7d977.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwyb7d977.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = [x for\
    \ x in arr if x % 2 == 0]\n    if isempty(even_values)\n        return []\n  \
    \  end\n    min_even_value = minimum(even_values)\n    min_even_value_index =\
    \ findfirst(arr, min_even_value)\n    return [min_even_value, min_even_value_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpujwi7v6j.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpujwi7v6j.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpujwi7v6j.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpujwi7v6j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpujwi7v6j.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpujwi7v6j.jl:43\n   [2] top-level scope at /tmp/tmpujwi7v6j.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpujwi7v6j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpujwi7v6j.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpujwi7v6j.jl:43\n   [2] top-level scope at /tmp/tmpujwi7v6j.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpujwi7v6j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpujwi7v6j.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpujwi7v6j.jl:43\n   [2] top-level scope at /tmp/tmpujwi7v6j.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpujwi7v6j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpujwi7v6j.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpujwi7v6j.jl:43\n   [2] top-level scope at /tmp/tmpujwi7v6j.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpujwi7v6j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpujwi7v6j.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpujwi7v6j.jl:43\n   [2] top-level scope at /tmp/tmpujwi7v6j.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpujwi7v6j.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpujwi7v6j.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if arr[i] % 2 == 0]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_idx = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpnbhyemwh.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpnbhyemwh.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpnbhyemwh.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnbhyemwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpnbhyemwh.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpnbhyemwh.jl:43\n   [2] top-level scope at /tmp/tmpnbhyemwh.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnbhyemwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpnbhyemwh.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpnbhyemwh.jl:43\n   [2] top-level scope at /tmp/tmpnbhyemwh.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnbhyemwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpnbhyemwh.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpnbhyemwh.jl:43\n   [2] top-level scope at /tmp/tmpnbhyemwh.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnbhyemwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpnbhyemwh.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpnbhyemwh.jl:43\n   [2] top-level scope at /tmp/tmpnbhyemwh.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnbhyemwh.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpnbhyemwh.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpnbhyemwh.jl:43\n   [2] top-level scope at /tmp/tmpnbhyemwh.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnbhyemwh.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnbhyemwh.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_indices = findall(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_indices)\n        return []\n    end\n\
    \    min_even_index = minimum(even_indices)\n    return [arr[min_even_index],\
    \ min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpnislzfdr.jl:50\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [4, 1] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpnislzfdr.jl:50\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpnislzfdr.jl:49\\ntest set: Test Failed at /tmp/tmpnislzfdr.jl:51\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpnislzfdr.jl:51\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpnislzfdr.jl:49\\ntest set: Test Failed at /tmp/tmpnislzfdr.jl:53\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpnislzfdr.jl:53\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpnislzfdr.jl:49\\ntest set: Test Failed at /tmp/tmpnislzfdr.jl:54\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [2, 2]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpnislzfdr.jl:54\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpnislzfdr.jl:49\\ntest set: Test Failed at /tmp/tmpnislzfdr.jl:55\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpnislzfdr.jl:55\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpnislzfdr.jl:49\\ntest set: Test Failed at /tmp/tmpnislzfdr.jl:56\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpnislzfdr.jl:56\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpnislzfdr.jl:49\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp12_0ox13.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp12_0ox13.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp12_0ox13.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12_0ox13.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp12_0ox13.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12_0ox13.jl:43\n   [2] top-level scope at /tmp/tmp12_0ox13.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12_0ox13.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp12_0ox13.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12_0ox13.jl:43\n   [2] top-level scope at /tmp/tmp12_0ox13.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12_0ox13.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp12_0ox13.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12_0ox13.jl:43\n   [2] top-level scope at /tmp/tmp12_0ox13.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12_0ox13.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp12_0ox13.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12_0ox13.jl:43\n   [2] top-level scope at /tmp/tmp12_0ox13.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12_0ox13.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp12_0ox13.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12_0ox13.jl:43\n   [2] top-level scope at /tmp/tmp12_0ox13.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12_0ox13.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp12_0ox13.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_values) == 0\n      \
    \  return []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n \
    \   return even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw09ysjy_.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpw09ysjy_.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw09ysjy_.jl:54\ntest set: Test Failed at /tmp/tmpw09ysjy_.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw09ysjy_.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw09ysjy_.jl:54\ntest set: Test Failed at /tmp/tmpw09ysjy_.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpw09ysjy_.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw09ysjy_.jl:54\ntest set: Test Failed at /tmp/tmpw09ysjy_.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpw09ysjy_.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw09ysjy_.jl:54\ntest set: Test Failed at /tmp/tmpw09ysjy_.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpw09ysjy_.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw09ysjy_.jl:54\ntest set: Test Failed at /tmp/tmpw09ysjy_.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpw09ysjy_.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw09ysjy_.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw09ysjy_.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if length(even_values) == 0\n        return\
    \ []\n    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpgv_9ttob.jl:59\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpgv_9ttob.jl:59\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgv_9ttob.jl:58\\ntest set: Test Failed at /tmp/tmpgv_9ttob.jl:60\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpgv_9ttob.jl:60\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgv_9ttob.jl:58\\ntest set: Test Failed at /tmp/tmpgv_9ttob.jl:62\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgv_9ttob.jl:62\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgv_9ttob.jl:58\\ntest set: Test Failed at /tmp/tmpgv_9ttob.jl:63\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgv_9ttob.jl:63\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgv_9ttob.jl:58\\ntest set: Test Failed at /tmp/tmpgv_9ttob.jl:64\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgv_9ttob.jl:64\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgv_9ttob.jl:58\\ntest set: Test Failed at /tmp/tmpgv_9ttob.jl:65\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgv_9ttob.jl:65\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgv_9ttob.jl:58\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_idx = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\
    \ && arr[i] < min_even\n            min_even = arr[i]\n            min_even_idx\
    \ = i\n        end\n    end\n    if min_even_idx == -1\n        return []\n  \
    \  end\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp3x0j92ru.jl:56\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp3x0j92ru.jl:56\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3x0j92ru.jl:55\\ntest set: Test Failed at /tmp/tmp3x0j92ru.jl:57\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp3x0j92ru.jl:57\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3x0j92ru.jl:55\\ntest set: Test Failed at /tmp/tmp3x0j92ru.jl:59\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3x0j92ru.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3x0j92ru.jl:55\\ntest set: Test Failed at /tmp/tmp3x0j92ru.jl:60\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3x0j92ru.jl:60\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3x0j92ru.jl:55\\ntest set: Test Failed at /tmp/tmp3x0j92ru.jl:61\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3x0j92ru.jl:61\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3x0j92ru.jl:55\\ntest set: Test Failed at /tmp/tmp3x0j92ru.jl:62\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3x0j92ru.jl:62\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3x0j92ru.jl:55\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    return [min_even_node, findfirst(arr,\
    \ min_even_node)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcn4uy8vv.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpcn4uy8vv.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpcn4uy8vv.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcn4uy8vv.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpcn4uy8vv.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcn4uy8vv.jl:43\n   [2] top-level scope at /tmp/tmpcn4uy8vv.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcn4uy8vv.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpcn4uy8vv.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcn4uy8vv.jl:43\n   [2] top-level scope at /tmp/tmpcn4uy8vv.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcn4uy8vv.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpcn4uy8vv.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcn4uy8vv.jl:43\n   [2] top-level scope at /tmp/tmpcn4uy8vv.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcn4uy8vv.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpcn4uy8vv.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcn4uy8vv.jl:43\n   [2] top-level scope at /tmp/tmpcn4uy8vv.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcn4uy8vv.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpcn4uy8vv.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcn4uy8vv.jl:43\n   [2] top-level scope at /tmp/tmpcn4uy8vv.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcn4uy8vv.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcn4uy8vv.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nums)\n        return\
    \ []\n    end\n    return sort!(even_nums)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpzbgm7gcq.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzbgm7gcq.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzbgm7gcq.jl:53\ntest set: Test Failed at /tmp/tmpzbgm7gcq.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzbgm7gcq.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzbgm7gcq.jl:53\ntest set: Test Failed at /tmp/tmpzbgm7gcq.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzbgm7gcq.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzbgm7gcq.jl:53\ntest set: Test Failed at /tmp/tmpzbgm7gcq.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpzbgm7gcq.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzbgm7gcq.jl:53\ntest set: Test Failed at /tmp/tmpzbgm7gcq.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzbgm7gcq.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzbgm7gcq.jl:53\ntest set: Test Failed at /tmp/tmpzbgm7gcq.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzbgm7gcq.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzbgm7gcq.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzbgm7gcq.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = [x for\
    \ x in arr if x % 2 == 0]\n    if isempty(even_values)\n        return []\n  \
    \  end\n    min_even_value = minimum(even_values)\n    min_even_value_index =\
    \ findfirst(arr, min_even_value)\n    return [min_even_value, min_even_value_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmplhrdluc9.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmplhrdluc9.jl:43\\\
    n   [2] top-level scope at /tmp/tmplhrdluc9.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplhrdluc9.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplhrdluc9.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmplhrdluc9.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmplhrdluc9.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplhrdluc9.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplhrdluc9.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmplhrdluc9.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmplhrdluc9.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplhrdluc9.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplhrdluc9.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmplhrdluc9.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmplhrdluc9.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplhrdluc9.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplhrdluc9.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmplhrdluc9.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmplhrdluc9.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplhrdluc9.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplhrdluc9.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmplhrdluc9.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmplhrdluc9.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplhrdluc9.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_even_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even_value\n            return [min_even_value, i]\n\
    \        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprmbd3gix.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmprmbd3gix.jl:59\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprmbd3gix.jl:58\ntest set: Test Failed at /tmp/tmprmbd3gix.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmprmbd3gix.jl:60\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprmbd3gix.jl:58\ntest set: Test Failed at /tmp/tmprmbd3gix.jl:62\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmprmbd3gix.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprmbd3gix.jl:58\ntest set: Test Failed at /tmp/tmprmbd3gix.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmprmbd3gix.jl:63\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprmbd3gix.jl:58\ntest set: Test Failed at /tmp/tmprmbd3gix.jl:64\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmprmbd3gix.jl:64\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprmbd3gix.jl:58\ntest set: Test Failed at /tmp/tmprmbd3gix.jl:65\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmprmbd3gix.jl:65\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprmbd3gix.jl:58\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprmbd3gix.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    \"Given a string, return the first\
    \ character that is not repeated in the string.\n    If there is no character\
    \ that is not repeated, return None.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdrwyxrlv.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdrwyxrlv.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = [x for\
    \ x in arr if x % 2 == 0]\n    if isempty(even_values)\n        return []\n  \
    \  end\n    min_value = minimum(even_values)\n    min_index = findfirst(arr, min_value)\n\
    \    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp7r6edk27.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp7r6edk27.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp7r6edk27.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r6edk27.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r6edk27.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp7r6edk27.jl:43\n   [2] top-level scope at /tmp/tmp7r6edk27.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r6edk27.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r6edk27.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp7r6edk27.jl:43\n   [2] top-level scope at /tmp/tmp7r6edk27.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r6edk27.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r6edk27.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp7r6edk27.jl:43\n   [2] top-level scope at /tmp/tmp7r6edk27.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r6edk27.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r6edk27.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp7r6edk27.jl:43\n   [2] top-level scope at /tmp/tmp7r6edk27.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r6edk27.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp7r6edk27.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp7r6edk27.jl:43\n   [2] top-level scope at /tmp/tmp7r6edk27.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7r6edk27.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7r6edk27.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if min_even == Inf\n        return []\n    end\n \
    \   return [min_even, findfirst(arr, min_even)]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp3shecucr.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp3shecucr.jl:42\n   [2] top-level scope at\
    \ /tmp/tmp3shecucr.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3shecucr.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3shecucr.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3shecucr.jl:42\n   [2] top-level scope at /tmp/tmp3shecucr.jl:50\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3shecucr.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3shecucr.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3shecucr.jl:42\n   [2] top-level scope at /tmp/tmp3shecucr.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3shecucr.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3shecucr.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3shecucr.jl:42\n   [2] top-level scope at /tmp/tmp3shecucr.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3shecucr.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3shecucr.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3shecucr.jl:42\n   [2] top-level scope at /tmp/tmp3shecucr.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3shecucr.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3shecucr.jl:55\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3shecucr.jl:42\n   [2] top-level scope at /tmp/tmp3shecucr.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3shecucr.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp3shecucr.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  ArgumentError: reducing over an empty collection\
    \ is not allowed\n  Stacktrace:\n   [1] _empty_reduce_error() at ./reduce.jl:295\n\
    \   [2] reduce_empty(::Function, ::Type{T} where T) at ./reduce.jl:305\n   [3]\
    \ mapreduce_empty(::typeof(identity), ::Function, ::Type{T} where T) at ./reduce.jl:335\n\
    \   [4] _mapreduce at ./reduce.jl:392 [inlined]\n   [5] _mapreduce_dim at ./reducedim.jl:312\
    \ [inlined]\n   [6] #mapreduce#580 at ./reducedim.jl:307 [inlined]\n   [7] mapreduce\
    \ at ./reducedim.jl:307 [inlined]\n   [8] _minimum at ./reducedim.jl:657 [inlined]\n\
    \   [9] _minimum at ./reducedim.jl:656 [inlined]\n   [10] #minimum#589 at ./reducedim.jl:652\
    \ [inlined]\n   [11] minimum at ./reducedim.jl:652 [inlined]\n   [12] pluck(::Array{Int64,1})\
    \ at /tmp/tmp3shecucr.jl:38\n   [13] top-level scope at /tmp/tmp3shecucr.jl:56\n\
    \   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [15] top-level scope at /tmp/tmp3shecucr.jl:48\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      7      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3shecucr.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if arr[i] % 2 == 0]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpuzfzrx00.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpuzfzrx00.jl:43\\\
    n   [2] top-level scope at /tmp/tmpuzfzrx00.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuzfzrx00.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuzfzrx00.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpuzfzrx00.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpuzfzrx00.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuzfzrx00.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuzfzrx00.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpuzfzrx00.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpuzfzrx00.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuzfzrx00.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuzfzrx00.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpuzfzrx00.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpuzfzrx00.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuzfzrx00.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuzfzrx00.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpuzfzrx00.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpuzfzrx00.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuzfzrx00.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuzfzrx00.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpuzfzrx00.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpuzfzrx00.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuzfzrx00.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpuzfzrx00.jl:48\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmptarpsim9.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmptarpsim9.jl:43\n   [2] top-level scope at\
    \ /tmp/tmptarpsim9.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptarpsim9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmptarpsim9.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmptarpsim9.jl:43\n   [2] top-level scope at /tmp/tmptarpsim9.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptarpsim9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmptarpsim9.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmptarpsim9.jl:43\n   [2] top-level scope at /tmp/tmptarpsim9.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptarpsim9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmptarpsim9.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmptarpsim9.jl:43\n   [2] top-level scope at /tmp/tmptarpsim9.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptarpsim9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmptarpsim9.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmptarpsim9.jl:43\n   [2] top-level scope at /tmp/tmptarpsim9.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptarpsim9.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmptarpsim9.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmptarpsim9.jl:43\n   [2] top-level scope at /tmp/tmptarpsim9.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptarpsim9.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptarpsim9.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppvb8c2zj.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmppvb8c2zj.jl:43\n   [2] top-level scope at\
    \ /tmp/tmppvb8c2zj.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppvb8c2zj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppvb8c2zj.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppvb8c2zj.jl:43\n   [2] top-level scope at /tmp/tmppvb8c2zj.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppvb8c2zj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppvb8c2zj.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppvb8c2zj.jl:43\n   [2] top-level scope at /tmp/tmppvb8c2zj.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppvb8c2zj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppvb8c2zj.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppvb8c2zj.jl:43\n   [2] top-level scope at /tmp/tmppvb8c2zj.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppvb8c2zj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppvb8c2zj.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppvb8c2zj.jl:43\n   [2] top-level scope at /tmp/tmppvb8c2zj.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppvb8c2zj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmppvb8c2zj.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmppvb8c2zj.jl:43\n   [2] top-level scope at /tmp/tmppvb8c2zj.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppvb8c2zj.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppvb8c2zj.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [i for i\
    \ in arr if i % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp8zfrhj2u.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp8zfrhj2u.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp8zfrhj2u.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8zfrhj2u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8zfrhj2u.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8zfrhj2u.jl:43\n   [2] top-level scope at /tmp/tmp8zfrhj2u.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8zfrhj2u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8zfrhj2u.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8zfrhj2u.jl:43\n   [2] top-level scope at /tmp/tmp8zfrhj2u.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8zfrhj2u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8zfrhj2u.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8zfrhj2u.jl:43\n   [2] top-level scope at /tmp/tmp8zfrhj2u.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8zfrhj2u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8zfrhj2u.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8zfrhj2u.jl:43\n   [2] top-level scope at /tmp/tmp8zfrhj2u.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8zfrhj2u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp8zfrhj2u.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8zfrhj2u.jl:43\n   [2] top-level scope at /tmp/tmp8zfrhj2u.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8zfrhj2u.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8zfrhj2u.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if arr[i] % 2 == 0]\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findall(arr\
    \ .== min_even)[1]\n    return [min_even, min_even_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpid_fzpue.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpid_fzpue.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid_fzpue.jl:50\ntest set: Test Failed at /tmp/tmpid_fzpue.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpid_fzpue.jl:52\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid_fzpue.jl:50\ntest set: Test Failed at /tmp/tmpid_fzpue.jl:54\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpid_fzpue.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid_fzpue.jl:50\ntest set: Test Failed at /tmp/tmpid_fzpue.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpid_fzpue.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid_fzpue.jl:50\ntest set: Test Failed at /tmp/tmpid_fzpue.jl:56\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpid_fzpue.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid_fzpue.jl:50\ntest set: Test Failed at /tmp/tmpid_fzpue.jl:57\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpid_fzpue.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid_fzpue.jl:50\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpid_fzpue.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    even_nums = sort(even_nums, by = x -> x[1])\n    return even_nums[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpq635muqg.jl:55\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpq635muqg.jl:55\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq635muqg.jl:54\\ntest set: Test Failed at /tmp/tmpq635muqg.jl:56\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpq635muqg.jl:56\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq635muqg.jl:54\\ntest set: Test Failed at /tmp/tmpq635muqg.jl:58\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq635muqg.jl:58\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq635muqg.jl:54\\ntest set: Test Failed at /tmp/tmpq635muqg.jl:59\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq635muqg.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq635muqg.jl:54\\ntest set: Test Failed at /tmp/tmpq635muqg.jl:60\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq635muqg.jl:60\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq635muqg.jl:54\\ntest set: Test Failed at /tmp/tmpq635muqg.jl:61\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq635muqg.jl:61\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq635muqg.jl:54\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpaisdtj_r.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpaisdtj_r.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpaisdtj_r.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaisdtj_r.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpaisdtj_r.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpaisdtj_r.jl:43\n   [2] top-level scope at /tmp/tmpaisdtj_r.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaisdtj_r.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpaisdtj_r.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpaisdtj_r.jl:43\n   [2] top-level scope at /tmp/tmpaisdtj_r.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaisdtj_r.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpaisdtj_r.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpaisdtj_r.jl:43\n   [2] top-level scope at /tmp/tmpaisdtj_r.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaisdtj_r.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpaisdtj_r.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpaisdtj_r.jl:43\n   [2] top-level scope at /tmp/tmpaisdtj_r.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaisdtj_r.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpaisdtj_r.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpaisdtj_r.jl:43\n   [2] top-level scope at /tmp/tmpaisdtj_r.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpaisdtj_r.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaisdtj_r.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if length(even_values) == 0\n        return\
    \ []\n    end\n    min_even_value = minimum(even_values)\n    min_even_value_index\
    \ = findall(arr .== min_even_value)[1]\n    return [min_even_value, min_even_value_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk2mq2oe2.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpk2mq2oe2.jl:56\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk2mq2oe2.jl:55\ntest set: Test Failed at /tmp/tmpk2mq2oe2.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpk2mq2oe2.jl:57\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk2mq2oe2.jl:55\ntest set: Test Failed at /tmp/tmpk2mq2oe2.jl:59\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk2mq2oe2.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk2mq2oe2.jl:55\ntest set: Test Failed at /tmp/tmpk2mq2oe2.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpk2mq2oe2.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk2mq2oe2.jl:55\ntest set: Test Failed at /tmp/tmpk2mq2oe2.jl:61\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk2mq2oe2.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk2mq2oe2.jl:55\ntest set: Test Failed at /tmp/tmpk2mq2oe2.jl:62\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk2mq2oe2.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk2mq2oe2.jl:55\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk2mq2oe2.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyb7nqlej.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpyb7nqlej.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyb7nqlej.jl:50\ntest set: Test Failed at /tmp/tmpyb7nqlej.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyb7nqlej.jl:52\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyb7nqlej.jl:50\ntest set: Test Failed at /tmp/tmpyb7nqlej.jl:54\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpyb7nqlej.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyb7nqlej.jl:50\ntest set: Test Failed at /tmp/tmpyb7nqlej.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpyb7nqlej.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyb7nqlej.jl:50\ntest set: Test Failed at /tmp/tmpyb7nqlej.jl:56\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpyb7nqlej.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyb7nqlej.jl:50\ntest set: Test Failed at /tmp/tmpyb7nqlej.jl:57\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpyb7nqlej.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyb7nqlej.jl:50\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyb7nqlej.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcb8h40tf.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcb8h40tf.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcb8h40tf.jl:54\ntest set: Test Failed at /tmp/tmpcb8h40tf.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpcb8h40tf.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcb8h40tf.jl:54\ntest set: Test Failed at /tmp/tmpcb8h40tf.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpcb8h40tf.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcb8h40tf.jl:54\ntest set: Test Failed at /tmp/tmpcb8h40tf.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpcb8h40tf.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcb8h40tf.jl:54\ntest set: Test Failed at /tmp/tmpcb8h40tf.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpcb8h40tf.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcb8h40tf.jl:54\ntest set: Test Failed at /tmp/tmpcb8h40tf.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpcb8h40tf.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcb8h40tf.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcb8h40tf.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    evens = sort(evens)\n    evens[1]\n    return [evens[1], findfirst(arr,\
    \ evens[1])]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfhwygcod.jl:48\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpfhwygcod.jl:41\\\
    n   [2] top-level scope at /tmp/tmpfhwygcod.jl:48\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfhwygcod.jl:47\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfhwygcod.jl:49\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfhwygcod.jl:41\\n   [2] top-level scope\
    \ at /tmp/tmpfhwygcod.jl:49\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfhwygcod.jl:47\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfhwygcod.jl:51\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfhwygcod.jl:41\\n   [2] top-level scope\
    \ at /tmp/tmpfhwygcod.jl:51\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfhwygcod.jl:47\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfhwygcod.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfhwygcod.jl:41\\n   [2] top-level scope\
    \ at /tmp/tmpfhwygcod.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfhwygcod.jl:47\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfhwygcod.jl:53\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfhwygcod.jl:41\\n   [2] top-level scope\
    \ at /tmp/tmpfhwygcod.jl:53\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfhwygcod.jl:47\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfhwygcod.jl:54\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpfhwygcod.jl:41\\n   [2] top-level scope\
    \ at /tmp/tmpfhwygcod.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfhwygcod.jl:47\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    return sort(even_nodes)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpacvf_4ho.jl:54\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpacvf_4ho.jl:54\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpacvf_4ho.jl:53\\ntest set: Test Failed at /tmp/tmpacvf_4ho.jl:55\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpacvf_4ho.jl:55\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpacvf_4ho.jl:53\\ntest set: Test Failed at /tmp/tmpacvf_4ho.jl:57\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpacvf_4ho.jl:57\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpacvf_4ho.jl:53\\ntest set: Test Failed at /tmp/tmpacvf_4ho.jl:58\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpacvf_4ho.jl:58\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpacvf_4ho.jl:53\\ntest set: Test Failed at /tmp/tmpacvf_4ho.jl:59\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpacvf_4ho.jl:59\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpacvf_4ho.jl:53\\ntest set: Test Failed at /tmp/tmpacvf_4ho.jl:60\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpacvf_4ho.jl:60\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpacvf_4ho.jl:53\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    min_index = findall(arr .==\
    \ min_value)[1]\n    return [min_value, min_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpdz0lwetq.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpdz0lwetq.jl:56\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdz0lwetq.jl:55\ntest set: Test Failed at /tmp/tmpdz0lwetq.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdz0lwetq.jl:57\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdz0lwetq.jl:55\ntest set: Test Failed at /tmp/tmpdz0lwetq.jl:59\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdz0lwetq.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdz0lwetq.jl:55\ntest set: Test Failed at /tmp/tmpdz0lwetq.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpdz0lwetq.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdz0lwetq.jl:55\ntest set: Test Failed at /tmp/tmpdz0lwetq.jl:61\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdz0lwetq.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdz0lwetq.jl:55\ntest set: Test Failed at /tmp/tmpdz0lwetq.jl:62\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpdz0lwetq.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdz0lwetq.jl:55\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdz0lwetq.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq8jvy1ol.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpq8jvy1ol.jl:36\n\
    \   [2] top-level scope at /tmp/tmpq8jvy1ol.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8jvy1ol.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8jvy1ol.jl:43\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpq8jvy1ol.jl:36\n\
    \   [2] top-level scope at /tmp/tmpq8jvy1ol.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8jvy1ol.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8jvy1ol.jl:44\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpq8jvy1ol.jl:36\n\
    \   [2] top-level scope at /tmp/tmpq8jvy1ol.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8jvy1ol.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8jvy1ol.jl:45\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpq8jvy1ol.jl:36\n\
    \   [2] top-level scope at /tmp/tmpq8jvy1ol.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8jvy1ol.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8jvy1ol.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpq8jvy1ol.jl:36\n\
    \   [2] top-level scope at /tmp/tmpq8jvy1ol.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8jvy1ol.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8jvy1ol.jl:47\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpq8jvy1ol.jl:36\n\
    \   [2] top-level scope at /tmp/tmpq8jvy1ol.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8jvy1ol.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8jvy1ol.jl:48\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpq8jvy1ol.jl:36\n\
    \   [2] top-level scope at /tmp/tmpq8jvy1ol.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8jvy1ol.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8jvy1ol.jl:49\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpq8jvy1ol.jl:36\n\
    \   [2] top-level scope at /tmp/tmpq8jvy1ol.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8jvy1ol.jl:41\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq8jvy1ol.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_values)\n        return\
    \ []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n    return\
    \ even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpfx6img7i.jl:55\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpfx6img7i.jl:55\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfx6img7i.jl:54\\ntest set: Test Failed at /tmp/tmpfx6img7i.jl:56\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpfx6img7i.jl:56\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfx6img7i.jl:54\\ntest set: Test Failed at /tmp/tmpfx6img7i.jl:58\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfx6img7i.jl:58\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfx6img7i.jl:54\\ntest set: Test Failed at /tmp/tmpfx6img7i.jl:59\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfx6img7i.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfx6img7i.jl:54\\ntest set: Test Failed at /tmp/tmpfx6img7i.jl:60\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfx6img7i.jl:60\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfx6img7i.jl:54\\ntest set: Test Failed at /tmp/tmpfx6img7i.jl:61\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfx6img7i.jl:61\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfx6img7i.jl:54\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7r3d3znk.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp7r3d3znk.jl:59\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7r3d3znk.jl:58\ntest set: Test Failed at /tmp/tmp7r3d3znk.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7r3d3znk.jl:60\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7r3d3znk.jl:58\ntest set: Test Failed at /tmp/tmp7r3d3znk.jl:62\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp7r3d3znk.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7r3d3znk.jl:58\ntest set: Test Failed at /tmp/tmp7r3d3znk.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp7r3d3znk.jl:63\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7r3d3znk.jl:58\ntest set: Test Failed at /tmp/tmp7r3d3znk.jl:64\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp7r3d3znk.jl:64\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7r3d3znk.jl:58\ntest set: Test Failed at /tmp/tmp7r3d3znk.jl:65\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp7r3d3znk.jl:65\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7r3d3znk.jl:58\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7r3d3znk.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_values) == 0\n      \
    \  return []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n \
    \   return even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplnn3xt1h.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmplnn3xt1h.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnn3xt1h.jl:54\ntest set: Test Failed at /tmp/tmplnn3xt1h.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplnn3xt1h.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnn3xt1h.jl:54\ntest set: Test Failed at /tmp/tmplnn3xt1h.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmplnn3xt1h.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnn3xt1h.jl:54\ntest set: Test Failed at /tmp/tmplnn3xt1h.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmplnn3xt1h.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnn3xt1h.jl:54\ntest set: Test Failed at /tmp/tmplnn3xt1h.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmplnn3xt1h.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnn3xt1h.jl:54\ntest set: Test Failed at /tmp/tmplnn3xt1h.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmplnn3xt1h.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnn3xt1h.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplnn3xt1h.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    \"Given an array of integers, return\
    \ the indices of the two numbers such that they add up to a specific target.\n\
    \    You may assume that each input would have exactly one solution, and you may\
    \ not use the same element twice.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpju3gsoq9.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpju3gsoq9.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = []\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n \
    \           push!(evens, [arr[i], i])\n        end\n    end\n    if length(evens)\
    \ == 0\n        return []\n    end\n    evens = sort(evens, by = x -> x[1])\n\
    \    return evens[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxci7fee3.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpxci7fee3.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxci7fee3.jl:51\ntest set: Test Failed at /tmp/tmpxci7fee3.jl:53\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxci7fee3.jl:53\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxci7fee3.jl:51\ntest set: Test Failed at /tmp/tmpxci7fee3.jl:55\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpxci7fee3.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxci7fee3.jl:51\ntest set: Test Failed at /tmp/tmpxci7fee3.jl:56\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpxci7fee3.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxci7fee3.jl:51\ntest set: Test Failed at /tmp/tmpxci7fee3.jl:57\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpxci7fee3.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxci7fee3.jl:51\ntest set: Test Failed at /tmp/tmpxci7fee3.jl:58\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpxci7fee3.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxci7fee3.jl:51\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxci7fee3.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_idx = findall(arr\
    \ .% 2 .== 0)\n    if isempty(even_idx)\n        return []\n    end\n    even_arr\
    \ = arr[even_idx]\n    min_even = minimum(even_arr)\n    min_even_idx = findall(even_arr\
    \ .== min_even)\n    return [min_even, even_idx[min_even_idx[1]]]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp77aa86ws.jl:52\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp77aa86ws.jl:52\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp77aa86ws.jl:51\\ntest set: Test Failed at /tmp/tmp77aa86ws.jl:53\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp77aa86ws.jl:53\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp77aa86ws.jl:51\\ntest set: Test Failed at /tmp/tmp77aa86ws.jl:55\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp77aa86ws.jl:55\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp77aa86ws.jl:51\\ntest set: Test Failed at /tmp/tmp77aa86ws.jl:56\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp77aa86ws.jl:56\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp77aa86ws.jl:51\\ntest set: Test Failed at /tmp/tmp77aa86ws.jl:57\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp77aa86ws.jl:57\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp77aa86ws.jl:51\\ntest set: Test Failed at /tmp/tmp77aa86ws.jl:58\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp77aa86ws.jl:58\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp77aa86ws.jl:51\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    smallest_even_index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, smallest_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp5l8dyu_j.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp5l8dyu_j.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp5l8dyu_j.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5l8dyu_j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5l8dyu_j.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5l8dyu_j.jl:43\n   [2] top-level scope at /tmp/tmp5l8dyu_j.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5l8dyu_j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5l8dyu_j.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5l8dyu_j.jl:43\n   [2] top-level scope at /tmp/tmp5l8dyu_j.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5l8dyu_j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5l8dyu_j.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5l8dyu_j.jl:43\n   [2] top-level scope at /tmp/tmp5l8dyu_j.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5l8dyu_j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5l8dyu_j.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5l8dyu_j.jl:43\n   [2] top-level scope at /tmp/tmp5l8dyu_j.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5l8dyu_j.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp5l8dyu_j.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp5l8dyu_j.jl:43\n   [2] top-level scope at /tmp/tmp5l8dyu_j.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5l8dyu_j.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5l8dyu_j.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmphhvpxscw.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmphhvpxscw.jl:43\n   [2] top-level scope at\
    \ /tmp/tmphhvpxscw.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhvpxscw.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphhvpxscw.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphhvpxscw.jl:43\n   [2] top-level scope at /tmp/tmphhvpxscw.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhvpxscw.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphhvpxscw.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphhvpxscw.jl:43\n   [2] top-level scope at /tmp/tmphhvpxscw.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhvpxscw.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphhvpxscw.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphhvpxscw.jl:43\n   [2] top-level scope at /tmp/tmphhvpxscw.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhvpxscw.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphhvpxscw.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphhvpxscw.jl:43\n   [2] top-level scope at /tmp/tmphhvpxscw.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhvpxscw.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmphhvpxscw.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmphhvpxscw.jl:43\n   [2] top-level scope at /tmp/tmphhvpxscw.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhvpxscw.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphhvpxscw.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpe5y8rngr.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpe5y8rngr.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpe5y8rngr.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe5y8rngr.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpe5y8rngr.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpe5y8rngr.jl:43\n   [2] top-level scope at /tmp/tmpe5y8rngr.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe5y8rngr.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpe5y8rngr.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpe5y8rngr.jl:43\n   [2] top-level scope at /tmp/tmpe5y8rngr.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe5y8rngr.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpe5y8rngr.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpe5y8rngr.jl:43\n   [2] top-level scope at /tmp/tmpe5y8rngr.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe5y8rngr.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpe5y8rngr.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpe5y8rngr.jl:43\n   [2] top-level scope at /tmp/tmpe5y8rngr.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe5y8rngr.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpe5y8rngr.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpe5y8rngr.jl:43\n   [2] top-level scope at /tmp/tmpe5y8rngr.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe5y8rngr.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe5y8rngr.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpish1zfq1.jl:43\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: Int64[] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpish1zfq1.jl:43\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpish1zfq1.jl:42\\ntest set: Test Failed at /tmp/tmpish1zfq1.jl:44\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: Int64[] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpish1zfq1.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpish1zfq1.jl:42\\ntest set: Test Failed at /tmp/tmpish1zfq1.jl:46\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: Int64[]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpish1zfq1.jl:46\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpish1zfq1.jl:42\\ntest set: Test Failed at /tmp/tmpish1zfq1.jl:47\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: Int64[]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpish1zfq1.jl:47\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpish1zfq1.jl:42\\ntest set: Test Failed at /tmp/tmpish1zfq1.jl:48\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: Int64[] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpish1zfq1.jl:48\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpish1zfq1.jl:42\\ntest set: Test Failed at /tmp/tmpish1zfq1.jl:49\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: Int64[] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpish1zfq1.jl:49\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpish1zfq1.jl:42\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj3d48spn.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpj3d48spn.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpj3d48spn.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj3d48spn.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj3d48spn.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj3d48spn.jl:43\n   [2] top-level scope at /tmp/tmpj3d48spn.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj3d48spn.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj3d48spn.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj3d48spn.jl:43\n   [2] top-level scope at /tmp/tmpj3d48spn.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj3d48spn.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj3d48spn.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj3d48spn.jl:43\n   [2] top-level scope at /tmp/tmpj3d48spn.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj3d48spn.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj3d48spn.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj3d48spn.jl:43\n   [2] top-level scope at /tmp/tmpj3d48spn.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj3d48spn.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpj3d48spn.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj3d48spn.jl:43\n   [2] top-level scope at /tmp/tmpj3d48spn.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj3d48spn.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj3d48spn.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpbjnns837.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpbjnns837.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpbjnns837.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbjnns837.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbjnns837.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbjnns837.jl:43\n   [2] top-level scope at /tmp/tmpbjnns837.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbjnns837.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbjnns837.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbjnns837.jl:43\n   [2] top-level scope at /tmp/tmpbjnns837.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbjnns837.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbjnns837.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbjnns837.jl:43\n   [2] top-level scope at /tmp/tmpbjnns837.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbjnns837.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbjnns837.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbjnns837.jl:43\n   [2] top-level scope at /tmp/tmpbjnns837.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbjnns837.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpbjnns837.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpbjnns837.jl:43\n   [2] top-level scope at /tmp/tmpbjnns837.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbjnns837.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbjnns837.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2c7mud9v.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp2c7mud9v.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp2c7mud9v.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2c7mud9v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2c7mud9v.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2c7mud9v.jl:43\n   [2] top-level scope at /tmp/tmp2c7mud9v.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2c7mud9v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2c7mud9v.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2c7mud9v.jl:43\n   [2] top-level scope at /tmp/tmp2c7mud9v.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2c7mud9v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2c7mud9v.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2c7mud9v.jl:43\n   [2] top-level scope at /tmp/tmp2c7mud9v.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2c7mud9v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2c7mud9v.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2c7mud9v.jl:43\n   [2] top-level scope at /tmp/tmp2c7mud9v.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2c7mud9v.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmp2c7mud9v.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp2c7mud9v.jl:43\n   [2] top-level scope at /tmp/tmp2c7mud9v.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2c7mud9v.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2c7mud9v.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpngdy3z04.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpngdy3z04.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpngdy3z04.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpngdy3z04.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpngdy3z04.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpngdy3z04.jl:43\n   [2] top-level scope at /tmp/tmpngdy3z04.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpngdy3z04.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpngdy3z04.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpngdy3z04.jl:43\n   [2] top-level scope at /tmp/tmpngdy3z04.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpngdy3z04.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpngdy3z04.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpngdy3z04.jl:43\n   [2] top-level scope at /tmp/tmpngdy3z04.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpngdy3z04.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpngdy3z04.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpngdy3z04.jl:43\n   [2] top-level scope at /tmp/tmpngdy3z04.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpngdy3z04.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpngdy3z04.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpngdy3z04.jl:43\n   [2] top-level scope at /tmp/tmpngdy3z04.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpngdy3z04.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpngdy3z04.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    min_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpm6ztiqy5.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpm6ztiqy5.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpm6ztiqy5.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6ztiqy5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm6ztiqy5.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm6ztiqy5.jl:43\n   [2] top-level scope at /tmp/tmpm6ztiqy5.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6ztiqy5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm6ztiqy5.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm6ztiqy5.jl:43\n   [2] top-level scope at /tmp/tmpm6ztiqy5.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6ztiqy5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm6ztiqy5.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm6ztiqy5.jl:43\n   [2] top-level scope at /tmp/tmpm6ztiqy5.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6ztiqy5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm6ztiqy5.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm6ztiqy5.jl:43\n   [2] top-level scope at /tmp/tmpm6ztiqy5.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6ztiqy5.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm6ztiqy5.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm6ztiqy5.jl:43\n   [2] top-level scope at /tmp/tmpm6ztiqy5.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6ztiqy5.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm6ztiqy5.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if arr[i] % 2 == 0]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpi0a3f83e.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpi0a3f83e.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpi0a3f83e.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0a3f83e.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0a3f83e.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0a3f83e.jl:43\n   [2] top-level scope at /tmp/tmpi0a3f83e.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0a3f83e.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0a3f83e.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0a3f83e.jl:43\n   [2] top-level scope at /tmp/tmpi0a3f83e.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0a3f83e.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0a3f83e.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0a3f83e.jl:43\n   [2] top-level scope at /tmp/tmpi0a3f83e.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0a3f83e.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0a3f83e.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0a3f83e.jl:43\n   [2] top-level scope at /tmp/tmpi0a3f83e.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0a3f83e.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0a3f83e.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0a3f83e.jl:43\n   [2] top-level scope at /tmp/tmpi0a3f83e.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0a3f83e.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi0a3f83e.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_idx = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfxu8umgh.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpfxu8umgh.jl:39\n   [2] top-level scope at\
    \ /tmp/tmpfxu8umgh.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfxu8umgh.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpfxu8umgh.jl:48\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfxu8umgh.jl:39\n   [2] top-level scope at /tmp/tmpfxu8umgh.jl:48\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfxu8umgh.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpfxu8umgh.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfxu8umgh.jl:39\n   [2] top-level scope at /tmp/tmpfxu8umgh.jl:50\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfxu8umgh.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpfxu8umgh.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfxu8umgh.jl:39\n   [2] top-level scope at /tmp/tmpfxu8umgh.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfxu8umgh.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpfxu8umgh.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfxu8umgh.jl:39\n   [2] top-level scope at /tmp/tmpfxu8umgh.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfxu8umgh.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpfxu8umgh.jl:53\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfxu8umgh.jl:39\n   [2] top-level scope at /tmp/tmpfxu8umgh.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfxu8umgh.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpfxu8umgh.jl:54\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  ArgumentError: reducing over an empty collection\
    \ is not allowed\n  Stacktrace:\n   [1] _empty_reduce_error() at ./reduce.jl:295\n\
    \   [2] reduce_empty(::Function, ::Type{T} where T) at ./reduce.jl:305\n   [3]\
    \ mapreduce_empty(::typeof(identity), ::Function, ::Type{T} where T) at ./reduce.jl:335\n\
    \   [4] _mapreduce at ./reduce.jl:392 [inlined]\n   [5] _mapreduce_dim at ./reducedim.jl:312\
    \ [inlined]\n   [6] #mapreduce#580 at ./reducedim.jl:307 [inlined]\n   [7] mapreduce\
    \ at ./reducedim.jl:307 [inlined]\n   [8] _minimum at ./reducedim.jl:657 [inlined]\n\
    \   [9] _minimum at ./reducedim.jl:656 [inlined]\n   [10] #minimum#589 at ./reducedim.jl:652\
    \ [inlined]\n   [11] minimum at ./reducedim.jl:652 [inlined]\n   [12] pluck(::Array{Int64,1})\
    \ at /tmp/tmpfxu8umgh.jl:38\n   [13] top-level scope at /tmp/tmpfxu8umgh.jl:54\n\
    \   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [15] top-level scope at /tmp/tmpfxu8umgh.jl:46\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      7      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfxu8umgh.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_index = findfirst(arr, min_even)\n   \
    \ return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpz8n9x7pq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpz8n9x7pq.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpz8n9x7pq.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz8n9x7pq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpz8n9x7pq.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpz8n9x7pq.jl:43\n   [2] top-level scope at /tmp/tmpz8n9x7pq.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz8n9x7pq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpz8n9x7pq.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpz8n9x7pq.jl:43\n   [2] top-level scope at /tmp/tmpz8n9x7pq.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz8n9x7pq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpz8n9x7pq.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpz8n9x7pq.jl:43\n   [2] top-level scope at /tmp/tmpz8n9x7pq.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz8n9x7pq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpz8n9x7pq.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpz8n9x7pq.jl:43\n   [2] top-level scope at /tmp/tmpz8n9x7pq.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz8n9x7pq.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpz8n9x7pq.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpz8n9x7pq.jl:43\n   [2] top-level scope at /tmp/tmpz8n9x7pq.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz8n9x7pq.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz8n9x7pq.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxon88d49.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpxon88d49.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpxon88d49.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxon88d49.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxon88d49.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxon88d49.jl:43\n   [2] top-level scope at /tmp/tmpxon88d49.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxon88d49.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxon88d49.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxon88d49.jl:43\n   [2] top-level scope at /tmp/tmpxon88d49.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxon88d49.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxon88d49.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxon88d49.jl:43\n   [2] top-level scope at /tmp/tmpxon88d49.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxon88d49.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxon88d49.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxon88d49.jl:43\n   [2] top-level scope at /tmp/tmpxon88d49.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxon88d49.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpxon88d49.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpxon88d49.jl:43\n   [2] top-level scope at /tmp/tmpxon88d49.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxon88d49.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxon88d49.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbo2lq1qc.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbo2lq1qc.jl:36\n\
    \   [2] top-level scope at /tmp/tmpbo2lq1qc.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo2lq1qc.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo2lq1qc.jl:43\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbo2lq1qc.jl:36\n\
    \   [2] top-level scope at /tmp/tmpbo2lq1qc.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo2lq1qc.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo2lq1qc.jl:44\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbo2lq1qc.jl:36\n\
    \   [2] top-level scope at /tmp/tmpbo2lq1qc.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo2lq1qc.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo2lq1qc.jl:45\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbo2lq1qc.jl:36\n\
    \   [2] top-level scope at /tmp/tmpbo2lq1qc.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo2lq1qc.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo2lq1qc.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbo2lq1qc.jl:36\n\
    \   [2] top-level scope at /tmp/tmpbo2lq1qc.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo2lq1qc.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo2lq1qc.jl:47\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbo2lq1qc.jl:36\n\
    \   [2] top-level scope at /tmp/tmpbo2lq1qc.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo2lq1qc.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo2lq1qc.jl:48\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbo2lq1qc.jl:36\n\
    \   [2] top-level scope at /tmp/tmpbo2lq1qc.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo2lq1qc.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmpbo2lq1qc.jl:49\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbo2lq1qc.jl:36\n\
    \   [2] top-level scope at /tmp/tmpbo2lq1qc.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbo2lq1qc.jl:41\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbo2lq1qc.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpc8zn5_ar.jl:55\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpc8zn5_ar.jl:55\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc8zn5_ar.jl:54\\ntest set: Test Failed at /tmp/tmpc8zn5_ar.jl:56\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpc8zn5_ar.jl:56\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc8zn5_ar.jl:54\\ntest set: Test Failed at /tmp/tmpc8zn5_ar.jl:58\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpc8zn5_ar.jl:58\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc8zn5_ar.jl:54\\ntest set: Test Failed at /tmp/tmpc8zn5_ar.jl:59\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpc8zn5_ar.jl:59\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc8zn5_ar.jl:54\\ntest set: Test Failed at /tmp/tmpc8zn5_ar.jl:60\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpc8zn5_ar.jl:60\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc8zn5_ar.jl:54\\ntest set: Test Failed at /tmp/tmpc8zn5_ar.jl:61\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpc8zn5_ar.jl:61\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc8zn5_ar.jl:54\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Int64(Inf)\n\
    \    min_even_index = 0\n    for (i, v) in enumerate(arr)\n        if v % 2 ==\
    \ 0 && v < min_even\n            min_even = v\n            min_even_index = i\n\
    \        end\n    end\n    if min_even == Inf\n        return []\n    end\n  \
    \  return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpnwow8kod.jl:56\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  InexactError: Int64(Inf)\\\
    n  Stacktrace:\\n   [1] Int64(::Float64) at ./float.jl:710\\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpnwow8kod.jl:38\\n   [3] top-level scope at /tmp/tmpnwow8kod.jl:56\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpnwow8kod.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpnwow8kod.jl:57\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  InexactError: Int64(Inf)\\n  Stacktrace:\\n   [1] Int64(::Float64)\
    \ at ./float.jl:710\\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpnwow8kod.jl:38\\\
    n   [3] top-level scope at /tmp/tmpnwow8kod.jl:57\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpnwow8kod.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpnwow8kod.jl:59\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  InexactError: Int64(Inf)\\n  Stacktrace:\\n  \
    \ [1] Int64(::Float64) at ./float.jl:710\\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpnwow8kod.jl:38\\\
    n   [3] top-level scope at /tmp/tmpnwow8kod.jl:59\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpnwow8kod.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpnwow8kod.jl:60\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  InexactError: Int64(Inf)\\n  Stacktrace:\\n  \
    \ [1] Int64(::Float64) at ./float.jl:710\\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpnwow8kod.jl:38\\\
    n   [3] top-level scope at /tmp/tmpnwow8kod.jl:60\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpnwow8kod.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpnwow8kod.jl:61\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  InexactError: Int64(Inf)\\n  Stacktrace:\\n   [1]\
    \ Int64(::Float64) at ./float.jl:710\\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpnwow8kod.jl:38\\\
    n   [3] top-level scope at /tmp/tmpnwow8kod.jl:61\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpnwow8kod.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpnwow8kod.jl:62\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  InexactError: Int64(Inf)\\n  Stacktrace:\\n   [1] Int64(::Float64)\
    \ at ./float.jl:710\\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpnwow8kod.jl:38\\\
    n   [3] top-level scope at /tmp/tmpnwow8kod.jl:62\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpnwow8kod.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpnwow8kod.jl:63\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\\n  InexactError: Int64(Inf)\\n  Stacktrace:\\\
    n   [1] Int64(::Float64) at ./float.jl:710\\n   [2] pluck(::Array{Int64,1}) at\
    \ /tmp/tmpnwow8kod.jl:38\\n   [3] top-level scope at /tmp/tmpnwow8kod.jl:63\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpnwow8kod.jl:55\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjgbkwcn1.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpjgbkwcn1.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpjgbkwcn1.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjgbkwcn1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpjgbkwcn1.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjgbkwcn1.jl:43\n   [2] top-level scope at /tmp/tmpjgbkwcn1.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjgbkwcn1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpjgbkwcn1.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjgbkwcn1.jl:43\n   [2] top-level scope at /tmp/tmpjgbkwcn1.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjgbkwcn1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpjgbkwcn1.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjgbkwcn1.jl:43\n   [2] top-level scope at /tmp/tmpjgbkwcn1.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjgbkwcn1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpjgbkwcn1.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjgbkwcn1.jl:43\n   [2] top-level scope at /tmp/tmpjgbkwcn1.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjgbkwcn1.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpjgbkwcn1.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpjgbkwcn1.jl:43\n   [2] top-level scope at /tmp/tmpjgbkwcn1.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjgbkwcn1.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjgbkwcn1.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmnfh2m1b.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpmnfh2m1b.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpmnfh2m1b.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmnfh2m1b.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpmnfh2m1b.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmnfh2m1b.jl:43\n   [2] top-level scope at /tmp/tmpmnfh2m1b.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmnfh2m1b.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpmnfh2m1b.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmnfh2m1b.jl:43\n   [2] top-level scope at /tmp/tmpmnfh2m1b.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmnfh2m1b.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpmnfh2m1b.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmnfh2m1b.jl:43\n   [2] top-level scope at /tmp/tmpmnfh2m1b.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmnfh2m1b.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpmnfh2m1b.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmnfh2m1b.jl:43\n   [2] top-level scope at /tmp/tmpmnfh2m1b.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmnfh2m1b.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpmnfh2m1b.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpmnfh2m1b.jl:43\n   [2] top-level scope at /tmp/tmpmnfh2m1b.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmnfh2m1b.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmnfh2m1b.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0a7ot03s.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0a7ot03s.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0a7ot03s.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0a7ot03s.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0a7ot03s.jl:43\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0a7ot03s.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0a7ot03s.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0a7ot03s.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0a7ot03s.jl:44\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0a7ot03s.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0a7ot03s.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0a7ot03s.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0a7ot03s.jl:45\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0a7ot03s.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0a7ot03s.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0a7ot03s.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0a7ot03s.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0a7ot03s.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0a7ot03s.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0a7ot03s.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0a7ot03s.jl:47\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0a7ot03s.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0a7ot03s.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0a7ot03s.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0a7ot03s.jl:48\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0a7ot03s.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0a7ot03s.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0a7ot03s.jl:41\n  \ntest set: Error During\
    \ Test at /tmp/tmp0a7ot03s.jl:49\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0a7ot03s.jl:36\n\
    \   [2] top-level scope at /tmp/tmp0a7ot03s.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0a7ot03s.jl:41\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0a7ot03s.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr .== min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp93k18zcu.jl:51\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp93k18zcu.jl:51\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp93k18zcu.jl:50\\ntest set: Test Failed at /tmp/tmp93k18zcu.jl:52\\\
    n  Expression: candidate([1, 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp93k18zcu.jl:52\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp93k18zcu.jl:50\\ntest set: Test Failed at /tmp/tmp93k18zcu.jl:54\\\
    n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n   Evaluated: [0, 2]\
    \ == [0, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp93k18zcu.jl:54\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp93k18zcu.jl:50\\ntest set: Test Failed at /tmp/tmp93k18zcu.jl:55\\\
    n  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\\n   Evaluated: [0, 4]\
    \ == [0, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp93k18zcu.jl:55\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp93k18zcu.jl:50\\ntest set: Test Failed at /tmp/tmp93k18zcu.jl:56\\\
    n  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\\n   Evaluated: [4, 2] ==\
    \ [4, 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp93k18zcu.jl:56\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp93k18zcu.jl:50\\ntest set: Test Failed at /tmp/tmp93k18zcu.jl:57\\\
    n  Expression: candidate([7, 6, 7, 1]) == [6, 1]\\n   Evaluated: [6, 2] == [6,\
    \ 1]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp93k18zcu.jl:57\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp93k18zcu.jl:50\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    evens\
    \ = sort(evens)\n    even = evens[1]\n    index = findfirst(arr, even)\n    return\
    \ [even, index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq5vcxbtp.jl:52\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpq5vcxbtp.jl:44\n   [2] top-level scope at\
    \ /tmp/tmpq5vcxbtp.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq5vcxbtp.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpq5vcxbtp.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq5vcxbtp.jl:44\n   [2] top-level scope at /tmp/tmpq5vcxbtp.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq5vcxbtp.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpq5vcxbtp.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq5vcxbtp.jl:44\n   [2] top-level scope at /tmp/tmpq5vcxbtp.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq5vcxbtp.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpq5vcxbtp.jl:56\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq5vcxbtp.jl:44\n   [2] top-level scope at /tmp/tmpq5vcxbtp.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq5vcxbtp.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpq5vcxbtp.jl:57\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq5vcxbtp.jl:44\n   [2] top-level scope at /tmp/tmpq5vcxbtp.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq5vcxbtp.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpq5vcxbtp.jl:58\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpq5vcxbtp.jl:44\n   [2] top-level scope at /tmp/tmpq5vcxbtp.jl:58\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq5vcxbtp.jl:51\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq5vcxbtp.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpl3ggcuvr.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Array{Int64,1}, ::Int64)\\n  Closest candidates\
    \ are:\\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1776\\n    findfirst(::Any)\
    \ at array.jl:1692\\n  Stacktrace:\\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpl3ggcuvr.jl:43\\\
    n   [2] top-level scope at /tmp/tmpl3ggcuvr.jl:51\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl3ggcuvr.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl3ggcuvr.jl:52\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpl3ggcuvr.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpl3ggcuvr.jl:52\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl3ggcuvr.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl3ggcuvr.jl:54\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpl3ggcuvr.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpl3ggcuvr.jl:54\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl3ggcuvr.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl3ggcuvr.jl:55\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpl3ggcuvr.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpl3ggcuvr.jl:55\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl3ggcuvr.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl3ggcuvr.jl:56\\n  Test threw exception\\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpl3ggcuvr.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpl3ggcuvr.jl:56\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl3ggcuvr.jl:50\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpl3ggcuvr.jl:57\\n  Test threw exception\\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1776\\n    findfirst(::Any) at array.jl:1692\\n  Stacktrace:\\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpl3ggcuvr.jl:43\\n   [2] top-level scope\
    \ at /tmp/tmpl3ggcuvr.jl:57\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpl3ggcuvr.jl:50\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      6      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # if the array is empty, return empty\n    if isempty(arr)\n        return\
    \ []\n    end\n    # find the smallest even value\n    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_values)\n        return []\n    end\n\
    \    smallest_even = minimum(even_values)\n    # find the index of the smallest\
    \ even value\n    smallest_even_index = findfirst(arr, smallest_even)\n    # return\
    \ the smallest even value and its index\n    return [smallest_even, smallest_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8sko259r.jl:55\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp8sko259r.jl:46\n   [2] top-level scope at\
    \ /tmp/tmp8sko259r.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8sko259r.jl:54\n  \ntest set: Error During\
    \ Test at /tmp/tmp8sko259r.jl:56\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8sko259r.jl:46\n   [2] top-level scope at /tmp/tmp8sko259r.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8sko259r.jl:54\n  \ntest set: Error During\
    \ Test at /tmp/tmp8sko259r.jl:58\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8sko259r.jl:46\n   [2] top-level scope at /tmp/tmp8sko259r.jl:58\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8sko259r.jl:54\n  \ntest set: Error During\
    \ Test at /tmp/tmp8sko259r.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8sko259r.jl:46\n   [2] top-level scope at /tmp/tmp8sko259r.jl:59\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8sko259r.jl:54\n  \ntest set: Error During\
    \ Test at /tmp/tmp8sko259r.jl:60\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8sko259r.jl:46\n   [2] top-level scope at /tmp/tmp8sko259r.jl:60\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8sko259r.jl:54\n  \ntest set: Error During\
    \ Test at /tmp/tmp8sko259r.jl:61\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8sko259r.jl:46\n   [2] top-level scope at /tmp/tmp8sko259r.jl:61\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8sko259r.jl:54\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8sko259r.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_values)\n        return []\n    end\n\
    \    min_even_value = minimum(even_values)\n    min_even_value_index = findfirst(arr\
    \ .== min_even_value)\n    return [min_even_value, min_even_value_index]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl4ha90er.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpl4ha90er.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl4ha90er.jl:50\ntest set: Test Failed at /tmp/tmpl4ha90er.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpl4ha90er.jl:52\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl4ha90er.jl:50\ntest set: Test Failed at /tmp/tmpl4ha90er.jl:54\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpl4ha90er.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl4ha90er.jl:50\ntest set: Test Failed at /tmp/tmpl4ha90er.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpl4ha90er.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl4ha90er.jl:50\ntest set: Test Failed at /tmp/tmpl4ha90er.jl:56\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpl4ha90er.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl4ha90er.jl:50\ntest set: Test Failed at /tmp/tmpl4ha90er.jl:57\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpl4ha90er.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl4ha90er.jl:50\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl4ha90er.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp12qszj3z.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp12qszj3z.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp12qszj3z.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12qszj3z.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp12qszj3z.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12qszj3z.jl:43\n   [2] top-level scope at /tmp/tmp12qszj3z.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12qszj3z.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp12qszj3z.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12qszj3z.jl:43\n   [2] top-level scope at /tmp/tmp12qszj3z.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12qszj3z.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp12qszj3z.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12qszj3z.jl:43\n   [2] top-level scope at /tmp/tmp12qszj3z.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12qszj3z.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp12qszj3z.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12qszj3z.jl:43\n   [2] top-level scope at /tmp/tmp12qszj3z.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12qszj3z.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp12qszj3z.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp12qszj3z.jl:43\n   [2] top-level scope at /tmp/tmp12qszj3z.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp12qszj3z.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp12qszj3z.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = [node\
    \ for node in arr if node % 2 == 0]\n    if length(even_nodes) == 0\n        return\
    \ []\n    end\n    min_even_node = minimum(even_nodes)\n    return [min_even_node,\
    \ findall(arr .== min_even_node)[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpnyxvtip9.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpnyxvtip9.jl:50\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnyxvtip9.jl:49\ntest set: Test Failed at /tmp/tmpnyxvtip9.jl:51\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnyxvtip9.jl:51\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnyxvtip9.jl:49\ntest set: Test Failed at /tmp/tmpnyxvtip9.jl:53\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpnyxvtip9.jl:53\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnyxvtip9.jl:49\ntest set: Test Failed at /tmp/tmpnyxvtip9.jl:54\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpnyxvtip9.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnyxvtip9.jl:49\ntest set: Test Failed at /tmp/tmpnyxvtip9.jl:55\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpnyxvtip9.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnyxvtip9.jl:49\ntest set: Test Failed at /tmp/tmpnyxvtip9.jl:56\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpnyxvtip9.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnyxvtip9.jl:49\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnyxvtip9.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if length(even_values) == 0\n        return\
    \ []\n    end\n    min_even_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even_value\n            return [min_even_value, i]\n\
    \        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl199lsx0.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpl199lsx0.jl:59\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl199lsx0.jl:58\ntest set: Test Failed at /tmp/tmpl199lsx0.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpl199lsx0.jl:60\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl199lsx0.jl:58\ntest set: Test Failed at /tmp/tmpl199lsx0.jl:62\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpl199lsx0.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl199lsx0.jl:58\ntest set: Test Failed at /tmp/tmpl199lsx0.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpl199lsx0.jl:63\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl199lsx0.jl:58\ntest set: Test Failed at /tmp/tmpl199lsx0.jl:64\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpl199lsx0.jl:64\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl199lsx0.jl:58\ntest set: Test Failed at /tmp/tmpl199lsx0.jl:65\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpl199lsx0.jl:65\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl199lsx0.jl:58\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl199lsx0.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    return [min_even, findfirst(x -> x == min_even,\
    \ arr)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplyhsvb51.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmplyhsvb51.jl:50\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplyhsvb51.jl:49\ntest set: Test Failed at /tmp/tmplyhsvb51.jl:51\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplyhsvb51.jl:51\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplyhsvb51.jl:49\ntest set: Test Failed at /tmp/tmplyhsvb51.jl:53\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmplyhsvb51.jl:53\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplyhsvb51.jl:49\ntest set: Test Failed at /tmp/tmplyhsvb51.jl:54\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmplyhsvb51.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplyhsvb51.jl:49\ntest set: Test Failed at /tmp/tmplyhsvb51.jl:55\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmplyhsvb51.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplyhsvb51.jl:49\ntest set: Test Failed at /tmp/tmplyhsvb51.jl:56\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmplyhsvb51.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplyhsvb51.jl:49\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplyhsvb51.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even_value =\
    \ Inf\n    min_even_index = Inf\n    for i in 1:length(arr)\n        if arr[i]\
    \ % 2 == 0 && arr[i] < min_even_value\n            min_even_value = arr[i]\n \
    \           min_even_index = i\n        end\n    end\n    if min_even_value ==\
    \ Inf\n        return []\n    end\n    return [min_even_value, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5xf_umc1.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5xf_umc1.jl:56\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5xf_umc1.jl:55\ntest set: Test Failed at /tmp/tmp5xf_umc1.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5xf_umc1.jl:57\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5xf_umc1.jl:55\ntest set: Test Failed at /tmp/tmp5xf_umc1.jl:59\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp5xf_umc1.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5xf_umc1.jl:55\ntest set: Test Failed at /tmp/tmp5xf_umc1.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp5xf_umc1.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5xf_umc1.jl:55\ntest set: Test Failed at /tmp/tmp5xf_umc1.jl:61\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp5xf_umc1.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5xf_umc1.jl:55\ntest set: Test Failed at /tmp/tmp5xf_umc1.jl:62\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp5xf_umc1.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5xf_umc1.jl:55\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5xf_umc1.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_values)\n        return\
    \ []\n    end\n    return sort!(even_values)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpa_e16dwh.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpa_e16dwh.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa_e16dwh.jl:53\ntest set: Test Failed at /tmp/tmpa_e16dwh.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa_e16dwh.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa_e16dwh.jl:53\ntest set: Test Failed at /tmp/tmpa_e16dwh.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpa_e16dwh.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa_e16dwh.jl:53\ntest set: Test Failed at /tmp/tmpa_e16dwh.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpa_e16dwh.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa_e16dwh.jl:53\ntest set: Test Failed at /tmp/tmpa_e16dwh.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpa_e16dwh.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa_e16dwh.jl:53\ntest set: Test Failed at /tmp/tmpa_e16dwh.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpa_e16dwh.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa_e16dwh.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa_e16dwh.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpi0exm0d2.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpi0exm0d2.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpi0exm0d2.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0exm0d2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0exm0d2.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0exm0d2.jl:43\n   [2] top-level scope at /tmp/tmpi0exm0d2.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0exm0d2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0exm0d2.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0exm0d2.jl:43\n   [2] top-level scope at /tmp/tmpi0exm0d2.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0exm0d2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0exm0d2.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0exm0d2.jl:43\n   [2] top-level scope at /tmp/tmpi0exm0d2.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0exm0d2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0exm0d2.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0exm0d2.jl:43\n   [2] top-level scope at /tmp/tmpi0exm0d2.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0exm0d2.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpi0exm0d2.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpi0exm0d2.jl:43\n   [2] top-level scope at /tmp/tmpi0exm0d2.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi0exm0d2.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi0exm0d2.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp97ihcphh.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp97ihcphh.jl:55\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp97ihcphh.jl:54\ntest set: Test Failed at /tmp/tmp97ihcphh.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp97ihcphh.jl:56\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp97ihcphh.jl:54\ntest set: Test Failed at /tmp/tmp97ihcphh.jl:58\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp97ihcphh.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp97ihcphh.jl:54\ntest set: Test Failed at /tmp/tmp97ihcphh.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp97ihcphh.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp97ihcphh.jl:54\ntest set: Test Failed at /tmp/tmp97ihcphh.jl:60\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp97ihcphh.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp97ihcphh.jl:54\ntest set: Test Failed at /tmp/tmp97ihcphh.jl:61\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp97ihcphh.jl:61\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp97ihcphh.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp97ihcphh.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if iseven(arr[i])]\n    if isempty(evens)\n        return []\n\
    \    end\n    min_even = minimum(evens)\n    min_even_index = findall(arr .==\
    \ min_even)[1]\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpqyrm5ydq.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpqyrm5ydq.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqyrm5ydq.jl:50\ntest set: Test Failed at /tmp/tmpqyrm5ydq.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqyrm5ydq.jl:52\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqyrm5ydq.jl:50\ntest set: Test Failed at /tmp/tmpqyrm5ydq.jl:54\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpqyrm5ydq.jl:54\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqyrm5ydq.jl:50\ntest set: Test Failed at /tmp/tmpqyrm5ydq.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpqyrm5ydq.jl:55\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqyrm5ydq.jl:50\ntest set: Test Failed at /tmp/tmpqyrm5ydq.jl:56\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpqyrm5ydq.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqyrm5ydq.jl:50\ntest set: Test Failed at /tmp/tmpqyrm5ydq.jl:57\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpqyrm5ydq.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqyrm5ydq.jl:50\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqyrm5ydq.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = []\n    for\
    \ (i, num) in enumerate(arr)\n        if num % 2 == 0\n            push!(even_nums,\
    \ [num, i])\n        end\n    end\n    if isempty(even_nums)\n        return []\n\
    \    end\n    return sort!(even_nums)[1]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp4629rblq.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4629rblq.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4629rblq.jl:53\ntest set: Test Failed at /tmp/tmp4629rblq.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4629rblq.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4629rblq.jl:53\ntest set: Test Failed at /tmp/tmp4629rblq.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4629rblq.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4629rblq.jl:53\ntest set: Test Failed at /tmp/tmp4629rblq.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp4629rblq.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4629rblq.jl:53\ntest set: Test Failed at /tmp/tmp4629rblq.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4629rblq.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4629rblq.jl:53\ntest set: Test Failed at /tmp/tmp4629rblq.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp4629rblq.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4629rblq.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4629rblq.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpm0y8ksl6.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpm0y8ksl6.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpm0y8ksl6.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm0y8ksl6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm0y8ksl6.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm0y8ksl6.jl:43\n   [2] top-level scope at /tmp/tmpm0y8ksl6.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm0y8ksl6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm0y8ksl6.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm0y8ksl6.jl:43\n   [2] top-level scope at /tmp/tmpm0y8ksl6.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm0y8ksl6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm0y8ksl6.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm0y8ksl6.jl:43\n   [2] top-level scope at /tmp/tmpm0y8ksl6.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm0y8ksl6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm0y8ksl6.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm0y8ksl6.jl:43\n   [2] top-level scope at /tmp/tmpm0y8ksl6.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm0y8ksl6.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpm0y8ksl6.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpm0y8ksl6.jl:43\n   [2] top-level scope at /tmp/tmpm0y8ksl6.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm0y8ksl6.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm0y8ksl6.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg21hl7tj.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpg21hl7tj.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpg21hl7tj.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg21hl7tj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg21hl7tj.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg21hl7tj.jl:43\n   [2] top-level scope at /tmp/tmpg21hl7tj.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg21hl7tj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg21hl7tj.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg21hl7tj.jl:43\n   [2] top-level scope at /tmp/tmpg21hl7tj.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg21hl7tj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg21hl7tj.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg21hl7tj.jl:43\n   [2] top-level scope at /tmp/tmpg21hl7tj.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg21hl7tj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg21hl7tj.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg21hl7tj.jl:43\n   [2] top-level scope at /tmp/tmpg21hl7tj.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg21hl7tj.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpg21hl7tj.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpg21hl7tj.jl:43\n   [2] top-level scope at /tmp/tmpg21hl7tj.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg21hl7tj.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg21hl7tj.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [x for x\
    \ in arr if x % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    return [min_even, findfirst(arr, min_even)[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp150troed.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp150troed.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp150troed.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp150troed.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp150troed.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp150troed.jl:43\n   [2] top-level scope at /tmp/tmp150troed.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp150troed.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp150troed.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp150troed.jl:43\n   [2] top-level scope at /tmp/tmp150troed.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp150troed.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp150troed.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp150troed.jl:43\n   [2] top-level scope at /tmp/tmp150troed.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp150troed.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp150troed.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp150troed.jl:43\n   [2] top-level scope at /tmp/tmp150troed.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp150troed.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp150troed.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp150troed.jl:43\n   [2] top-level scope at /tmp/tmp150troed.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp150troed.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp150troed.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v,\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpk4sf_jkp.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpk4sf_jkp.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4sf_jkp.jl:53\ntest set: Test Failed at /tmp/tmpk4sf_jkp.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpk4sf_jkp.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4sf_jkp.jl:53\ntest set: Test Failed at /tmp/tmpk4sf_jkp.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk4sf_jkp.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4sf_jkp.jl:53\ntest set: Test Failed at /tmp/tmpk4sf_jkp.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpk4sf_jkp.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4sf_jkp.jl:53\ntest set: Test Failed at /tmp/tmpk4sf_jkp.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk4sf_jkp.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4sf_jkp.jl:53\ntest set: Test Failed at /tmp/tmpk4sf_jkp.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpk4sf_jkp.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4sf_jkp.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk4sf_jkp.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_idx = findfirst(arr .== min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv08i078v.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpv08i078v.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv08i078v.jl:46\ntest set: Test Failed at /tmp/tmpv08i078v.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpv08i078v.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv08i078v.jl:46\ntest set: Test Failed at /tmp/tmpv08i078v.jl:50\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpv08i078v.jl:50\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv08i078v.jl:46\ntest set: Test Failed at /tmp/tmpv08i078v.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpv08i078v.jl:51\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv08i078v.jl:46\ntest set: Test Failed at /tmp/tmpv08i078v.jl:52\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpv08i078v.jl:52\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv08i078v.jl:46\ntest set: Test Failed at /tmp/tmpv08i078v.jl:53\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpv08i078v.jl:53\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv08i078v.jl:46\ntest set: Error During Test at\
    \ /tmp/tmpv08i078v.jl:54\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  ArgumentError: reducing over an empty collection\
    \ is not allowed\n  Stacktrace:\n   [1] _empty_reduce_error() at ./reduce.jl:295\n\
    \   [2] reduce_empty(::Function, ::Type{T} where T) at ./reduce.jl:305\n   [3]\
    \ mapreduce_empty(::typeof(identity), ::Function, ::Type{T} where T) at ./reduce.jl:335\n\
    \   [4] _mapreduce at ./reduce.jl:392 [inlined]\n   [5] _mapreduce_dim at ./reducedim.jl:312\
    \ [inlined]\n   [6] #mapreduce#580 at ./reducedim.jl:307 [inlined]\n   [7] mapreduce\
    \ at ./reducedim.jl:307 [inlined]\n   [8] _minimum at ./reducedim.jl:657 [inlined]\n\
    \   [9] _minimum at ./reducedim.jl:656 [inlined]\n   [10] #minimum#589 at ./reducedim.jl:652\
    \ [inlined]\n   [11] minimum at ./reducedim.jl:652 [inlined]\n   [12] pluck(::Array{Int64,1})\
    \ at /tmp/tmpv08i078v.jl:38\n   [13] top-level scope at /tmp/tmpv08i078v.jl:54\n\
    \   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [15] top-level scope at /tmp/tmpv08i078v.jl:46\n  \nTest Summary: | Pass \
    \ Fail  Error  Total\ntest set      |    1     6      1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv08i078v.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [x for x\
    \ in arr if x % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8b7k1nfm.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp8b7k1nfm.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp8b7k1nfm.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b7k1nfm.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp8b7k1nfm.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8b7k1nfm.jl:43\n   [2] top-level scope at /tmp/tmp8b7k1nfm.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b7k1nfm.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp8b7k1nfm.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8b7k1nfm.jl:43\n   [2] top-level scope at /tmp/tmp8b7k1nfm.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b7k1nfm.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp8b7k1nfm.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8b7k1nfm.jl:43\n   [2] top-level scope at /tmp/tmp8b7k1nfm.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b7k1nfm.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp8b7k1nfm.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8b7k1nfm.jl:43\n   [2] top-level scope at /tmp/tmp8b7k1nfm.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b7k1nfm.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp8b7k1nfm.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp8b7k1nfm.jl:43\n   [2] top-level scope at /tmp/tmp8b7k1nfm.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b7k1nfm.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8b7k1nfm.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9udewxhy.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp9udewxhy.jl:43\n   [2] top-level scope at\
    \ /tmp/tmp9udewxhy.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9udewxhy.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp9udewxhy.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9udewxhy.jl:43\n   [2] top-level scope at /tmp/tmp9udewxhy.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9udewxhy.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp9udewxhy.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9udewxhy.jl:43\n   [2] top-level scope at /tmp/tmp9udewxhy.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9udewxhy.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp9udewxhy.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9udewxhy.jl:43\n   [2] top-level scope at /tmp/tmp9udewxhy.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9udewxhy.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp9udewxhy.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9udewxhy.jl:43\n   [2] top-level scope at /tmp/tmp9udewxhy.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9udewxhy.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmp9udewxhy.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmp9udewxhy.jl:43\n   [2] top-level scope at /tmp/tmp9udewxhy.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9udewxhy.jl:49\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9udewxhy.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpo2e6yu7p.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString,\
    \ AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at\
    \ array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpo2e6yu7p.jl:43\n   [2] top-level scope at\
    \ /tmp/tmpo2e6yu7p.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo2e6yu7p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpo2e6yu7p.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpo2e6yu7p.jl:43\n   [2] top-level scope at /tmp/tmpo2e6yu7p.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo2e6yu7p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpo2e6yu7p.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpo2e6yu7p.jl:43\n   [2] top-level scope at /tmp/tmpo2e6yu7p.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo2e6yu7p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpo2e6yu7p.jl:55\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpo2e6yu7p.jl:43\n   [2] top-level scope at /tmp/tmpo2e6yu7p.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo2e6yu7p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpo2e6yu7p.jl:56\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpo2e6yu7p.jl:43\n   [2] top-level scope at /tmp/tmpo2e6yu7p.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo2e6yu7p.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpo2e6yu7p.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching findfirst(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(::Union{AbstractString, AbstractArray})\
    \ at array.jl:1701\n    findfirst(!Matched::Function, ::Any) at array.jl:1776\n\
    \    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n   [1] pluck(::Array{Int64,1})\
    \ at /tmp/tmpo2e6yu7p.jl:43\n   [2] top-level scope at /tmp/tmpo2e6yu7p.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo2e6yu7p.jl:50\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo2e6yu7p.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = []\n \
    \   for i in arr\n        if i % 2 == 0\n            push!(even_arr, i)\n    \
    \    end\n    end\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq8b23s1v.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpq8b23s1v.jl:59\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq8b23s1v.jl:58\ntest set: Test Failed at /tmp/tmpq8b23s1v.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpq8b23s1v.jl:60\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq8b23s1v.jl:58\ntest set: Test Failed at /tmp/tmpq8b23s1v.jl:62\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpq8b23s1v.jl:62\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq8b23s1v.jl:58\ntest set: Test Failed at /tmp/tmpq8b23s1v.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpq8b23s1v.jl:63\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq8b23s1v.jl:58\ntest set: Test Failed at /tmp/tmpq8b23s1v.jl:64\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpq8b23s1v.jl:64\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq8b23s1v.jl:58\ntest set: Test Failed at /tmp/tmpq8b23s1v.jl:65\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [6, 2] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpq8b23s1v.jl:65\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq8b23s1v.jl:58\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq8b23s1v.jl:56\n"
  exit_code: 1
  status: SyntaxError
