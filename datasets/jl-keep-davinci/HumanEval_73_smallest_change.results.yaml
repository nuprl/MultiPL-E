name: HumanEval_73_smallest_change
language: julia
results:
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf9iqofnr.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpf9iqofnr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr7l44yza.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr7l44yza.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpttfoct7x.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpttfoct7x.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpttfoct7x.jl:19\ntest set: Test Failed at /tmp/tmpttfoct7x.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpttfoct7x.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpttfoct7x.jl:19\ntest set: Test Failed at /tmp/tmpttfoct7x.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpttfoct7x.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpttfoct7x.jl:19\ntest set: Test Failed at /tmp/tmpttfoct7x.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpttfoct7x.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpttfoct7x.jl:19\ntest set: Test Failed at /tmp/tmpttfoct7x.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpttfoct7x.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpttfoct7x.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpttfoct7x.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    if length(arr) == 0\n     \
    \   return 0\n    end\n    if length(arr) == 1\n        return 0\n    end\n  \
    \  if length(arr) == 2\n        return abs(arr[1] - arr[2])\n    end\n    if length(arr)\
    \ == 3\n        return abs(arr[1] - arr[3])\n    end\n    if length(arr) == 4\n\
    \        return abs(arr[1] - arr[4])\n    end\n    if length(arr) == 5\n     \
    \   return abs(arr[1] - arr[5])\n    end\n    if length(arr) == 6\n        return\
    \ abs(arr[1] - arr[6])\n    end\n    if length(arr) == 7\n        return abs(arr[1]\
    \ - arr[7])\n    end\n    if length(arr) == 8\n        return abs(arr[1] - arr[8])\n\
    \    end\n    if length(arr) == 9\n        return abs(arr[1] - arr[9])\n    end\n\
    \    if length(arr) == 10\n        return abs(arr[1] - arr[10])\n    end\n   \
    \ if length(arr) == 11\n        return abs(arr[1] - arr[11])\n    end\n    if\
    \ length(arr) == 12\n        return abs(arr[1] - arr[12])\n    end\n    if length(arr)\
    \ == 13\n        return abs(arr[1] - arr[13])\n    end\n    if length(arr) ==\
    \ 14\n        return abs(arr[1] - arr[14])\n    end\n    if length(arr) == 15\n\
    \        return abs(arr[1] - arr[15])\n    end\n    if length(arr) == 16\n   \
    \     return abs(arr[1] - arr[16])\n    end\n    if length(arr) == 17\n      \
    \  return abs(arr[1] - arr[17])\n    end\n    if length(arr) == 18\n        return\
    \ abs(arr[1] - arr[18])\n    end\n    if length(arr) == 19\n        return abs(arr[1]\
    \ - arr[19])\n    end\n    if length(arr) == 20\n        return\nusing Test\n\n\
    @testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5,\
    \ 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpavy99u9q.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpavy99u9q.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return arr[1] == arr[2]\
    \ ? 0 : 1\n    end\n    if n == 3\n        return arr[1] == arr[3] ? 0 : 1\n \
    \   end\n    if n == 4\n        return arr[1] == arr[4] && arr[2] == arr[3] ?\
    \ 0 : 1\n    end\n    if n == 5\n        return arr[1] == arr[5] && arr[2] ==\
    \ arr[4] ? 0 : 1\n    end\n    if n == 6\n        return arr[1] == arr[6] && arr[2]\
    \ == arr[5] && arr[3] == arr[4] ? 0 : 1\n    end\n    if n == 7\n        return\
    \ arr[1] == arr[7] && arr[2] == arr[6] && arr[3] == arr[5] ? 0 : 1\n    end\n\
    \    if n == 8\n        return arr[1] == arr[8] && arr[2] == arr[7] && arr[3]\
    \ == arr[6] && arr[4] == arr[5] ? 0 : 1\n    end\n    if n == 9\n        return\
    \ arr[1] == arr[9] && arr[2] == arr[8] && arr[3] == arr[7] && arr[4] == arr[6]\
    \ ? 0 : 1\n    end\n    if n == 10\n        return arr[1] == arr[10] && arr[2]\
    \ == arr[9] && arr[3] == arr[8] && arr[4] == arr[7] && arr[5] == arr[6] ? 0 :\
    \ 1\n    end\n    if n == 11\n        return arr[1] == arr[11] && arr[2] == arr[10]\
    \ && arr[3] == arr[9] && arr[4] == arr[8] && arr[5] == arr[7] ? 0 : 1\n    end\n\
    \    if n == 12\n        return arr[1] == arr[12] && arr[2] == arr[11] && arr[3]\
    \ == arr[10] && arr[\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7dycqbco.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7dycqbco.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if arr[1] == arr[end]\n        return smallest_change(arr[2:end-1])\n    else\n\
    \        return 1 + min(smallest_change(arr[2:end]), smallest_change(arr[1:end-1]))\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t\
    @test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1us_vm7g.jl:30\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 7 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp1us_vm7g.jl:30\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1us_vm7g.jl:29\ntest set: Test Failed at /tmp/tmp1us_vm7g.jl:31\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1us_vm7g.jl:31\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1us_vm7g.jl:29\ntest set: Test Failed at /tmp/tmp1us_vm7g.jl:32\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1us_vm7g.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1us_vm7g.jl:29\ntest set: Test Failed at /tmp/tmp1us_vm7g.jl:33\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 3 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1us_vm7g.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1us_vm7g.jl:29\ntest set: Test Failed at /tmp/tmp1us_vm7g.jl:35\n\
    \  Expression: candidate([3, 1, 1, 3]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1us_vm7g.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1us_vm7g.jl:29\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1us_vm7g.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl8lhiluy.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpl8lhiluy.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl8lhiluy.jl:19\ntest set: Test Failed at /tmp/tmpl8lhiluy.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl8lhiluy.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl8lhiluy.jl:19\ntest set: Test Failed at /tmp/tmpl8lhiluy.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl8lhiluy.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl8lhiluy.jl:19\ntest set: Test Failed at /tmp/tmpl8lhiluy.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl8lhiluy.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl8lhiluy.jl:19\ntest set: Test Failed at /tmp/tmpl8lhiluy.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpl8lhiluy.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl8lhiluy.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl8lhiluy.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi7h0w5um.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi7h0w5um.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl_a07dfb.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpl_a07dfb.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl_a07dfb.jl:19\ntest set: Test Failed at /tmp/tmpl_a07dfb.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl_a07dfb.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl_a07dfb.jl:19\ntest set: Test Failed at /tmp/tmpl_a07dfb.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl_a07dfb.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl_a07dfb.jl:19\ntest set: Test Failed at /tmp/tmpl_a07dfb.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl_a07dfb.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl_a07dfb.jl:19\ntest set: Test Failed at /tmp/tmpl_a07dfb.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpl_a07dfb.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl_a07dfb.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl_a07dfb.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp7zvc17w.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpp7zvc17w.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7uroro4m.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7uroro4m.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuhxsvlhp.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuhxsvlhp.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n % 2 == 0\n        return smallest_change_even(arr)\n\
    \    else\n        return smallest_change_odd(arr)\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6ubacyq1.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  UndefVarError: smallest_change_even\
    \ not defined\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp6ubacyq1.jl:17\n\
    \   [2] top-level scope at /tmp/tmp6ubacyq1.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ubacyq1.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ubacyq1.jl:28\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  UndefVarError: smallest_change_odd not defined\n\
    \  Stacktrace:\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp6ubacyq1.jl:19\n\
    \   [2] top-level scope at /tmp/tmp6ubacyq1.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ubacyq1.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ubacyq1.jl:29\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  UndefVarError: smallest_change_odd not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp6ubacyq1.jl:19\n   [2] top-level\
    \ scope at /tmp/tmp6ubacyq1.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ubacyq1.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ubacyq1.jl:30\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  UndefVarError: smallest_change_even not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp6ubacyq1.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp6ubacyq1.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ubacyq1.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ubacyq1.jl:31\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  UndefVarError: smallest_change_odd not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp6ubacyq1.jl:19\n   [2] top-level\
    \ scope at /tmp/tmp6ubacyq1.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ubacyq1.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ubacyq1.jl:32\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  UndefVarError: smallest_change_even not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp6ubacyq1.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp6ubacyq1.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ubacyq1.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ubacyq1.jl:34\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  UndefVarError: smallest_change_even not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp6ubacyq1.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp6ubacyq1.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6ubacyq1.jl:26\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      7      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ubacyq1.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbnse9g4l.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpbnse9g4l.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpbnse9g4l.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbnse9g4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpbnse9g4l.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpbnse9g4l.jl:13\n   [2] top-level scope at /tmp/tmpbnse9g4l.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbnse9g4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpbnse9g4l.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpbnse9g4l.jl:13\n   [2] top-level scope at /tmp/tmpbnse9g4l.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbnse9g4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpbnse9g4l.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpbnse9g4l.jl:13\n   [2] top-level scope at /tmp/tmpbnse9g4l.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbnse9g4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpbnse9g4l.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpbnse9g4l.jl:13\n   [2] top-level scope at /tmp/tmpbnse9g4l.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbnse9g4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpbnse9g4l.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpbnse9g4l.jl:13\n   [2] top-level scope at /tmp/tmpbnse9g4l.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbnse9g4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpbnse9g4l.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpbnse9g4l.jl:13\n   [2] top-level scope at /tmp/tmpbnse9g4l.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbnse9g4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpbnse9g4l.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpbnse9g4l.jl:13\n   [2] top-level scope at /tmp/tmpbnse9g4l.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbnse9g4l.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbnse9g4l.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]))\n    end\n    if n == 4\n        return min(abs(arr[1] - arr[2]), abs(arr[3]\
    \ - arr[4]))\n    end\n    if n == 5\n        return min(abs(arr[1] - arr[2]),\
    \ abs(arr[3] - arr[4]), abs(arr[4] - arr[5]))\n    end\n    if n == 6\n      \
    \  return min(abs(arr[1] - arr[2]), abs(arr[3] - arr[4]), abs(arr[5] - arr[6]))\n\
    \    end\n    if n == 7\n        return min(abs(arr[1] - arr[2]), abs(arr[3] -\
    \ arr[4]), abs(arr[5] - arr[6]), abs(arr[6] - arr[7]))\n    end\n    if n == 8\n\
    \        return min(abs(arr[1] - arr[2]), abs(arr[3] - arr[4]), abs(arr[5] - arr[6]),\
    \ abs(arr[7] - arr[8]))\n    end\n    if n == 9\n        return min(abs(arr[1]\
    \ - arr[2]), abs(arr[3] - arr[4]), abs(arr[5] - arr[6]), abs(arr[7] - arr[8]),\
    \ abs(arr[8] - arr[9]))\n    end\n    if n == 10\n        return min(abs(arr[1]\
    \ - arr[2]), abs(arr[3] - arr[4]), abs(arr[5] - arr[6]), abs(arr[7] - arr[8]),\
    \ abs(arr[9] - arr[10]))\n    end\n    if n == 11\n        return min(abs(arr[1]\
    \ - arr[2]), abs(arr[3] - arr[4]), abs(arr[5] -\nusing Test\n\n@testset begin\n\
    \ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) ==\
    \ 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4,\
    \ 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3,\
    \ 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi1qam4bw.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi1qam4bw.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp84ld_ja8.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp84ld_ja8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbdgt9v7u.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbdgt9v7u.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdgt9v7u.jl:19\ntest set: Test Failed at /tmp/tmpbdgt9v7u.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbdgt9v7u.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdgt9v7u.jl:19\ntest set: Test Failed at /tmp/tmpbdgt9v7u.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbdgt9v7u.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdgt9v7u.jl:19\ntest set: Test Failed at /tmp/tmpbdgt9v7u.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbdgt9v7u.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdgt9v7u.jl:19\ntest set: Test Failed at /tmp/tmpbdgt9v7u.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpbdgt9v7u.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdgt9v7u.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbdgt9v7u.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcfn0kfo_.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcfn0kfo_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for l in 2:n\n \
    \       for i in 1:n-l+1\n            j = i+l-1\n            if arr[i] == arr[j]\n\
    \                dp[i, j] = dp[i+1, j-1]\n            else\n                dp[i,\
    \ j] = min(dp[i+1, j], dp[i, j-1]) + 1\n            end\n        end\n    end\n\
    \    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmphd57t3b6.jl:34\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 7 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmphd57t3b6.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphd57t3b6.jl:33\\ntest set: Test Failed at /tmp/tmphd57t3b6.jl:35\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 2 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmphd57t3b6.jl:35\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphd57t3b6.jl:33\\ntest set: Test Failed at /tmp/tmphd57t3b6.jl:36\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 2 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmphd57t3b6.jl:36\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphd57t3b6.jl:33\\ntest set: Test Failed at /tmp/tmphd57t3b6.jl:37\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 2 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmphd57t3b6.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphd57t3b6.jl:33\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     4      8\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg8db6ojv.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpg8db6ojv.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpg8db6ojv.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg8db6ojv.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpg8db6ojv.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg8db6ojv.jl:13\n   [2] top-level scope at /tmp/tmpg8db6ojv.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg8db6ojv.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpg8db6ojv.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg8db6ojv.jl:13\n   [2] top-level scope at /tmp/tmpg8db6ojv.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg8db6ojv.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpg8db6ojv.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg8db6ojv.jl:13\n   [2] top-level scope at /tmp/tmpg8db6ojv.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg8db6ojv.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpg8db6ojv.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg8db6ojv.jl:13\n   [2] top-level scope at /tmp/tmpg8db6ojv.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg8db6ojv.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpg8db6ojv.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg8db6ojv.jl:13\n   [2] top-level scope at /tmp/tmpg8db6ojv.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg8db6ojv.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpg8db6ojv.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg8db6ojv.jl:13\n   [2] top-level scope at /tmp/tmpg8db6ojv.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg8db6ojv.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpg8db6ojv.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg8db6ojv.jl:13\n   [2] top-level scope at /tmp/tmpg8db6ojv.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg8db6ojv.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg8db6ojv.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6r9x0spf.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6r9x0spf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for l in 2:n\n \
    \       for i in 1:n-l+1\n            j = i+l-1\n            if arr[i] == arr[j]\n\
    \                dp[i, j] = dp[i+1, j-1]\n            else\n                dp[i,\
    \ j] = min(dp[i+1, j], dp[i, j-1]) + 1\n            end\n        end\n    end\n\
    \    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvolr7ed9.jl:34\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 7 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpvolr7ed9.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvolr7ed9.jl:33\ntest set: Test Failed at /tmp/tmpvolr7ed9.jl:35\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvolr7ed9.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvolr7ed9.jl:33\ntest set: Test Failed at /tmp/tmpvolr7ed9.jl:36\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvolr7ed9.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvolr7ed9.jl:33\ntest set: Test Failed at /tmp/tmpvolr7ed9.jl:37\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvolr7ed9.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvolr7ed9.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     4      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvolr7ed9.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_xc3rk24.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp_xc3rk24.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xc3rk24.jl:19\\ntest set: Test Failed at /tmp/tmp_xc3rk24.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_xc3rk24.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xc3rk24.jl:19\\ntest set: Test Failed at /tmp/tmp_xc3rk24.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp_xc3rk24.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xc3rk24.jl:19\\ntest set: Test Failed at /tmp/tmp_xc3rk24.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp_xc3rk24.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xc3rk24.jl:19\\ntest set: Test Failed at /tmp/tmp_xc3rk24.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp_xc3rk24.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xc3rk24.jl:19\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_249llxb.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_249llxb.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7ghvevnj.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7ghvevnj.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]))\n    end\n    if n == 4\n        return min(abs(arr[1] - arr[2]), abs(arr[2]\
    \ - arr[3]), abs(arr[3] - arr[4]))\n    end\n    if n == 5\n        return min(abs(arr[1]\
    \ - arr[2]), abs(arr[2] - arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]))\n\
    \    end\n    if n == 6\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]))\n\
    \    end\n    if n == 7\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]), abs(arr[6]\
    \ - arr[7]))\n    end\n    if n == 8\n        return min(abs(arr[1] - arr[2]),\
    \ abs(arr[2] - arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5]\
    \ - arr[6]), abs(arr[6] - arr[7]), abs(arr[7] - arr[8]))\n    end\n    if n ==\
    \ 9\n        return min(abs(arr[1] - arr[2]), abs(arr[2] - arr[3]), abs(arr[3]\
    \ - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]), abs(arr[6] - arr[7]),\
    \ abs(arr[\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0oyym7tn.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0oyym7tn.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for i in 1:n-1\n\
    \        dp[i, i+1] = abs(arr[i] - arr[i+1])\n    end\n    for i in 1:n-2\n  \
    \      dp[i, i+2] = abs(arr[i] - arr[i+2])\n    end\n    for i in 3:n\n      \
    \  for j in 1:n-i\n            dp[j, j+i] = min(dp[j+1, j+i] + abs(arr[j] - arr[j+i]),\
    \ dp[j, j+i-1] + abs(arr[j] - arr[j+i]))\n        end\n    end\n    return dp[1,\
    \ n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp08d3cua.jl:35\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 16 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpp08d3cua.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp08d3cua.jl:34\ntest set: Test Failed at /tmp/tmpp08d3cua.jl:36\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp08d3cua.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp08d3cua.jl:34\ntest set: Test Failed at /tmp/tmpp08d3cua.jl:38\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 3 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp08d3cua.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp08d3cua.jl:34\ntest set: Test Failed at /tmp/tmpp08d3cua.jl:39\n\
    \  Expression: candidate([1, 2, 3, 2, 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp08d3cua.jl:39\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp08d3cua.jl:34\ntest set: Test Failed at /tmp/tmpp08d3cua.jl:40\n\
    \  Expression: candidate([3, 1, 1, 3]) == 0\n   Evaluated: 2 == 0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp08d3cua.jl:40\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp08d3cua.jl:34\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp08d3cua.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuf7cuife.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuf7cuife.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1fbjx077.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1fbjx077.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp94q6iw4c.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp94q6iw4c.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpccde3tj6.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpccde3tj6.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpccde3tj6.jl:19\ntest set: Test Failed at /tmp/tmpccde3tj6.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpccde3tj6.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpccde3tj6.jl:19\ntest set: Test Failed at /tmp/tmpccde3tj6.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpccde3tj6.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpccde3tj6.jl:19\ntest set: Test Failed at /tmp/tmpccde3tj6.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpccde3tj6.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpccde3tj6.jl:19\ntest set: Test Failed at /tmp/tmpccde3tj6.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpccde3tj6.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpccde3tj6.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpccde3tj6.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuckgoa0x.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpuckgoa0x.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuckgoa0x.jl:19\ntest set: Test Failed at /tmp/tmpuckgoa0x.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuckgoa0x.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuckgoa0x.jl:19\ntest set: Test Failed at /tmp/tmpuckgoa0x.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuckgoa0x.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuckgoa0x.jl:19\ntest set: Test Failed at /tmp/tmpuckgoa0x.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuckgoa0x.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuckgoa0x.jl:19\ntest set: Test Failed at /tmp/tmpuckgoa0x.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpuckgoa0x.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuckgoa0x.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuckgoa0x.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp13bnnj35.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp13bnnj35.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpitkc2c32.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpitkc2c32.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpitkc2c32.jl:19\\ntest set: Test Failed at /tmp/tmpitkc2c32.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpitkc2c32.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpitkc2c32.jl:19\\ntest set: Test Failed at /tmp/tmpitkc2c32.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpitkc2c32.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpitkc2c32.jl:19\\ntest set: Test Failed at /tmp/tmpitkc2c32.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpitkc2c32.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpitkc2c32.jl:19\\ntest set: Test Failed at /tmp/tmpitkc2c32.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpitkc2c32.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpitkc2c32.jl:19\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqd8hwg5s.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqd8hwg5s.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i = 1:n\n        dp[i, i] = 0\n    end\n    for i = 1:n-1\n \
    \       dp[i, i+1] = arr[i] == arr[i+1] ? 0 : 1\n    end\n    for i = 3:n\n  \
    \      for j = 1:n-i+1\n            dp[j, j+i-1] = arr[j] == arr[j+i-1] ? dp[j+1,\
    \ j+i-2] : 1 + min(dp[j+1, j+i-1], dp[j, j+i-2])\n        end\n    end\n    return\
    \ dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprcpfb86x.jl:32\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 7 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmprcpfb86x.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprcpfb86x.jl:31\ntest set: Test Failed at /tmp/tmprcpfb86x.jl:33\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprcpfb86x.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprcpfb86x.jl:31\ntest set: Test Failed at /tmp/tmprcpfb86x.jl:34\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprcpfb86x.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprcpfb86x.jl:31\ntest set: Test Failed at /tmp/tmprcpfb86x.jl:35\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprcpfb86x.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprcpfb86x.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     4      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprcpfb86x.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpijl5clob.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpijl5clob.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3km97cn3.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3km97cn3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for l in 2:n\n \
    \       for i in 1:n-l+1\n            j = i+l-1\n            if arr[i] == arr[j]\n\
    \                dp[i, j] = dp[i+1, j-1]\n            else\n                dp[i,\
    \ j] = min(dp[i+1, j], dp[i, j-1]) + 1\n            end\n        end\n    end\n\
    \    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpag7hi0uw.jl:34\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 7 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpag7hi0uw.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpag7hi0uw.jl:33\ntest set: Test Failed at /tmp/tmpag7hi0uw.jl:35\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpag7hi0uw.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpag7hi0uw.jl:33\ntest set: Test Failed at /tmp/tmpag7hi0uw.jl:36\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpag7hi0uw.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpag7hi0uw.jl:33\ntest set: Test Failed at /tmp/tmpag7hi0uw.jl:37\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpag7hi0uw.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpag7hi0uw.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     4      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpag7hi0uw.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe5p62zsy.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe5p62zsy.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_ialjxmv.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_ialjxmv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuxlel57g.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuxlel57g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpudx0o0my.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpudx0o0my.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpudx0o0my.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpudx0o0my.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpudx0o0my.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpudx0o0my.jl:13\n   [2] top-level scope at /tmp/tmpudx0o0my.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpudx0o0my.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpudx0o0my.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpudx0o0my.jl:13\n   [2] top-level scope at /tmp/tmpudx0o0my.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpudx0o0my.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpudx0o0my.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpudx0o0my.jl:13\n   [2] top-level scope at /tmp/tmpudx0o0my.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpudx0o0my.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpudx0o0my.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpudx0o0my.jl:13\n   [2] top-level scope at /tmp/tmpudx0o0my.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpudx0o0my.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpudx0o0my.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpudx0o0my.jl:13\n   [2] top-level scope at /tmp/tmpudx0o0my.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpudx0o0my.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpudx0o0my.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpudx0o0my.jl:13\n   [2] top-level scope at /tmp/tmpudx0o0my.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpudx0o0my.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpudx0o0my.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpudx0o0my.jl:13\n   [2] top-level scope at /tmp/tmpudx0o0my.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpudx0o0my.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpudx0o0my.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk9dni280.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk9dni280.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4hee02kt.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4hee02kt.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hee02kt.jl:19\ntest set: Test Failed at /tmp/tmp4hee02kt.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4hee02kt.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hee02kt.jl:19\ntest set: Test Failed at /tmp/tmp4hee02kt.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4hee02kt.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hee02kt.jl:19\ntest set: Test Failed at /tmp/tmp4hee02kt.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4hee02kt.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hee02kt.jl:19\ntest set: Test Failed at /tmp/tmp4hee02kt.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp4hee02kt.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hee02kt.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4hee02kt.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3zoh2nif.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmp3zoh2nif.jl:13\n   [2] top-level\
    \ scope at /tmp/tmp3zoh2nif.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3zoh2nif.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3zoh2nif.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmp3zoh2nif.jl:13\n   [2] top-level scope at /tmp/tmp3zoh2nif.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3zoh2nif.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3zoh2nif.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmp3zoh2nif.jl:13\n   [2] top-level scope at /tmp/tmp3zoh2nif.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3zoh2nif.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3zoh2nif.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmp3zoh2nif.jl:13\n   [2] top-level scope at /tmp/tmp3zoh2nif.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3zoh2nif.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3zoh2nif.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmp3zoh2nif.jl:13\n   [2] top-level scope at /tmp/tmp3zoh2nif.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3zoh2nif.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3zoh2nif.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmp3zoh2nif.jl:13\n   [2] top-level scope at /tmp/tmp3zoh2nif.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3zoh2nif.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3zoh2nif.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmp3zoh2nif.jl:13\n   [2] top-level scope at /tmp/tmp3zoh2nif.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3zoh2nif.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3zoh2nif.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmp3zoh2nif.jl:13\n   [2] top-level scope at /tmp/tmp3zoh2nif.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3zoh2nif.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3zoh2nif.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp80_2smxp.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp80_2smxp.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgq0pv3m8.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpgq0pv3m8.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgq0pv3m8.jl:19\ntest set: Test Failed at /tmp/tmpgq0pv3m8.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgq0pv3m8.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgq0pv3m8.jl:19\ntest set: Test Failed at /tmp/tmpgq0pv3m8.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgq0pv3m8.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgq0pv3m8.jl:19\ntest set: Test Failed at /tmp/tmpgq0pv3m8.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgq0pv3m8.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgq0pv3m8.jl:19\ntest set: Test Failed at /tmp/tmpgq0pv3m8.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpgq0pv3m8.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgq0pv3m8.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgq0pv3m8.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpacacj122.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpacacj122.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpthhu0_pe.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpthhu0_pe.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpthhu0_pe.jl:19\\ntest set: Test Failed at /tmp/tmpthhu0_pe.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpthhu0_pe.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpthhu0_pe.jl:19\\ntest set: Test Failed at /tmp/tmpthhu0_pe.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpthhu0_pe.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpthhu0_pe.jl:19\\ntest set: Test Failed at /tmp/tmpthhu0_pe.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpthhu0_pe.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpthhu0_pe.jl:19\\ntest set: Test Failed at /tmp/tmpthhu0_pe.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpthhu0_pe.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpthhu0_pe.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     5      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw3y2cl47.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw3y2cl47.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpueq7rxmy.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpueq7rxmy.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpueq7rxmy.jl:19\ntest set: Test Failed at /tmp/tmpueq7rxmy.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpueq7rxmy.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpueq7rxmy.jl:19\ntest set: Test Failed at /tmp/tmpueq7rxmy.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpueq7rxmy.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpueq7rxmy.jl:19\ntest set: Test Failed at /tmp/tmpueq7rxmy.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpueq7rxmy.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpueq7rxmy.jl:19\ntest set: Test Failed at /tmp/tmpueq7rxmy.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpueq7rxmy.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpueq7rxmy.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpueq7rxmy.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # Your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp42dc6d8j.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp42dc6d8j.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp42dc6d8j.jl:19\\ntest set: Test Failed at /tmp/tmp42dc6d8j.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp42dc6d8j.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp42dc6d8j.jl:19\\ntest set: Test Failed at /tmp/tmp42dc6d8j.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp42dc6d8j.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp42dc6d8j.jl:19\\ntest set: Test Failed at /tmp/tmp42dc6d8j.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp42dc6d8j.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp42dc6d8j.jl:19\\ntest set: Test Failed at /tmp/tmp42dc6d8j.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp42dc6d8j.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp42dc6d8j.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     5      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_cu_ntxh.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_cu_ntxh.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqsm176_1.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqsm176_1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw1n9oz5k.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw1n9oz5k.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # Your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9_948g5n.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp9_948g5n.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9_948g5n.jl:19\ntest set: Test Failed at /tmp/tmp9_948g5n.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9_948g5n.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9_948g5n.jl:19\ntest set: Test Failed at /tmp/tmp9_948g5n.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9_948g5n.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9_948g5n.jl:19\ntest set: Test Failed at /tmp/tmp9_948g5n.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9_948g5n.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9_948g5n.jl:19\ntest set: Test Failed at /tmp/tmp9_948g5n.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp9_948g5n.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9_948g5n.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9_948g5n.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code goes here\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt_6w8fjv.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpt_6w8fjv.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt_6w8fjv.jl:19\ntest set: Test Failed at /tmp/tmpt_6w8fjv.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt_6w8fjv.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt_6w8fjv.jl:19\ntest set: Test Failed at /tmp/tmpt_6w8fjv.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt_6w8fjv.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt_6w8fjv.jl:19\ntest set: Test Failed at /tmp/tmpt_6w8fjv.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt_6w8fjv.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt_6w8fjv.jl:19\ntest set: Test Failed at /tmp/tmpt_6w8fjv.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpt_6w8fjv.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt_6w8fjv.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt_6w8fjv.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5jaeydw9.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5jaeydw9.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n % 2 == 0\n        m = n \xF7 2\n    else\n\
    \        m = (n + 1) \xF7 2\n    end\n    count = 0\n    for i in 1:m\n      \
    \  if arr[i] != arr[n - i + 1]\n            count += 1\n        end\n    end\n\
    \    return count\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp30iy__nm.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp30iy__nm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk7zbt6kf.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk7zbt6kf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy4vqzb61.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpy4vqzb61.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy4vqzb61.jl:19\ntest set: Test Failed at /tmp/tmpy4vqzb61.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy4vqzb61.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy4vqzb61.jl:19\ntest set: Test Failed at /tmp/tmpy4vqzb61.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy4vqzb61.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy4vqzb61.jl:19\ntest set: Test Failed at /tmp/tmpy4vqzb61.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy4vqzb61.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy4vqzb61.jl:19\ntest set: Test Failed at /tmp/tmpy4vqzb61.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpy4vqzb61.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy4vqzb61.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy4vqzb61.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp82ndt3wz.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp82ndt3wz.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp82ndt3wz.jl:19\ntest set: Test Failed at /tmp/tmp82ndt3wz.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp82ndt3wz.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp82ndt3wz.jl:19\ntest set: Test Failed at /tmp/tmp82ndt3wz.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp82ndt3wz.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp82ndt3wz.jl:19\ntest set: Test Failed at /tmp/tmp82ndt3wz.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp82ndt3wz.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp82ndt3wz.jl:19\ntest set: Test Failed at /tmp/tmp82ndt3wz.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp82ndt3wz.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp82ndt3wz.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp82ndt3wz.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpla78utgp.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpla78utgp.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpla78utgp.jl:19\ntest set: Test Failed at /tmp/tmpla78utgp.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpla78utgp.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpla78utgp.jl:19\ntest set: Test Failed at /tmp/tmpla78utgp.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpla78utgp.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpla78utgp.jl:19\ntest set: Test Failed at /tmp/tmpla78utgp.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpla78utgp.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpla78utgp.jl:19\ntest set: Test Failed at /tmp/tmpla78utgp.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpla78utgp.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpla78utgp.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpla78utgp.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # Your code here\nend\n \n\
    using Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpo5ivms98.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpo5ivms98.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpo5ivms98.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo5ivms98.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpo5ivms98.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpo5ivms98.jl:13\n   [2] top-level scope at /tmp/tmpo5ivms98.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo5ivms98.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpo5ivms98.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpo5ivms98.jl:13\n   [2] top-level scope at /tmp/tmpo5ivms98.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo5ivms98.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpo5ivms98.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpo5ivms98.jl:13\n   [2] top-level scope at /tmp/tmpo5ivms98.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo5ivms98.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpo5ivms98.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpo5ivms98.jl:13\n   [2] top-level scope at /tmp/tmpo5ivms98.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo5ivms98.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpo5ivms98.jl:25\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpo5ivms98.jl:13\n   [2] top-level scope at /tmp/tmpo5ivms98.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo5ivms98.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpo5ivms98.jl:26\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpo5ivms98.jl:13\n   [2] top-level scope at /tmp/tmpo5ivms98.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo5ivms98.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpo5ivms98.jl:27\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpo5ivms98.jl:13\n   [2] top-level scope at /tmp/tmpo5ivms98.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo5ivms98.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo5ivms98.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for i in 1:n-1\n\
    \        dp[i, i+1] = abs(arr[i] - arr[i+1])\n    end\n    for i in 1:n-2\n  \
    \      dp[i, i+2] = abs(arr[i] - arr[i+2])\n    end\n    for i in 3:n\n      \
    \  for j in 1:n-i\n            dp[j, j+i] = minimum(dp[j+1, j+i] + abs(arr[j]\
    \ - arr[j+i]), dp[j, j+i-1] + abs(arr[j] - arr[j+i]))\n        end\n    end\n\
    \    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpda1z9lp8.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\\n  MethodError:\
    \ objects of type Int64 are not callable\\n  Stacktrace:\\n   [1] mapreduce_first(::Int64,\
    \ ::Function, ::Int64) at ./reduce.jl:384\\n   [2] mapreduce(::Int64, ::Function,\
    \ ::Int64) at ./reduce.jl:411\\n   [3] minimum(::Int64, ::Int64) at ./reduce.jl:628\\\
    n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpda1z9lp8.jl:25\\n   [5] top-level\
    \ scope at /tmp/tmpda1z9lp8.jl:35\\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpda1z9lp8.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpda1z9lp8.jl:36\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\\n  MethodError: objects of type Int64 are not callable\\\
    n  Stacktrace:\\n   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\\\
    n   [2] mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpda1z9lp8.jl:25\\\
    n   [5] top-level scope at /tmp/tmpda1z9lp8.jl:36\\n   [6] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpda1z9lp8.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpda1z9lp8.jl:38\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\\n  MethodError: objects of type Int64 are not callable\\n  Stacktrace:\\\
    n   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\\n  \
    \ [2] mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpda1z9lp8.jl:25\\\
    n   [5] top-level scope at /tmp/tmpda1z9lp8.jl:38\\n   [6] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpda1z9lp8.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpda1z9lp8.jl:39\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\\n  MethodError: objects of type Int64 are not callable\\\
    n  Stacktrace:\\n   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\\\
    n   [2] mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpda1z9lp8.jl:25\\\
    n   [5] top-level scope at /tmp/tmpda1z9lp8.jl:39\\n   [6] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpda1z9lp8.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpda1z9lp8.jl:40\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\\n  MethodError: objects of type Int64 are not callable\\n  Stacktrace:\\\
    n   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\\n  \
    \ [2] mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpda1z9lp8.jl:25\\\
    n   [5] top-level scope at /tmp/tmpda1z9lp8.jl:40\\n   [6] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpda1z9lp8.jl:34\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    3      5      8\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmptofqv_f3.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmptofqv_f3.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptofqv_f3.jl:19\\ntest set: Test Failed at /tmp/tmptofqv_f3.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmptofqv_f3.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptofqv_f3.jl:19\\ntest set: Test Failed at /tmp/tmptofqv_f3.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmptofqv_f3.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptofqv_f3.jl:19\\ntest set: Test Failed at /tmp/tmptofqv_f3.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmptofqv_f3.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptofqv_f3.jl:19\\ntest set: Test Failed at /tmp/tmptofqv_f3.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmptofqv_f3.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptofqv_f3.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpskqkoxfm.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpskqkoxfm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiikcxg5g.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpiikcxg5g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]))\n    end\n    if n == 4\n        return min(abs(arr[1] - arr[2]), abs(arr[2]\
    \ - arr[3]), abs(arr[3] - arr[4]))\n    end\n    if n == 5\n        return min(abs(arr[1]\
    \ - arr[2]), abs(arr[2] - arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]))\n\
    \    end\n    if n == 6\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]))\n\
    \    end\n    if n == 7\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]), abs(arr[6]\
    \ - arr[7]))\n    end\n    if n == 8\n        return min(abs(arr[1] - arr[2]),\
    \ abs(arr[2] - arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5]\
    \ - arr[6]), abs(arr[6] - arr[7]), abs(arr[7] - arr[8]))\n    end\n    if n ==\
    \ 9\n        return min(abs(arr[1] - arr[2]), abs(arr[2] - arr[3]), abs(arr[3]\
    \ - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]), abs(arr[6] - arr[7]),\
    \ abs(arr[\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppuupz18f.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppuupz18f.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_kb0ys8m.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_kb0ys8m.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6oz3ytcp.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp6oz3ytcp.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6oz3ytcp.jl:19\ntest set: Test Failed at /tmp/tmp6oz3ytcp.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6oz3ytcp.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6oz3ytcp.jl:19\ntest set: Test Failed at /tmp/tmp6oz3ytcp.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6oz3ytcp.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6oz3ytcp.jl:19\ntest set: Test Failed at /tmp/tmp6oz3ytcp.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6oz3ytcp.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6oz3ytcp.jl:19\ntest set: Test Failed at /tmp/tmp6oz3ytcp.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp6oz3ytcp.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6oz3ytcp.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6oz3ytcp.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg06fbfye.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg06fbfye.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpndi0s4_8.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpndi0s4_8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph98nvyiq.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph98nvyiq.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    \"\"\"\n    Given an array\
    \ arr of integers, find the minimum number of elements that\n    need to be changed\
    \ to make the array palindromic. A palindromic array is an array that\n    is\
    \ read the same backwards and forwards. In one change, you can change one element\
    \ to any other element.\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgtq57flk.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgtq57flk.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfkrzwwsk.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfkrzwwsk.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqt2xr21j.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpqt2xr21j.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqt2xr21j.jl:19\ntest set: Test Failed at /tmp/tmpqt2xr21j.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqt2xr21j.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqt2xr21j.jl:19\ntest set: Test Failed at /tmp/tmpqt2xr21j.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqt2xr21j.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqt2xr21j.jl:19\ntest set: Test Failed at /tmp/tmpqt2xr21j.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqt2xr21j.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqt2xr21j.jl:19\ntest set: Test Failed at /tmp/tmpqt2xr21j.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpqt2xr21j.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqt2xr21j.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqt2xr21j.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxuix3icu.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxuix3icu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpijtsv0j2.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpijtsv0j2.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpijtsv0j2.jl:19\ntest set: Test Failed at /tmp/tmpijtsv0j2.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpijtsv0j2.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpijtsv0j2.jl:19\ntest set: Test Failed at /tmp/tmpijtsv0j2.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpijtsv0j2.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpijtsv0j2.jl:19\ntest set: Test Failed at /tmp/tmpijtsv0j2.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpijtsv0j2.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpijtsv0j2.jl:19\ntest set: Test Failed at /tmp/tmpijtsv0j2.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpijtsv0j2.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpijtsv0j2.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpijtsv0j2.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # Your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphibq5cjo.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmphibq5cjo.jl:13\n   [2] top-level\
    \ scope at /tmp/tmphibq5cjo.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphibq5cjo.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphibq5cjo.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmphibq5cjo.jl:13\n   [2] top-level scope at /tmp/tmphibq5cjo.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphibq5cjo.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphibq5cjo.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmphibq5cjo.jl:13\n   [2] top-level scope at /tmp/tmphibq5cjo.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphibq5cjo.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphibq5cjo.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmphibq5cjo.jl:13\n   [2] top-level scope at /tmp/tmphibq5cjo.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphibq5cjo.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphibq5cjo.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmphibq5cjo.jl:13\n   [2] top-level scope at /tmp/tmphibq5cjo.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphibq5cjo.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphibq5cjo.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmphibq5cjo.jl:13\n   [2] top-level scope at /tmp/tmphibq5cjo.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphibq5cjo.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphibq5cjo.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmphibq5cjo.jl:13\n   [2] top-level scope at /tmp/tmphibq5cjo.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphibq5cjo.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphibq5cjo.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmphibq5cjo.jl:13\n   [2] top-level scope at /tmp/tmphibq5cjo.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphibq5cjo.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphibq5cjo.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpka5ru7is.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpka5ru7is.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpka5ru7is.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpka5ru7is.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpka5ru7is.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpka5ru7is.jl:13\n   [2] top-level scope at /tmp/tmpka5ru7is.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpka5ru7is.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpka5ru7is.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpka5ru7is.jl:13\n   [2] top-level scope at /tmp/tmpka5ru7is.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpka5ru7is.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpka5ru7is.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpka5ru7is.jl:13\n   [2] top-level scope at /tmp/tmpka5ru7is.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpka5ru7is.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpka5ru7is.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpka5ru7is.jl:13\n   [2] top-level scope at /tmp/tmpka5ru7is.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpka5ru7is.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpka5ru7is.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpka5ru7is.jl:13\n   [2] top-level scope at /tmp/tmpka5ru7is.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpka5ru7is.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpka5ru7is.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpka5ru7is.jl:13\n   [2] top-level scope at /tmp/tmpka5ru7is.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpka5ru7is.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpka5ru7is.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpka5ru7is.jl:13\n   [2] top-level scope at /tmp/tmpka5ru7is.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpka5ru7is.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpka5ru7is.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwf0u7cis.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwf0u7cis.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmps4o87fel.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmps4o87fel.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps4o87fel.jl:19\\ntest set: Test Failed at /tmp/tmps4o87fel.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmps4o87fel.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps4o87fel.jl:19\\ntest set: Test Failed at /tmp/tmps4o87fel.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmps4o87fel.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps4o87fel.jl:19\\ntest set: Test Failed at /tmp/tmps4o87fel.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmps4o87fel.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps4o87fel.jl:19\\ntest set: Test Failed at /tmp/tmps4o87fel.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmps4o87fel.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps4o87fel.jl:19\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp3jxn8rsg.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp3jxn8rsg.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jxn8rsg.jl:19\\ntest set: Test Failed at /tmp/tmp3jxn8rsg.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp3jxn8rsg.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jxn8rsg.jl:19\\ntest set: Test Failed at /tmp/tmp3jxn8rsg.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3jxn8rsg.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jxn8rsg.jl:19\\ntest set: Test Failed at /tmp/tmp3jxn8rsg.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3jxn8rsg.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jxn8rsg.jl:19\\ntest set: Test Failed at /tmp/tmp3jxn8rsg.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp3jxn8rsg.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3jxn8rsg.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     5      8\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmp3jxn8rsg.jl:17\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphain7dzl.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmphain7dzl.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphain7dzl.jl:19\ntest set: Test Failed at /tmp/tmphain7dzl.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphain7dzl.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphain7dzl.jl:19\ntest set: Test Failed at /tmp/tmphain7dzl.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphain7dzl.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphain7dzl.jl:19\ntest set: Test Failed at /tmp/tmphain7dzl.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphain7dzl.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphain7dzl.jl:19\ntest set: Test Failed at /tmp/tmphain7dzl.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmphain7dzl.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphain7dzl.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphain7dzl.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfiqbklzv.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpfiqbklzv.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfiqbklzv.jl:19\ntest set: Test Failed at /tmp/tmpfiqbklzv.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfiqbklzv.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfiqbklzv.jl:19\ntest set: Test Failed at /tmp/tmpfiqbklzv.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfiqbklzv.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfiqbklzv.jl:19\ntest set: Test Failed at /tmp/tmpfiqbklzv.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfiqbklzv.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfiqbklzv.jl:19\ntest set: Test Failed at /tmp/tmpfiqbklzv.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpfiqbklzv.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfiqbklzv.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfiqbklzv.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx6i7izh3.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpx6i7izh3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpuu8tt2ab.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpuu8tt2ab.jl:13\\\
    n   [2] top-level scope at /tmp/tmpuu8tt2ab.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuu8tt2ab.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuu8tt2ab.jl:20\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpuu8tt2ab.jl:13\\n   [2] top-level scope at /tmp/tmpuu8tt2ab.jl:20\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuu8tt2ab.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuu8tt2ab.jl:21\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 4, 2]) == 1\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpuu8tt2ab.jl:13\\n   [2] top-level scope at /tmp/tmpuu8tt2ab.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuu8tt2ab.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuu8tt2ab.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpuu8tt2ab.jl:13\\n   [2] top-level scope at /tmp/tmpuu8tt2ab.jl:22\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuu8tt2ab.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuu8tt2ab.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpuu8tt2ab.jl:13\\n   [2] top-level scope at /tmp/tmpuu8tt2ab.jl:23\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuu8tt2ab.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuu8tt2ab.jl:24\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpuu8tt2ab.jl:13\\n   [2] top-level scope at /tmp/tmpuu8tt2ab.jl:24\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuu8tt2ab.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuu8tt2ab.jl:25\\n  Test threw exception\\n  Expression: candidate([1])\
    \ == 0\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpuu8tt2ab.jl:13\\n   [2] top-level scope at /tmp/tmpuu8tt2ab.jl:25\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuu8tt2ab.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuu8tt2ab.jl:26\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 1]) == 1\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpuu8tt2ab.jl:13\\n   [2] top-level scope at /tmp/tmpuu8tt2ab.jl:26\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuu8tt2ab.jl:18\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     8      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnxzbesoq.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpnxzbesoq.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnxzbesoq.jl:19\ntest set: Test Failed at /tmp/tmpnxzbesoq.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnxzbesoq.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnxzbesoq.jl:19\ntest set: Test Failed at /tmp/tmpnxzbesoq.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnxzbesoq.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnxzbesoq.jl:19\ntest set: Test Failed at /tmp/tmpnxzbesoq.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnxzbesoq.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnxzbesoq.jl:19\ntest set: Test Failed at /tmp/tmpnxzbesoq.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpnxzbesoq.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnxzbesoq.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnxzbesoq.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt3mpwkwx.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpt3mpwkwx.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplq_cuikw.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplq_cuikw.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7qxmirdb.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7qxmirdb.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmplvx59e07.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmplvx59e07.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplvx59e07.jl:19\\ntest set: Test Failed at /tmp/tmplvx59e07.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmplvx59e07.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplvx59e07.jl:19\\ntest set: Test Failed at /tmp/tmplvx59e07.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplvx59e07.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplvx59e07.jl:19\\ntest set: Test Failed at /tmp/tmplvx59e07.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplvx59e07.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplvx59e07.jl:19\\ntest set: Test Failed at /tmp/tmplvx59e07.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmplvx59e07.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplvx59e07.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     5      8\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq9518z9k.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpq9518z9k.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpq9518z9k.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq9518z9k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9518z9k.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpq9518z9k.jl:13\n   [2] top-level scope at /tmp/tmpq9518z9k.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq9518z9k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9518z9k.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpq9518z9k.jl:13\n   [2] top-level scope at /tmp/tmpq9518z9k.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq9518z9k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9518z9k.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpq9518z9k.jl:13\n   [2] top-level scope at /tmp/tmpq9518z9k.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq9518z9k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9518z9k.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpq9518z9k.jl:13\n   [2] top-level scope at /tmp/tmpq9518z9k.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq9518z9k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9518z9k.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpq9518z9k.jl:13\n   [2] top-level scope at /tmp/tmpq9518z9k.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq9518z9k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9518z9k.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpq9518z9k.jl:13\n   [2] top-level scope at /tmp/tmpq9518z9k.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq9518z9k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9518z9k.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpq9518z9k.jl:13\n   [2] top-level scope at /tmp/tmpq9518z9k.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq9518z9k.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq9518z9k.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_atkqglu.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_atkqglu.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_atkqglu.jl:19\ntest set: Test Failed at /tmp/tmp_atkqglu.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_atkqglu.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_atkqglu.jl:19\ntest set: Test Failed at /tmp/tmp_atkqglu.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_atkqglu.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_atkqglu.jl:19\ntest set: Test Failed at /tmp/tmp_atkqglu.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_atkqglu.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_atkqglu.jl:19\ntest set: Test Failed at /tmp/tmp_atkqglu.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp_atkqglu.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_atkqglu.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_atkqglu.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpenjg57tt.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpenjg57tt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn_30civ1.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpn_30civ1.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_30civ1.jl:19\ntest set: Test Failed at /tmp/tmpn_30civ1.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn_30civ1.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_30civ1.jl:19\ntest set: Test Failed at /tmp/tmpn_30civ1.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn_30civ1.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_30civ1.jl:19\ntest set: Test Failed at /tmp/tmpn_30civ1.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn_30civ1.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_30civ1.jl:19\ntest set: Test Failed at /tmp/tmpn_30civ1.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpn_30civ1.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_30civ1.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn_30civ1.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8kejrn5l.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8kejrn5l.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw5fdhwwg.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw5fdhwwg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpatz46s0l.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpatz46s0l.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpatz46s0l.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpatz46s0l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpatz46s0l.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpatz46s0l.jl:13\n   [2] top-level scope at /tmp/tmpatz46s0l.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpatz46s0l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpatz46s0l.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpatz46s0l.jl:13\n   [2] top-level scope at /tmp/tmpatz46s0l.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpatz46s0l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpatz46s0l.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpatz46s0l.jl:13\n   [2] top-level scope at /tmp/tmpatz46s0l.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpatz46s0l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpatz46s0l.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpatz46s0l.jl:13\n   [2] top-level scope at /tmp/tmpatz46s0l.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpatz46s0l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpatz46s0l.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpatz46s0l.jl:13\n   [2] top-level scope at /tmp/tmpatz46s0l.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpatz46s0l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpatz46s0l.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpatz46s0l.jl:13\n   [2] top-level scope at /tmp/tmpatz46s0l.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpatz46s0l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpatz46s0l.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpatz46s0l.jl:13\n   [2] top-level scope at /tmp/tmpatz46s0l.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpatz46s0l.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpatz46s0l.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7qi34hi3.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7qi34hi3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkmjsgb3z.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkmjsgb3z.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdoocykv0.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdoocykv0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\n\"\"\
    \"\n    Given an array arr of integers, find the minimum number of elements that\n\
    \    need to be changed to make the array palindromic. A palindromic array is\
    \ an array that\n    is read the same backwards and forwards. In one change, you\
    \ can change one element to any other element.\nusing Test\n\n@testset begin\n\
    \ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) ==\
    \ 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4,\
    \ 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3,\
    \ 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuea4sio8.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuea4sio8.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5dhahi0l.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5dhahi0l.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhahi0l.jl:19\ntest set: Test Failed at /tmp/tmp5dhahi0l.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5dhahi0l.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhahi0l.jl:19\ntest set: Test Failed at /tmp/tmp5dhahi0l.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5dhahi0l.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhahi0l.jl:19\ntest set: Test Failed at /tmp/tmp5dhahi0l.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5dhahi0l.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhahi0l.jl:19\ntest set: Test Failed at /tmp/tmp5dhahi0l.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp5dhahi0l.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhahi0l.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5dhahi0l.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt5y3lo5o.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpt5y3lo5o.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt7rj4g83.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpt7rj4g83.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt7rj4g83.jl:19\ntest set: Test Failed at /tmp/tmpt7rj4g83.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt7rj4g83.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt7rj4g83.jl:19\ntest set: Test Failed at /tmp/tmpt7rj4g83.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt7rj4g83.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt7rj4g83.jl:19\ntest set: Test Failed at /tmp/tmpt7rj4g83.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt7rj4g83.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt7rj4g83.jl:19\ntest set: Test Failed at /tmp/tmpt7rj4g83.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpt7rj4g83.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt7rj4g83.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt7rj4g83.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]))\n    end\n    if n == 4\n        return min(abs(arr[1] - arr[2]), abs(arr[2]\
    \ - arr[3]), abs(arr[3] - arr[4]))\n    end\n    if n == 5\n        return min(abs(arr[1]\
    \ - arr[2]), abs(arr[2] - arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]))\n\
    \    end\n    if n == 6\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]))\n\
    \    end\n    if n == 7\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]), abs(arr[6]\
    \ - arr[7]))\n    end\n    if n == 8\n        return min(abs(arr[1] - arr[2]),\
    \ abs(arr[2] - arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5]\
    \ - arr[6]), abs(arr[6] - arr[7]), abs(arr[7] - arr[8]))\n    end\n    if n ==\
    \ 9\n        return min(abs(arr[1] - arr[2]), abs(arr[2] - arr[3]), abs(arr[3]\
    \ - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]), abs(arr[6] - arr[7]),\
    \ abs(arr[\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9wgy92lu.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9wgy92lu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n % 2 == 0\n        return n -\
    \ 2\n    end\n    return n - 1\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpjoiq7svh.jl:32\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 6 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpjoiq7svh.jl:32\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjoiq7svh.jl:31\\ntest set: Test Failed at /tmp/tmpjoiq7svh.jl:33\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 6 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpjoiq7svh.jl:33\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjoiq7svh.jl:31\\ntest set: Test Failed at /tmp/tmpjoiq7svh.jl:34\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 2 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpjoiq7svh.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjoiq7svh.jl:31\\ntest set: Test Failed at /tmp/tmpjoiq7svh.jl:35\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 2 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpjoiq7svh.jl:35\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjoiq7svh.jl:31\\ntest set: Test Failed at /tmp/tmpjoiq7svh.jl:36\\\
    n  Expression: candidate([1, 2, 3, 2, 1]) == 0\\n   Evaluated: 4 == 0\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpjoiq7svh.jl:36\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjoiq7svh.jl:31\\ntest set: Test Failed at /tmp/tmpjoiq7svh.jl:37\\\
    n  Expression: candidate([3, 1, 1, 3]) == 0\\n   Evaluated: 2 == 0\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpjoiq7svh.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjoiq7svh.jl:31\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # Your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwl7tr0nz.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpwl7tr0nz.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpwl7tr0nz.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwl7tr0nz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwl7tr0nz.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpwl7tr0nz.jl:13\n   [2] top-level scope at /tmp/tmpwl7tr0nz.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwl7tr0nz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwl7tr0nz.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpwl7tr0nz.jl:13\n   [2] top-level scope at /tmp/tmpwl7tr0nz.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwl7tr0nz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwl7tr0nz.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpwl7tr0nz.jl:13\n   [2] top-level scope at /tmp/tmpwl7tr0nz.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwl7tr0nz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwl7tr0nz.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpwl7tr0nz.jl:13\n   [2] top-level scope at /tmp/tmpwl7tr0nz.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwl7tr0nz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwl7tr0nz.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpwl7tr0nz.jl:13\n   [2] top-level scope at /tmp/tmpwl7tr0nz.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwl7tr0nz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwl7tr0nz.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpwl7tr0nz.jl:13\n   [2] top-level scope at /tmp/tmpwl7tr0nz.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwl7tr0nz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwl7tr0nz.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpwl7tr0nz.jl:13\n   [2] top-level scope at /tmp/tmpwl7tr0nz.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwl7tr0nz.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwl7tr0nz.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe1i7ayg2.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe1i7ayg2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for l in 2:n\n \
    \       for i in 1:n-l+1\n            j = i+l-1\n            if arr[i] == arr[j]\n\
    \                dp[i, j] = dp[i+1, j-1]\n            else\n                dp[i,\
    \ j] = min(dp[i+1, j], dp[i, j-1]) + 1\n            end\n        end\n    end\n\
    \    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0l5ivmn2.jl:34\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 7 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp0l5ivmn2.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0l5ivmn2.jl:33\ntest set: Test Failed at /tmp/tmp0l5ivmn2.jl:35\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0l5ivmn2.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0l5ivmn2.jl:33\ntest set: Test Failed at /tmp/tmp0l5ivmn2.jl:36\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0l5ivmn2.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0l5ivmn2.jl:33\ntest set: Test Failed at /tmp/tmp0l5ivmn2.jl:37\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0l5ivmn2.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0l5ivmn2.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     4      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0l5ivmn2.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3ktfxcw3.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3ktfxcw3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp314lrh98.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp314lrh98.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp314lrh98.jl:19\ntest set: Test Failed at /tmp/tmp314lrh98.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp314lrh98.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp314lrh98.jl:19\ntest set: Test Failed at /tmp/tmp314lrh98.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp314lrh98.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp314lrh98.jl:19\ntest set: Test Failed at /tmp/tmp314lrh98.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp314lrh98.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp314lrh98.jl:19\ntest set: Test Failed at /tmp/tmp314lrh98.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp314lrh98.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp314lrh98.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp314lrh98.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp3nednxs0.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp3nednxs0.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3nednxs0.jl:19\\ntest set: Test Failed at /tmp/tmp3nednxs0.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp3nednxs0.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3nednxs0.jl:19\\ntest set: Test Failed at /tmp/tmp3nednxs0.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3nednxs0.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3nednxs0.jl:19\\ntest set: Test Failed at /tmp/tmp3nednxs0.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3nednxs0.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3nednxs0.jl:19\\ntest set: Test Failed at /tmp/tmp3nednxs0.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp3nednxs0.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3nednxs0.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     5      8\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5c4snh43.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5c4snh43.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n % 2 == 0\n        return n -\
    \ 2\n    end\n    return n - 1\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg_k1my5g.jl:32\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 6 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpg_k1my5g.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg_k1my5g.jl:31\ntest set: Test Failed at /tmp/tmpg_k1my5g.jl:33\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 6 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg_k1my5g.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg_k1my5g.jl:31\ntest set: Test Failed at /tmp/tmpg_k1my5g.jl:34\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg_k1my5g.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg_k1my5g.jl:31\ntest set: Test Failed at /tmp/tmpg_k1my5g.jl:35\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg_k1my5g.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg_k1my5g.jl:31\ntest set: Test Failed at /tmp/tmpg_k1my5g.jl:36\n\
    \  Expression: candidate([1, 2, 3, 2, 1]) == 0\n   Evaluated: 4 == 0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg_k1my5g.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg_k1my5g.jl:31\ntest set: Test Failed at /tmp/tmpg_k1my5g.jl:37\n\
    \  Expression: candidate([3, 1, 1, 3]) == 0\n   Evaluated: 2 == 0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg_k1my5g.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg_k1my5g.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg_k1my5g.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\n\"\"\
    \"\n    Given an array arr of integers, find the minimum number of elements that\n\
    \    need to be changed to make the array palindromic. A palindromic array is\
    \ an array that\n    is read the same backwards and forwards. In one change, you\
    \ can change one element to any other element.\nusing Test\n\n@testset begin\n\
    \ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) ==\
    \ 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4,\
    \ 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3,\
    \ 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiagra2bw.jl:14\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpiagra2bw.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for i in 1:n-1\n\
    \        dp[i, i+1] = abs(arr[i] - arr[i+1])\n    end\n    for l in 3:n\n    \
    \    for i in 1:n-l+1\n            j = i+l-1\n            dp[i, j] = minimum(dp[i+1,\
    \ j] + abs(arr[i] - arr[i+1]), dp[i, j-1] + abs(arr[j] - arr[j-1]))\n        end\n\
    \    end\n    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpm4u0fgvq.jl:33\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: objects\
    \ of type Int64 are not callable\n  Stacktrace:\n   [1] mapreduce_first(::Int64,\
    \ ::Function, ::Int64) at ./reduce.jl:384\n   [2] mapreduce(::Int64, ::Function,\
    \ ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64, ::Int64) at ./reduce.jl:628\n\
    \   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpm4u0fgvq.jl:23\n   [5] top-level\
    \ scope at /tmp/tmpm4u0fgvq.jl:33\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpm4u0fgvq.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4u0fgvq.jl:34\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: objects of type Int64 are not callable\n\
    \  Stacktrace:\n   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n\
    \   [2] mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpm4u0fgvq.jl:23\n\
    \   [5] top-level scope at /tmp/tmpm4u0fgvq.jl:34\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpm4u0fgvq.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4u0fgvq.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: objects of type Int64 are not callable\n  Stacktrace:\n\
    \   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n   [2]\
    \ mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpm4u0fgvq.jl:23\n\
    \   [5] top-level scope at /tmp/tmpm4u0fgvq.jl:35\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpm4u0fgvq.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4u0fgvq.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: objects of type Int64 are not callable\n  Stacktrace:\n\
    \   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n   [2]\
    \ mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpm4u0fgvq.jl:23\n\
    \   [5] top-level scope at /tmp/tmpm4u0fgvq.jl:36\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpm4u0fgvq.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4u0fgvq.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: objects of type Int64 are not callable\n \
    \ Stacktrace:\n   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n\
    \   [2] mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpm4u0fgvq.jl:23\n\
    \   [5] top-level scope at /tmp/tmpm4u0fgvq.jl:37\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpm4u0fgvq.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4u0fgvq.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: objects of type Int64 are not callable\n  Stacktrace:\n\
    \   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n   [2]\
    \ mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmpm4u0fgvq.jl:23\n\
    \   [5] top-level scope at /tmp/tmpm4u0fgvq.jl:38\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpm4u0fgvq.jl:32\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm4u0fgvq.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp1j1kwdjs.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp1j1kwdjs.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1j1kwdjs.jl:19\\ntest set: Test Failed at /tmp/tmp1j1kwdjs.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp1j1kwdjs.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1j1kwdjs.jl:19\\ntest set: Test Failed at /tmp/tmp1j1kwdjs.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp1j1kwdjs.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1j1kwdjs.jl:19\\ntest set: Test Failed at /tmp/tmp1j1kwdjs.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp1j1kwdjs.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1j1kwdjs.jl:19\\ntest set: Test Failed at /tmp/tmp1j1kwdjs.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp1j1kwdjs.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1j1kwdjs.jl:19\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpys24gm_8.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpys24gm_8.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpys24gm_8.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpys24gm_8.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpys24gm_8.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpys24gm_8.jl:13\n   [2] top-level scope at /tmp/tmpys24gm_8.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpys24gm_8.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpys24gm_8.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpys24gm_8.jl:13\n   [2] top-level scope at /tmp/tmpys24gm_8.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpys24gm_8.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpys24gm_8.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpys24gm_8.jl:13\n   [2] top-level scope at /tmp/tmpys24gm_8.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpys24gm_8.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpys24gm_8.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpys24gm_8.jl:13\n   [2] top-level scope at /tmp/tmpys24gm_8.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpys24gm_8.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpys24gm_8.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpys24gm_8.jl:13\n   [2] top-level scope at /tmp/tmpys24gm_8.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpys24gm_8.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpys24gm_8.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpys24gm_8.jl:13\n   [2] top-level scope at /tmp/tmpys24gm_8.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpys24gm_8.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpys24gm_8.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpys24gm_8.jl:13\n   [2] top-level scope at /tmp/tmpys24gm_8.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpys24gm_8.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpys24gm_8.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfo424dgx.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpfo424dgx.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpfo424dgx.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo424dgx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo424dgx.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpfo424dgx.jl:13\n   [2] top-level scope at /tmp/tmpfo424dgx.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo424dgx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo424dgx.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpfo424dgx.jl:13\n   [2] top-level scope at /tmp/tmpfo424dgx.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo424dgx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo424dgx.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpfo424dgx.jl:13\n   [2] top-level scope at /tmp/tmpfo424dgx.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo424dgx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo424dgx.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpfo424dgx.jl:13\n   [2] top-level scope at /tmp/tmpfo424dgx.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo424dgx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo424dgx.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpfo424dgx.jl:13\n   [2] top-level scope at /tmp/tmpfo424dgx.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo424dgx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo424dgx.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpfo424dgx.jl:13\n   [2] top-level scope at /tmp/tmpfo424dgx.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo424dgx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo424dgx.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpfo424dgx.jl:13\n   [2] top-level scope at /tmp/tmpfo424dgx.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo424dgx.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfo424dgx.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7y4jfz3e.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7y4jfz3e.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcbfntoeo.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcbfntoeo.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcbfntoeo.jl:19\ntest set: Test Failed at /tmp/tmpcbfntoeo.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcbfntoeo.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcbfntoeo.jl:19\ntest set: Test Failed at /tmp/tmpcbfntoeo.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcbfntoeo.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcbfntoeo.jl:19\ntest set: Test Failed at /tmp/tmpcbfntoeo.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcbfntoeo.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcbfntoeo.jl:19\ntest set: Test Failed at /tmp/tmpcbfntoeo.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpcbfntoeo.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcbfntoeo.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcbfntoeo.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw4m_h_uu.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw4m_h_uu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpljff_o5p.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpljff_o5p.jl:13\\\
    n   [2] top-level scope at /tmp/tmpljff_o5p.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpljff_o5p.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpljff_o5p.jl:20\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpljff_o5p.jl:13\\n   [2] top-level scope at /tmp/tmpljff_o5p.jl:20\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpljff_o5p.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpljff_o5p.jl:21\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 4, 2]) == 1\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpljff_o5p.jl:13\\n   [2] top-level scope at /tmp/tmpljff_o5p.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpljff_o5p.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpljff_o5p.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpljff_o5p.jl:13\\n   [2] top-level scope at /tmp/tmpljff_o5p.jl:22\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpljff_o5p.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpljff_o5p.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpljff_o5p.jl:13\\n   [2] top-level scope at /tmp/tmpljff_o5p.jl:23\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpljff_o5p.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpljff_o5p.jl:24\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpljff_o5p.jl:13\\n   [2] top-level scope at /tmp/tmpljff_o5p.jl:24\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpljff_o5p.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpljff_o5p.jl:25\\n  Test threw exception\\n  Expression: candidate([1])\
    \ == 0\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpljff_o5p.jl:13\\n   [2] top-level scope at /tmp/tmpljff_o5p.jl:25\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpljff_o5p.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpljff_o5p.jl:26\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 1]) == 1\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpljff_o5p.jl:13\\n   [2] top-level scope at /tmp/tmpljff_o5p.jl:26\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpljff_o5p.jl:18\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp90e5i4va.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp90e5i4va.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp90e5i4va.jl:19\ntest set: Test Failed at /tmp/tmp90e5i4va.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp90e5i4va.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp90e5i4va.jl:19\ntest set: Test Failed at /tmp/tmp90e5i4va.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp90e5i4va.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp90e5i4va.jl:19\ntest set: Test Failed at /tmp/tmp90e5i4va.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp90e5i4va.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp90e5i4va.jl:19\ntest set: Test Failed at /tmp/tmp90e5i4va.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp90e5i4va.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp90e5i4va.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp90e5i4va.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpac9xxylr.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpac9xxylr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for l in 2:n\n \
    \       for i in 1:n-l+1\n            j = i+l-1\n            if arr[i] == arr[j]\n\
    \                dp[i, j] = dp[i+1, j-1]\n            else\n                dp[i,\
    \ j] = min(dp[i+1, j], dp[i, j-1]) + 1\n            end\n        end\n    end\n\
    \    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp5mgjoyyn.jl:34\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 7 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp5mgjoyyn.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5mgjoyyn.jl:33\\ntest set: Test Failed at /tmp/tmp5mgjoyyn.jl:35\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 2 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp5mgjoyyn.jl:35\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5mgjoyyn.jl:33\\ntest set: Test Failed at /tmp/tmp5mgjoyyn.jl:36\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 2 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp5mgjoyyn.jl:36\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5mgjoyyn.jl:33\\ntest set: Test Failed at /tmp/tmp5mgjoyyn.jl:37\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 2 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp5mgjoyyn.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5mgjoyyn.jl:33\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     4      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdxpuaqd1.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpdxpuaqd1.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdxpuaqd1.jl:19\ntest set: Test Failed at /tmp/tmpdxpuaqd1.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdxpuaqd1.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdxpuaqd1.jl:19\ntest set: Test Failed at /tmp/tmpdxpuaqd1.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdxpuaqd1.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdxpuaqd1.jl:19\ntest set: Test Failed at /tmp/tmpdxpuaqd1.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdxpuaqd1.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdxpuaqd1.jl:19\ntest set: Test Failed at /tmp/tmpdxpuaqd1.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpdxpuaqd1.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdxpuaqd1.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdxpuaqd1.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoqar3ap6.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpoqar3ap6.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqar3ap6.jl:19\ntest set: Test Failed at /tmp/tmpoqar3ap6.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoqar3ap6.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqar3ap6.jl:19\ntest set: Test Failed at /tmp/tmpoqar3ap6.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoqar3ap6.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqar3ap6.jl:19\ntest set: Test Failed at /tmp/tmpoqar3ap6.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoqar3ap6.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqar3ap6.jl:19\ntest set: Test Failed at /tmp/tmpoqar3ap6.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpoqar3ap6.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoqar3ap6.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoqar3ap6.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppn1_m2zl.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppn1_m2zl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    # if the\
    \ array is already a palindrome, return 0\n    if arr == reverse(arr)\n      \
    \  return 0\n    end\n    # if the array is not a palindrome, find the minimum\
    \ number of changes\n    # required to make it a palindrome\n    # first, find\
    \ the longest palindromic subsequence\n    # then, find the number of elements\
    \ that need to be changed to make the\n    # array palindromic\n    # the number\
    \ of changes is the length of the array minus the length of the\n    # longest\
    \ palindromic subsequence\n    return n - longest_palindromic_subsequence(arr)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5b1oiczq.jl:31\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  UndefVarError: longest_palindromic_subsequence\
    \ not defined\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp5b1oiczq.jl:24\n\
    \   [2] top-level scope at /tmp/tmp5b1oiczq.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5b1oiczq.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp5b1oiczq.jl:32\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  UndefVarError: longest_palindromic_subsequence not\
    \ defined\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp5b1oiczq.jl:24\n\
    \   [2] top-level scope at /tmp/tmp5b1oiczq.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5b1oiczq.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp5b1oiczq.jl:33\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  UndefVarError: longest_palindromic_subsequence not defined\n\
    \  Stacktrace:\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp5b1oiczq.jl:24\n\
    \   [2] top-level scope at /tmp/tmp5b1oiczq.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5b1oiczq.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp5b1oiczq.jl:34\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  UndefVarError: longest_palindromic_subsequence not defined\n\
    \  Stacktrace:\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp5b1oiczq.jl:24\n\
    \   [2] top-level scope at /tmp/tmp5b1oiczq.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5b1oiczq.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmp5b1oiczq.jl:38\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  UndefVarError: longest_palindromic_subsequence not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmp5b1oiczq.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp5b1oiczq.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5b1oiczq.jl:30\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5b1oiczq.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprsvuhi4h.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprsvuhi4h.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpofd8mqxb.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpofd8mqxb.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpofd8mqxb.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpofd8mqxb.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpofd8mqxb.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpofd8mqxb.jl:13\n   [2] top-level scope at /tmp/tmpofd8mqxb.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpofd8mqxb.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpofd8mqxb.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpofd8mqxb.jl:13\n   [2] top-level scope at /tmp/tmpofd8mqxb.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpofd8mqxb.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpofd8mqxb.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpofd8mqxb.jl:13\n   [2] top-level scope at /tmp/tmpofd8mqxb.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpofd8mqxb.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpofd8mqxb.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpofd8mqxb.jl:13\n   [2] top-level scope at /tmp/tmpofd8mqxb.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpofd8mqxb.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpofd8mqxb.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpofd8mqxb.jl:13\n   [2] top-level scope at /tmp/tmpofd8mqxb.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpofd8mqxb.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpofd8mqxb.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpofd8mqxb.jl:13\n   [2] top-level scope at /tmp/tmpofd8mqxb.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpofd8mqxb.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpofd8mqxb.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpofd8mqxb.jl:13\n   [2] top-level scope at /tmp/tmpofd8mqxb.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpofd8mqxb.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpofd8mqxb.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbblpzt_b.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbblpzt_b.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbblpzt_b.jl:19\ntest set: Test Failed at /tmp/tmpbblpzt_b.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbblpzt_b.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbblpzt_b.jl:19\ntest set: Test Failed at /tmp/tmpbblpzt_b.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbblpzt_b.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbblpzt_b.jl:19\ntest set: Test Failed at /tmp/tmpbblpzt_b.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbblpzt_b.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbblpzt_b.jl:19\ntest set: Test Failed at /tmp/tmpbblpzt_b.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpbblpzt_b.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbblpzt_b.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbblpzt_b.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp52e9ycdz.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp52e9ycdz.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # Your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpef8yn5da.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpef8yn5da.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpef8yn5da.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpef8yn5da.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpef8yn5da.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpef8yn5da.jl:13\n   [2] top-level scope at /tmp/tmpef8yn5da.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpef8yn5da.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpef8yn5da.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpef8yn5da.jl:13\n   [2] top-level scope at /tmp/tmpef8yn5da.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpef8yn5da.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpef8yn5da.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpef8yn5da.jl:13\n   [2] top-level scope at /tmp/tmpef8yn5da.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpef8yn5da.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpef8yn5da.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpef8yn5da.jl:13\n   [2] top-level scope at /tmp/tmpef8yn5da.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpef8yn5da.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpef8yn5da.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpef8yn5da.jl:13\n   [2] top-level scope at /tmp/tmpef8yn5da.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpef8yn5da.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpef8yn5da.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpef8yn5da.jl:13\n   [2] top-level scope at /tmp/tmpef8yn5da.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpef8yn5da.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpef8yn5da.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpef8yn5da.jl:13\n   [2] top-level scope at /tmp/tmpef8yn5da.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpef8yn5da.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpef8yn5da.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjsdnnnaa.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjsdnnnaa.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2cv_k267.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2cv_k267.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2cv_k267.jl:19\ntest set: Test Failed at /tmp/tmp2cv_k267.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2cv_k267.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2cv_k267.jl:19\ntest set: Test Failed at /tmp/tmp2cv_k267.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2cv_k267.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2cv_k267.jl:19\ntest set: Test Failed at /tmp/tmp2cv_k267.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2cv_k267.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2cv_k267.jl:19\ntest set: Test Failed at /tmp/tmp2cv_k267.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp2cv_k267.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2cv_k267.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2cv_k267.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnpk0_nh7.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnpk0_nh7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # Your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptrk1kfkw.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmptrk1kfkw.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptrk1kfkw.jl:19\ntest set: Test Failed at /tmp/tmptrk1kfkw.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptrk1kfkw.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptrk1kfkw.jl:19\ntest set: Test Failed at /tmp/tmptrk1kfkw.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptrk1kfkw.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptrk1kfkw.jl:19\ntest set: Test Failed at /tmp/tmptrk1kfkw.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptrk1kfkw.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptrk1kfkw.jl:19\ntest set: Test Failed at /tmp/tmptrk1kfkw.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmptrk1kfkw.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptrk1kfkw.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptrk1kfkw.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    \"\"\"\n    Given an array\
    \ arr of integers, find the minimum number of elements that\n    need to be changed\
    \ to make the array palindromic. A palindromic array is an array that\n    is\
    \ read the same backwards and forwards. In one change, you can change one element\
    \ to any other element.\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0j2v6lyu.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0j2v6lyu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzkfv1c3e.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzkfv1c3e.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqkcjz2gy.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpqkcjz2gy.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqkcjz2gy.jl:19\\ntest set: Test Failed at /tmp/tmpqkcjz2gy.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqkcjz2gy.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqkcjz2gy.jl:19\\ntest set: Test Failed at /tmp/tmpqkcjz2gy.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqkcjz2gy.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqkcjz2gy.jl:19\\ntest set: Test Failed at /tmp/tmpqkcjz2gy.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqkcjz2gy.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqkcjz2gy.jl:19\\ntest set: Test Failed at /tmp/tmpqkcjz2gy.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpqkcjz2gy.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqkcjz2gy.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     5      8\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp4ywzha2b.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp4ywzha2b.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4ywzha2b.jl:19\\ntest set: Test Failed at /tmp/tmp4ywzha2b.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp4ywzha2b.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4ywzha2b.jl:19\\ntest set: Test Failed at /tmp/tmp4ywzha2b.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp4ywzha2b.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4ywzha2b.jl:19\\ntest set: Test Failed at /tmp/tmp4ywzha2b.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp4ywzha2b.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4ywzha2b.jl:19\\ntest set: Test Failed at /tmp/tmp4ywzha2b.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp4ywzha2b.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4ywzha2b.jl:19\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return arr[1] == arr[2]\
    \ ? 0 : 1\n    end\n    if n == 3\n        return arr[1] == arr[3] ? 0 : 1\n \
    \   end\n    if n == 4\n        return arr[1] == arr[4] ? 0 : 1\n    end\n   \
    \ if n == 5\n        return arr[1] == arr[5] ? 0 : 1\n    end\n    if n == 6\n\
    \        return arr[1] == arr[6] ? 0 : 1\n    end\n    if n == 7\n        return\
    \ arr[1] == arr[7] ? 0 : 1\n    end\n    if n == 8\n        return arr[1] == arr[8]\
    \ ? 0 : 1\n    end\n    if n == 9\n        return arr[1] == arr[9] ? 0 : 1\n \
    \   end\n    if n == 10\n        return arr[1] == arr[10] ? 0 : 1\n    end\n \
    \   if n == 11\n        return arr[1] == arr[11] ? 0 : 1\n    end\n    if n ==\
    \ 12\n        return arr[1] == arr[12] ? 0 : 1\n    end\n    if n == 13\n    \
    \    return arr[1] == arr[13] ? 0 : 1\n    end\n    if n == 14\n        return\
    \ arr[1] == arr[14] ? 0 : 1\n    end\n    if n == 15\n        return arr[1] ==\
    \ arr[15] ? 0 : 1\n    end\n    if n == 16\n        return arr[1] == arr[16] ?\
    \ 0 : 1\n    end\n    if n == 17\n        return arr[1] == arr[17] ? 0 : 1\n \
    \   end\n    if n == 18\n        return arr[1] == arr[18] ? 0 : 1\n    end\n \
    \   if n == 19\n        return arr[1] == arr[19] ? 0 : 1\n    end\n    if n ==\
    \ 20\n        return arr[1] == arr[20] ? 0 : 1\n    end\n    if n == 21\n    \
    \    return arr[1] == arr[\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpziql8qdh.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpziql8qdh.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb16ipon0.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb16ipon0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzcvvtjyv.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzcvvtjyv.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzcvvtjyv.jl:19\ntest set: Test Failed at /tmp/tmpzcvvtjyv.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzcvvtjyv.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzcvvtjyv.jl:19\ntest set: Test Failed at /tmp/tmpzcvvtjyv.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzcvvtjyv.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzcvvtjyv.jl:19\ntest set: Test Failed at /tmp/tmpzcvvtjyv.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzcvvtjyv.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzcvvtjyv.jl:19\ntest set: Test Failed at /tmp/tmpzcvvtjyv.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpzcvvtjyv.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzcvvtjyv.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzcvvtjyv.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxi968sw2.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxi968sw2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr6klejw6.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpr6klejw6.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr6klejw6.jl:19\ntest set: Test Failed at /tmp/tmpr6klejw6.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr6klejw6.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr6klejw6.jl:19\ntest set: Test Failed at /tmp/tmpr6klejw6.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr6klejw6.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr6klejw6.jl:19\ntest set: Test Failed at /tmp/tmpr6klejw6.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr6klejw6.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr6klejw6.jl:19\ntest set: Test Failed at /tmp/tmpr6klejw6.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpr6klejw6.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr6klejw6.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr6klejw6.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 1\n    end\n    if n == 4\n        return 2\n    end\n\
    \    if n == 5\n        return 2\n    end\n    if n == 6\n        return 3\n \
    \   end\n    if n == 7\n        return 3\n    end\n    if n == 8\n        return\
    \ 4\n    end\n    if n == 9\n        return 4\n    end\n    if n == 10\n     \
    \   return 5\n    end\n    if n == 11\n        return 5\n    end\n    if n ==\
    \ 12\n        return 6\n    end\n    if n == 13\n        return 6\n    end\n \
    \   if n == 14\n        return 7\n    end\n    if n == 15\n        return 7\n\
    \    end\n    if n == 16\n        return 8\n    end\n    if n == 17\n        return\
    \ 8\n    end\n    if n == 18\n        return 9\n    end\n    if n == 19\n    \
    \    return 9\n    end\n    if n == 20\n        return 10\n    end\n    if n ==\
    \ 21\n        return 10\n    end\n    if n == 22\n        return 11\n    end\n\
    \    if n == 23\n        return 11\n    end\n    if n == 24\n        return 12\n\
    \    end\n    if n == 25\n        return 12\n    end\n    if n == 26\n       \
    \ return 13\n    end\n    if n == 27\n        return 13\n    end\n    if n ==\
    \ 28\n        return 14\n    end\n    if n == 29\n        return 14\n    end\n\
    \    if n == 30\n        return 15\n    end\n    if n == 31\n        return 15\n\
    \    end\n    if n == 32\n        return 16\n    end\n    if n == 33\n       \
    \ return 16\n    end\n    if n == 34\n        return 17\n    end\n    if n ==\
    \ 35\n        return 17\n    end\n    if n == 36\n        return 18\n    end\n\
    \    if n == 37\n        return 18\n    end\n    if n == 38\n        return 19\n\
    \    end\n    if n == 39\n        return 19\nusing Test\n\n@testset begin\n\n\
    candidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\
    \t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) ==\
    \ 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1])\
    \ == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\
    \t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv9wyrpqm.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv9wyrpqm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n % 2 == 0\n        return n - 2\n    end\n    return n - 1\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp7wiat_f.jl:29\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 6 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpp7wiat_f.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp7wiat_f.jl:28\ntest set: Test Failed at /tmp/tmpp7wiat_f.jl:30\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 6 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp7wiat_f.jl:30\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp7wiat_f.jl:28\ntest set: Test Failed at /tmp/tmpp7wiat_f.jl:31\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp7wiat_f.jl:31\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp7wiat_f.jl:28\ntest set: Test Failed at /tmp/tmpp7wiat_f.jl:32\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp7wiat_f.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp7wiat_f.jl:28\ntest set: Test Failed at /tmp/tmpp7wiat_f.jl:33\n\
    \  Expression: candidate([1, 2, 3, 2, 1]) == 0\n   Evaluated: 4 == 0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp7wiat_f.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp7wiat_f.jl:28\ntest set: Test Failed at /tmp/tmpp7wiat_f.jl:34\n\
    \  Expression: candidate([3, 1, 1, 3]) == 0\n   Evaluated: 2 == 0\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp7wiat_f.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp7wiat_f.jl:28\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp7wiat_f.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfd41vefu.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpfd41vefu.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfd41vefu.jl:19\ntest set: Test Failed at /tmp/tmpfd41vefu.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfd41vefu.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfd41vefu.jl:19\ntest set: Test Failed at /tmp/tmpfd41vefu.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfd41vefu.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfd41vefu.jl:19\ntest set: Test Failed at /tmp/tmpfd41vefu.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfd41vefu.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfd41vefu.jl:19\ntest set: Test Failed at /tmp/tmpfd41vefu.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpfd41vefu.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfd41vefu.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfd41vefu.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # Your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp6emhlh29.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp6emhlh29.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6emhlh29.jl:19\\ntest set: Test Failed at /tmp/tmp6emhlh29.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp6emhlh29.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6emhlh29.jl:19\\ntest set: Test Failed at /tmp/tmp6emhlh29.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp6emhlh29.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6emhlh29.jl:19\\ntest set: Test Failed at /tmp/tmp6emhlh29.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp6emhlh29.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6emhlh29.jl:19\\ntest set: Test Failed at /tmp/tmp6emhlh29.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp6emhlh29.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6emhlh29.jl:19\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk77b34wq.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpk77b34wq.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk77b34wq.jl:19\ntest set: Test Failed at /tmp/tmpk77b34wq.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk77b34wq.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk77b34wq.jl:19\ntest set: Test Failed at /tmp/tmpk77b34wq.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk77b34wq.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk77b34wq.jl:19\ntest set: Test Failed at /tmp/tmpk77b34wq.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk77b34wq.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk77b34wq.jl:19\ntest set: Test Failed at /tmp/tmpk77b34wq.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpk77b34wq.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk77b34wq.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk77b34wq.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphty82_3x.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphty82_3x.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg2aehfy8.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg2aehfy8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptvaysay9.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptvaysay9.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwq2k3_qd.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwq2k3_qd.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5u54og39.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5u54og39.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5u54og39.jl:19\ntest set: Test Failed at /tmp/tmp5u54og39.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5u54og39.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5u54og39.jl:19\ntest set: Test Failed at /tmp/tmp5u54og39.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5u54og39.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5u54og39.jl:19\ntest set: Test Failed at /tmp/tmp5u54og39.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5u54og39.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5u54og39.jl:19\ntest set: Test Failed at /tmp/tmp5u54og39.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp5u54og39.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5u54og39.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5u54og39.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpid9h3wea.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpid9h3wea.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid9h3wea.jl:19\ntest set: Test Failed at /tmp/tmpid9h3wea.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpid9h3wea.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid9h3wea.jl:19\ntest set: Test Failed at /tmp/tmpid9h3wea.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpid9h3wea.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid9h3wea.jl:19\ntest set: Test Failed at /tmp/tmpid9h3wea.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpid9h3wea.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid9h3wea.jl:19\ntest set: Test Failed at /tmp/tmpid9h3wea.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpid9h3wea.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpid9h3wea.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpid9h3wea.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpudsfh4r3.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpudsfh4r3.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpudsfh4r3.jl:19\ntest set: Test Failed at /tmp/tmpudsfh4r3.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpudsfh4r3.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpudsfh4r3.jl:19\ntest set: Test Failed at /tmp/tmpudsfh4r3.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpudsfh4r3.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpudsfh4r3.jl:19\ntest set: Test Failed at /tmp/tmpudsfh4r3.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpudsfh4r3.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpudsfh4r3.jl:19\ntest set: Test Failed at /tmp/tmpudsfh4r3.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpudsfh4r3.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpudsfh4r3.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpudsfh4r3.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n % 2 == 0\n        return smallest_change_even(arr)\n\
    \    else\n        return smallest_change_odd(arr)\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpw_hv62j6.jl:27\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  UndefVarError: smallest_change_even\
    \ not defined\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpw_hv62j6.jl:17\n\
    \   [2] top-level scope at /tmp/tmpw_hv62j6.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw_hv62j6.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpw_hv62j6.jl:28\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  UndefVarError: smallest_change_odd not defined\n\
    \  Stacktrace:\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpw_hv62j6.jl:19\n\
    \   [2] top-level scope at /tmp/tmpw_hv62j6.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw_hv62j6.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpw_hv62j6.jl:29\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  UndefVarError: smallest_change_odd not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpw_hv62j6.jl:19\n   [2] top-level\
    \ scope at /tmp/tmpw_hv62j6.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw_hv62j6.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpw_hv62j6.jl:30\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  UndefVarError: smallest_change_even not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpw_hv62j6.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw_hv62j6.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw_hv62j6.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpw_hv62j6.jl:31\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  UndefVarError: smallest_change_odd not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpw_hv62j6.jl:19\n   [2] top-level\
    \ scope at /tmp/tmpw_hv62j6.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw_hv62j6.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpw_hv62j6.jl:32\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  UndefVarError: smallest_change_even not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpw_hv62j6.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw_hv62j6.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw_hv62j6.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmpw_hv62j6.jl:34\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  UndefVarError: smallest_change_even not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpw_hv62j6.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw_hv62j6.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw_hv62j6.jl:26\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      7      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw_hv62j6.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps3jy8kwx.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmps3jy8kwx.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8fupannf.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp8fupannf.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8fupannf.jl:19\ntest set: Test Failed at /tmp/tmp8fupannf.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8fupannf.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8fupannf.jl:19\ntest set: Test Failed at /tmp/tmp8fupannf.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8fupannf.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8fupannf.jl:19\ntest set: Test Failed at /tmp/tmp8fupannf.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8fupannf.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8fupannf.jl:19\ntest set: Test Failed at /tmp/tmp8fupannf.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp8fupannf.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8fupannf.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8fupannf.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4rx35d79.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4rx35d79.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpah8bgjgg.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpah8bgjgg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdw1c16qt.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdw1c16qt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # Your code here\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3a6yfkkn.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp3a6yfkkn.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3a6yfkkn.jl:19\ntest set: Test Failed at /tmp/tmp3a6yfkkn.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3a6yfkkn.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3a6yfkkn.jl:19\ntest set: Test Failed at /tmp/tmp3a6yfkkn.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3a6yfkkn.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3a6yfkkn.jl:19\ntest set: Test Failed at /tmp/tmp3a6yfkkn.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3a6yfkkn.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3a6yfkkn.jl:19\ntest set: Test Failed at /tmp/tmp3a6yfkkn.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp3a6yfkkn.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3a6yfkkn.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3a6yfkkn.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3ej79xbw.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp3ej79xbw.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3ej79xbw.jl:19\ntest set: Test Failed at /tmp/tmp3ej79xbw.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3ej79xbw.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3ej79xbw.jl:19\ntest set: Test Failed at /tmp/tmp3ej79xbw.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3ej79xbw.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3ej79xbw.jl:19\ntest set: Test Failed at /tmp/tmp3ej79xbw.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3ej79xbw.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3ej79xbw.jl:19\ntest set: Test Failed at /tmp/tmp3ej79xbw.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp3ej79xbw.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3ej79xbw.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3ej79xbw.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps4gku5yh.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmps4gku5yh.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps4gku5yh.jl:19\ntest set: Test Failed at /tmp/tmps4gku5yh.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps4gku5yh.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps4gku5yh.jl:19\ntest set: Test Failed at /tmp/tmps4gku5yh.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps4gku5yh.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps4gku5yh.jl:19\ntest set: Test Failed at /tmp/tmps4gku5yh.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps4gku5yh.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps4gku5yh.jl:19\ntest set: Test Failed at /tmp/tmps4gku5yh.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmps4gku5yh.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps4gku5yh.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps4gku5yh.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpksm8ssub.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpksm8ssub.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # your code here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpg0p6dpop.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpg0p6dpop.jl:13\\\
    n   [2] top-level scope at /tmp/tmpg0p6dpop.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpg0p6dpop.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpg0p6dpop.jl:20\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg0p6dpop.jl:13\\n   [2] top-level scope at /tmp/tmpg0p6dpop.jl:20\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpg0p6dpop.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpg0p6dpop.jl:21\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 4, 2]) == 1\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg0p6dpop.jl:13\\n   [2] top-level scope at /tmp/tmpg0p6dpop.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpg0p6dpop.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpg0p6dpop.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg0p6dpop.jl:13\\n   [2] top-level scope at /tmp/tmpg0p6dpop.jl:22\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpg0p6dpop.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpg0p6dpop.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg0p6dpop.jl:13\\n   [2] top-level scope at /tmp/tmpg0p6dpop.jl:23\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpg0p6dpop.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpg0p6dpop.jl:24\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg0p6dpop.jl:13\\n   [2] top-level scope at /tmp/tmpg0p6dpop.jl:24\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpg0p6dpop.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpg0p6dpop.jl:25\\n  Test threw exception\\n  Expression: candidate([1])\
    \ == 0\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg0p6dpop.jl:13\\n   [2] top-level scope at /tmp/tmpg0p6dpop.jl:25\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpg0p6dpop.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpg0p6dpop.jl:26\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 1]) == 1\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpg0p6dpop.jl:13\\n   [2] top-level scope at /tmp/tmpg0p6dpop.jl:26\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpg0p6dpop.jl:18\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpm02k_bcd.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpm02k_bcd.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpm02k_bcd.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm02k_bcd.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpm02k_bcd.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpm02k_bcd.jl:13\n   [2] top-level scope at /tmp/tmpm02k_bcd.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm02k_bcd.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpm02k_bcd.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpm02k_bcd.jl:13\n   [2] top-level scope at /tmp/tmpm02k_bcd.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm02k_bcd.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpm02k_bcd.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpm02k_bcd.jl:13\n   [2] top-level scope at /tmp/tmpm02k_bcd.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm02k_bcd.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpm02k_bcd.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpm02k_bcd.jl:13\n   [2] top-level scope at /tmp/tmpm02k_bcd.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm02k_bcd.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpm02k_bcd.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpm02k_bcd.jl:13\n   [2] top-level scope at /tmp/tmpm02k_bcd.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm02k_bcd.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpm02k_bcd.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpm02k_bcd.jl:13\n   [2] top-level scope at /tmp/tmpm02k_bcd.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm02k_bcd.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpm02k_bcd.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpm02k_bcd.jl:13\n   [2] top-level scope at /tmp/tmpm02k_bcd.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm02k_bcd.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm02k_bcd.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpxai04nc5.jl:20\\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\\n   Evaluated: 0 == 4\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpxai04nc5.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxai04nc5.jl:19\\ntest set: Test Failed at /tmp/tmpxai04nc5.jl:21\\\
    n  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\\n   Evaluated: 0 == 1\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpxai04nc5.jl:21\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxai04nc5.jl:19\\ntest set: Test Failed at /tmp/tmpxai04nc5.jl:22\\\
    n  Expression: candidate([1, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpxai04nc5.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxai04nc5.jl:19\\ntest set: Test Failed at /tmp/tmpxai04nc5.jl:23\\\
    n  Expression: candidate([1, 4, 4, 2]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpxai04nc5.jl:23\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxai04nc5.jl:19\\ntest set: Test Failed at /tmp/tmpxai04nc5.jl:27\\\
    n  Expression: candidate([0, 1]) == 1\\n   Evaluated: 0 == 1\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpxai04nc5.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxai04nc5.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     5      8\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    # if the\
    \ array is already a palindrome, return 0\n    if ispalindrome(arr)\n        return\
    \ 0\n    end\n    # if the array is not a palindrome, find the minimum number\
    \ of changes\n    # needed to make it a palindrome\n    # initialize the minimum\
    \ number of changes to the maximum possible\n    min_changes = n\n    # loop through\
    \ all possible starting points for the left side of the array\n    for i in 1:n\n\
    \        # loop through all possible starting points for the right side of the\
    \ array\n        for j in i:n\n            # initialize the number of changes\
    \ to 0\n            changes = 0\n            # loop through the array from the\
    \ left starting point to the right starting point\n            for k in i:j\n\
    \                # if the value at the current index is not equal to the value\
    \ at the\n                # mirrored index, increment the number of changes\n\
    \                if arr[k] != arr[2*j - k + 1]\n                    changes +=\
    \ 1\n                end\n            end\n            # if the number of changes\
    \ is less than the current minimum number of changes,\n            # update the\
    \ minimum number of changes\n            if changes < min_changes\n          \
    \      min_changes = changes\n            end\n        end\n    end\n    # return\
    \ the minimum number of changes\n    return min_changes\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa4cu5v1k.jl:50\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  UndefVarError: ispalindrome\
    \ not defined\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpa4cu5v1k.jl:14\n\
    \   [2] top-level scope at /tmp/tmpa4cu5v1k.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa4cu5v1k.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpa4cu5v1k.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  UndefVarError: ispalindrome not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpa4cu5v1k.jl:14\n   [2] top-level\
    \ scope at /tmp/tmpa4cu5v1k.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa4cu5v1k.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpa4cu5v1k.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  UndefVarError: ispalindrome not defined\n  Stacktrace:\n   [1]\
    \ smallest_change(::Array{Int64,1}) at /tmp/tmpa4cu5v1k.jl:14\n   [2] top-level\
    \ scope at /tmp/tmpa4cu5v1k.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa4cu5v1k.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpa4cu5v1k.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  UndefVarError: ispalindrome not defined\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpa4cu5v1k.jl:14\n   [2] top-level\
    \ scope at /tmp/tmpa4cu5v1k.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa4cu5v1k.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpa4cu5v1k.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  UndefVarError: ispalindrome not defined\n  Stacktrace:\n\
    \   [1] smallest_change(::Array{Int64,1}) at /tmp/tmpa4cu5v1k.jl:14\n   [2] top-level\
    \ scope at /tmp/tmpa4cu5v1k.jl:54\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa4cu5v1k.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpa4cu5v1k.jl:55\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  UndefVarError: ispalindrome not defined\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpa4cu5v1k.jl:14\n   [2] top-level\
    \ scope at /tmp/tmpa4cu5v1k.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa4cu5v1k.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpa4cu5v1k.jl:56\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  UndefVarError: ispalindrome not defined\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpa4cu5v1k.jl:14\n   [2] top-level scope at /tmp/tmpa4cu5v1k.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa4cu5v1k.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpa4cu5v1k.jl:57\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  UndefVarError: ispalindrome not defined\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpa4cu5v1k.jl:14\n   [2] top-level scope at /tmp/tmpa4cu5v1k.jl:57\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa4cu5v1k.jl:49\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa4cu5v1k.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvgvsthdl.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvgvsthdl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2qzhd51v.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2qzhd51v.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qzhd51v.jl:19\ntest set: Test Failed at /tmp/tmp2qzhd51v.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2qzhd51v.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qzhd51v.jl:19\ntest set: Test Failed at /tmp/tmp2qzhd51v.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2qzhd51v.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qzhd51v.jl:19\ntest set: Test Failed at /tmp/tmp2qzhd51v.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2qzhd51v.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qzhd51v.jl:19\ntest set: Test Failed at /tmp/tmp2qzhd51v.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp2qzhd51v.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2qzhd51v.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2qzhd51v.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpst1tt5xr.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpst1tt5xr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]))\n    end\n    if n == 4\n        return min(abs(arr[1] - arr[2]), abs(arr[2]\
    \ - arr[3]), abs(arr[3] - arr[4]))\n    end\n    if n == 5\n        return min(abs(arr[1]\
    \ - arr[2]), abs(arr[2] - arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]))\n\
    \    end\n    if n == 6\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]))\n\
    \    end\n    if n == 7\n        return min(abs(arr[1] - arr[2]), abs(arr[2] -\
    \ arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]), abs(arr[6]\
    \ - arr[7]))\n    end\n    if n == 8\n        return min(abs(arr[1] - arr[2]),\
    \ abs(arr[2] - arr[3]), abs(arr[3] - arr[4]), abs(arr[4] - arr[5]), abs(arr[5]\
    \ - arr[6]), abs(arr[6] - arr[7]), abs(arr[7] - arr[8]))\n    end\n    if n ==\
    \ 9\n        return min(abs(arr[1] - arr[2]), abs(arr[2] - arr[3]), abs(arr[3]\
    \ - arr[4]), abs(arr[4] - arr[5]), abs(arr[5] - arr[6]), abs(arr[6] - arr[7]),\
    \ abs(arr[\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk0fdlwut.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk0fdlwut.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement your solution\
    \ here\n    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnt54g3nq.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpnt54g3nq.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnt54g3nq.jl:19\ntest set: Test Failed at /tmp/tmpnt54g3nq.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnt54g3nq.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnt54g3nq.jl:19\ntest set: Test Failed at /tmp/tmpnt54g3nq.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnt54g3nq.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnt54g3nq.jl:19\ntest set: Test Failed at /tmp/tmpnt54g3nq.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnt54g3nq.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnt54g3nq.jl:19\ntest set: Test Failed at /tmp/tmpnt54g3nq.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpnt54g3nq.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnt54g3nq.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnt54g3nq.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: implement this function\n\
    \    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd2yc5iti.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpd2yc5iti.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd2yc5iti.jl:19\ntest set: Test Failed at /tmp/tmpd2yc5iti.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd2yc5iti.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd2yc5iti.jl:19\ntest set: Test Failed at /tmp/tmpd2yc5iti.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd2yc5iti.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd2yc5iti.jl:19\ntest set: Test Failed at /tmp/tmpd2yc5iti.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd2yc5iti.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd2yc5iti.jl:19\ntest set: Test Failed at /tmp/tmpd2yc5iti.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpd2yc5iti.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd2yc5iti.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd2yc5iti.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsfx4ia5q.jl:50\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 17 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpsfx4ia5q.jl:50\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsfx4ia5q.jl:49\nTest Summary: | Pass  Fail  Total\n\
    test set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsfx4ia5q.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for l in 2:n\n \
    \       for i in 1:n-l+1\n            j = i+l-1\n            if arr[i] == arr[j]\n\
    \                dp[i, j] = dp[i+1, j-1]\n            else\n                dp[i,\
    \ j] = min(dp[i+1, j], dp[i, j-1]) + 1\n            end\n        end\n    end\n\
    \    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbzj2yubb.jl:34\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 7 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbzj2yubb.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbzj2yubb.jl:33\ntest set: Test Failed at /tmp/tmpbzj2yubb.jl:35\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbzj2yubb.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbzj2yubb.jl:33\ntest set: Test Failed at /tmp/tmpbzj2yubb.jl:36\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbzj2yubb.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbzj2yubb.jl:33\ntest set: Test Failed at /tmp/tmpbzj2yubb.jl:37\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbzj2yubb.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbzj2yubb.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     4      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbzj2yubb.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiw7cmx7z.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpiw7cmx7z.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiw7cmx7z.jl:19\ntest set: Test Failed at /tmp/tmpiw7cmx7z.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiw7cmx7z.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiw7cmx7z.jl:19\ntest set: Test Failed at /tmp/tmpiw7cmx7z.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiw7cmx7z.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiw7cmx7z.jl:19\ntest set: Test Failed at /tmp/tmpiw7cmx7z.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiw7cmx7z.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiw7cmx7z.jl:19\ntest set: Test Failed at /tmp/tmpiw7cmx7z.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpiw7cmx7z.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiw7cmx7z.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiw7cmx7z.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\n    return\
    \ 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9phu2m87.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp9phu2m87.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9phu2m87.jl:19\ntest set: Test Failed at /tmp/tmp9phu2m87.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9phu2m87.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9phu2m87.jl:19\ntest set: Test Failed at /tmp/tmp9phu2m87.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9phu2m87.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9phu2m87.jl:19\ntest set: Test Failed at /tmp/tmp9phu2m87.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9phu2m87.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9phu2m87.jl:19\ntest set: Test Failed at /tmp/tmp9phu2m87.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp9phu2m87.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9phu2m87.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9phu2m87.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for l in 2:n\n \
    \       for i in 1:n-l+1\n            j = i+l-1\n            if arr[i] == arr[j]\n\
    \                dp[i, j] = dp[i+1, j-1]\n            else\n                dp[i,\
    \ j] = min(dp[i+1, j], dp[i, j-1]) + 1\n            end\n        end\n    end\n\
    \    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmputmtsoka.jl:34\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 7 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmputmtsoka.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmputmtsoka.jl:33\ntest set: Test Failed at /tmp/tmputmtsoka.jl:35\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmputmtsoka.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmputmtsoka.jl:33\ntest set: Test Failed at /tmp/tmputmtsoka.jl:36\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmputmtsoka.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmputmtsoka.jl:33\ntest set: Test Failed at /tmp/tmputmtsoka.jl:37\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 2 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmputmtsoka.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmputmtsoka.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     4      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmputmtsoka.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1qazzpia.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1qazzpia.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmmyg31u4.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmmyg31u4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq_gq6y0h.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq_gq6y0h.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg9uolcp4.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg9uolcp4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    dp = zeros(Int64,\
    \ n, n)\n    for i in 1:n\n        dp[i, i] = 0\n    end\n    for l in 2:n\n \
    \       for i in 1:n-l+1\n            j = i+l-1\n            dp[i, j] = minimum(dp[i+1,\
    \ j], dp[i, j-1]) + 1\n            if arr[i] == arr[j]\n                dp[i,\
    \ j] = minimum(dp[i, j], dp[i+1, j-1])\n            end\n        end\n    end\n\
    \    return dp[1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp66hiiy9x.jl:33\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: objects\
    \ of type Int64 are not callable\n  Stacktrace:\n   [1] mapreduce_first(::Int64,\
    \ ::Function, ::Int64) at ./reduce.jl:384\n   [2] mapreduce(::Int64, ::Function,\
    \ ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64, ::Int64) at ./reduce.jl:628\n\
    \   [4] smallest_change(::Array{Int64,1}) at /tmp/tmp66hiiy9x.jl:20\n   [5] top-level\
    \ scope at /tmp/tmp66hiiy9x.jl:33\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp66hiiy9x.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp66hiiy9x.jl:34\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: objects of type Int64 are not callable\n\
    \  Stacktrace:\n   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n\
    \   [2] mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmp66hiiy9x.jl:20\n\
    \   [5] top-level scope at /tmp/tmp66hiiy9x.jl:34\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp66hiiy9x.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp66hiiy9x.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: objects of type Int64 are not callable\n  Stacktrace:\n\
    \   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n   [2]\
    \ mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmp66hiiy9x.jl:20\n\
    \   [5] top-level scope at /tmp/tmp66hiiy9x.jl:35\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp66hiiy9x.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp66hiiy9x.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: objects of type Int64 are not callable\n  Stacktrace:\n\
    \   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n   [2]\
    \ mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmp66hiiy9x.jl:20\n\
    \   [5] top-level scope at /tmp/tmp66hiiy9x.jl:36\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp66hiiy9x.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp66hiiy9x.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: objects of type Int64 are not callable\n \
    \ Stacktrace:\n   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n\
    \   [2] mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmp66hiiy9x.jl:20\n\
    \   [5] top-level scope at /tmp/tmp66hiiy9x.jl:37\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp66hiiy9x.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp66hiiy9x.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: objects of type Int64 are not callable\n  Stacktrace:\n\
    \   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n   [2]\
    \ mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmp66hiiy9x.jl:20\n\
    \   [5] top-level scope at /tmp/tmp66hiiy9x.jl:38\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp66hiiy9x.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp66hiiy9x.jl:40\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: objects of type Int64 are not callable\n  Stacktrace:\n\
    \   [1] mapreduce_first(::Int64, ::Function, ::Int64) at ./reduce.jl:384\n   [2]\
    \ mapreduce(::Int64, ::Function, ::Int64) at ./reduce.jl:411\n   [3] minimum(::Int64,\
    \ ::Int64) at ./reduce.jl:628\n   [4] smallest_change(::Array{Int64,1}) at /tmp/tmp66hiiy9x.jl:20\n\
    \   [5] top-level scope at /tmp/tmp66hiiy9x.jl:40\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp66hiiy9x.jl:32\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      7      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp66hiiy9x.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return 1\n    end\n   \
    \ if n == 3\n        return 2\n    end\n    if n == 4\n        return 3\n    end\n\
    \    if n == 5\n        return 4\n    end\n    if n == 6\n        return 5\n \
    \   end\n    if n == 7\n        return 6\n    end\n    if n == 8\n        return\
    \ 7\n    end\n    if n == 9\n        return 8\n    end\n    if n == 10\n     \
    \   return 9\n    end\n    if n == 11\n        return 10\n    end\n    if n ==\
    \ 12\n        return 11\n    end\n    if n == 13\n        return 12\n    end\n\
    \    if n == 14\n        return 13\n    end\n    if n == 15\n        return 14\n\
    \    end\n    if n == 16\n        return 15\n    end\n    if n == 17\n       \
    \ return 16\n    end\n    if n == 18\n        return 17\n    end\n    if n ==\
    \ 19\n        return 18\n    end\n    if n == 20\n        return 19\n    end\n\
    \    if n == 21\n        return 20\n    end\n    if n == 22\n        return 21\n\
    \    end\n    if n == 23\n        return 22\n    end\n    if n == 24\n       \
    \ return 23\n    end\n    if n == 25\n        return 24\n    end\n    if n ==\
    \ 26\n        return 25\n    end\n    if n == 27\n        return 26\n    end\n\
    \    if n == 28\n        return 27\n    end\n    if n == 29\n        return 28\n\
    \    end\n    if n == 30\n        return 29\n    end\n    if n == 31\n       \
    \ return 30\n    end\n    if n == 32\n        return 31\n    end\n    if n ==\
    \ 33\n        return 32\n    end\n    if n == 34\n        return 33\n    end\n\
    \    if n == 35\n        return 34\n    end\n    if n == 36\n        return 35\n\
    \    end\n    if n == 37\n        return 36\n    end\n    if n == 38\n       \
    \ return 37\n    end\n    if n == 39\n        return 38\nusing Test\n\n@testset\
    \ begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7,\
    \ 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkyhisiik.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkyhisiik.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr71altf7.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr71altf7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # YOUR CODE HERE\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\
    \t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t\
    @test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\
    \t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpocjust88.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] smallest_change(::Array{Int64,1}) at /tmp/tmpocjust88.jl:13\n   [2] top-level\
    \ scope at /tmp/tmpocjust88.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpocjust88.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpocjust88.jl:20\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 3, 2, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpocjust88.jl:13\n   [2] top-level scope at /tmp/tmpocjust88.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpocjust88.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpocjust88.jl:21\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpocjust88.jl:13\n   [2] top-level scope at /tmp/tmpocjust88.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpocjust88.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpocjust88.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ 4, 4, 2]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpocjust88.jl:13\n   [2] top-level scope at /tmp/tmpocjust88.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpocjust88.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpocjust88.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 2, 1]) == 0\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpocjust88.jl:13\n   [2] top-level scope at /tmp/tmpocjust88.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpocjust88.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpocjust88.jl:24\n  Test threw exception\n  Expression: candidate([3,\
    \ 1, 1, 3]) == 0\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpocjust88.jl:13\n   [2] top-level scope at /tmp/tmpocjust88.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpocjust88.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpocjust88.jl:25\n  Test threw exception\n  Expression: candidate([1])\
    \ == 0\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpocjust88.jl:13\n   [2] top-level scope at /tmp/tmpocjust88.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpocjust88.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpocjust88.jl:26\n  Test threw exception\n  Expression: candidate([0,\
    \ 1]) == 1\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] smallest_change(::Array{Int64,1})\
    \ at /tmp/tmpocjust88.jl:13\n   [2] top-level scope at /tmp/tmpocjust88.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpocjust88.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpocjust88.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    # TODO: Implement me!\n   \
    \ return 0\nend\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\
    \t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3,\
    \ 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3,\
    \ 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) ==\
    \ 1)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvxllre5h.jl:20\n  Expression: candidate([1,\
    \ 2, 3, 5, 4, 7, 9, 6]) == 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpvxllre5h.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvxllre5h.jl:19\ntest set: Test Failed at /tmp/tmpvxllre5h.jl:21\n\
    \  Expression: candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvxllre5h.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvxllre5h.jl:19\ntest set: Test Failed at /tmp/tmpvxllre5h.jl:22\n\
    \  Expression: candidate([1, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvxllre5h.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvxllre5h.jl:19\ntest set: Test Failed at /tmp/tmpvxllre5h.jl:23\n\
    \  Expression: candidate([1, 4, 4, 2]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvxllre5h.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvxllre5h.jl:19\ntest set: Test Failed at /tmp/tmpvxllre5h.jl:27\n\
    \  Expression: candidate([0, 1]) == 1\n   Evaluated: 0 == 1\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpvxllre5h.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvxllre5h.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     5      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvxllre5h.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array arr of integers, find the minimum number of\
    \ elements that\n    need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n\n    For example:\n\
    \    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4,\
    \ 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\nfunction\
    \ smallest_change(arr::Vector{Int64})::Int64 \n    n = length(arr)\n    if n ==\
    \ 1\n        return 0\n    end\n    if n == 2\n        return abs(arr[1] - arr[2])\n\
    \    end\n    if n == 3\n        return abs(arr[1] - arr[3])\n    end\n    if\
    \ n == 4\n        return abs(arr[1] - arr[4]) + abs(arr[2] - arr[3])\n    end\n\
    \    if n == 5\n        return abs(arr[1] - arr[5]) + abs(arr[2] - arr[4])\n \
    \   end\n    if n == 6\n        return abs(arr[1] - arr[6]) + abs(arr[2] - arr[5])\
    \ + abs(arr[3] - arr[4])\n    end\n    if n == 7\n        return abs(arr[1] -\
    \ arr[7]) + abs(arr[2] - arr[6]) + abs(arr[3] - arr[5])\n    end\n    if n ==\
    \ 8\n        return abs(arr[1] - arr[8]) + abs(arr[2] - arr[7]) + abs(arr[3] -\
    \ arr[6]) + abs(arr[4] - arr[5])\n    end\n    if n == 9\n        return abs(arr[1]\
    \ - arr[9]) + abs(arr[2] - arr[8]) + abs(arr[3] - arr[7]) + abs(arr[4] - arr[6])\n\
    \    end\n    if n == 10\n        return abs(arr[1] - arr[10]) + abs(arr[2] -\
    \ arr[9]) + abs(arr[3] - arr[8]) + abs(arr[4] - arr[7]) + abs(arr[5] - arr[6])\n\
    \    end\n    if n == 11\n        return abs(arr[1] - arr[11]) + abs(arr[2] -\
    \ arr[10]) + abs(arr[3] - arr[9]) + abs(arr[4] - arr[8]) + abs(arr[5] - arr[7])\n\
    \    end\n    if n == 12\n        return abs(arr[1] - arr[12]) +\nusing Test\n\
    \n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3,\
    \ 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1,\
    \ 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2,\
    \ 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1])\
    \ == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6qatoel_.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6qatoel_.jl:1\n"
  exit_code: 1
  status: SyntaxError
