name: HumanEval_104_unique_digits
language: julia
results:
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return [i for i in x if !(any(i % 2 == 0 for i in digits(i)))]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgyl5h39u.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgyl5h39u.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgyl5h39u.jl:19\ntest set: Test Failed at /tmp/tmpgyl5h39u.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpgyl5h39u.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgyl5h39u.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgyl5h39u.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return [i for i in x if !any(dig in [\"0\", \"2\", \"4\", \"6\", \"8\"] for\
    \ dig in string(i))]\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1mimygih.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1422, 1] == [1, 15, 33]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1mimygih.jl:20\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1mimygih.jl:19\ntest set: Test Failed at /tmp/tmp1mimygih.jl:21\n\
    \  Expression: candidate([152, 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated:\
    \ [152, 323, 1422, 10] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp1mimygih.jl:21\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1mimygih.jl:19\ntest set: Test Failed at /tmp/tmp1mimygih.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [12345, 2033, 111, 151] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp1mimygih.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1mimygih.jl:19\ntest set: Test Failed at /tmp/tmp1mimygih.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 103,\
    \ 31] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp1mimygih.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1mimygih.jl:19\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1mimygih.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp14xa890x.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp14xa890x.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp14xa890x.jl:20\ntest set: Test Failed at /tmp/tmp14xa890x.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp14xa890x.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp14xa890x.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp14xa890x.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> all(digits(x) .% 2 .!= 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code goes here\n    return [i for i in x if all(j % 2 == 1 for j in\
    \ digits(i))]\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpfh1ccyb3.jl:21\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: [15, 33, 1] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpfh1ccyb3.jl:21\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfh1ccyb3.jl:20\\ntest set: Test Failed at /tmp/tmpfh1ccyb3.jl:24\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: [135, 31]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfh1ccyb3.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfh1ccyb3.jl:20\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     2      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp28p85ok4.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp28p85ok4.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28p85ok4.jl:20\ntest set: Test Failed at /tmp/tmp28p85ok4.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp28p85ok4.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28p85ok4.jl:20\ntest set: Test Failed at /tmp/tmp28p85ok4.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp28p85ok4.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28p85ok4.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp28p85ok4.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp94bgd33n.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp94bgd33n.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp94bgd33n.jl:20\ntest set: Test Failed at /tmp/tmp94bgd33n.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp94bgd33n.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp94bgd33n.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp94bgd33n.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # TODO: write your code here\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuqritez9.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuqritez9.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuqritez9.jl:20\ntest set: Test Failed at /tmp/tmpuqritez9.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpuqritez9.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuqritez9.jl:20\ntest set: Test Failed at /tmp/tmpuqritez9.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpuqritez9.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuqritez9.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuqritez9.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !has_even_digit(i)\n            push!(y,\
    \ i)\n        end\n    end\n    return sort(y)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15,\
    \ 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345,\
    \ 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmprvw850wr.jl:26\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  UndefVarError: has_even_digit\
    \ not defined\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmprvw850wr.jl:15\n\
    \   [2] top-level scope at /tmp/tmprvw850wr.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprvw850wr.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmprvw850wr.jl:27\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmprvw850wr.jl:15\n\
    \   [2] top-level scope at /tmp/tmprvw850wr.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprvw850wr.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmprvw850wr.jl:28\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmprvw850wr.jl:15\n\
    \   [2] top-level scope at /tmp/tmprvw850wr.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprvw850wr.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmprvw850wr.jl:29\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  UndefVarError: has_even_digit not defined\n  Stacktrace:\n\
    \   [1] unique_digits(::Array{Int64,1}) at /tmp/tmprvw850wr.jl:15\n   [2] top-level\
    \ scope at /tmp/tmprvw850wr.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprvw850wr.jl:25\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprvw850wr.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> all(digits(x) .% 2 .!= 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    unique_digits = []\n    for i in x\n        if !(any(i\
    \ % 2 == 0 for i in digits(i)))\n            push!(unique_digits, i)\n       \
    \ end\n    end\n    return sort(unique_digits)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15,\
    \ 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345,\
    \ 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcunz5djv.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcunz5djv.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcunz5djv.jl:20\ntest set: Test Failed at /tmp/tmpcunz5djv.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpcunz5djv.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcunz5djv.jl:20\ntest set: Test Failed at /tmp/tmpcunz5djv.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpcunz5djv.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcunz5djv.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcunz5djv.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjse8152q.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpjse8152q.jl:14\n\
    \   [2] top-level scope at /tmp/tmpjse8152q.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjse8152q.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpjse8152q.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpjse8152q.jl:14\n\
    \   [2] top-level scope at /tmp/tmpjse8152q.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjse8152q.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpjse8152q.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpjse8152q.jl:14\n\
    \   [2] top-level scope at /tmp/tmpjse8152q.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjse8152q.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpjse8152q.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpjse8152q.jl:14\n\
    \   [2] top-level scope at /tmp/tmpjse8152q.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjse8152q.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjse8152q.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return filter(x) do x\n        !any(isodd, digits(x))\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpij58ujz0.jl:22\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpij58ujz0.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpij58ujz0.jl:21\ntest set: Test Failed at /tmp/tmpij58ujz0.jl:24\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpij58ujz0.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpij58ujz0.jl:21\ntest set: Test Failed at /tmp/tmpij58ujz0.jl:25\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpij58ujz0.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpij58ujz0.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpij58ujz0.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return x[findall(x) do xi\n        !any(isodd, digits(xi))\n    end]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpnpuiwp9e.jl:22\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: Int64[] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzfxi4co5.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpzfxi4co5.jl:14\n\
    \   [2] top-level scope at /tmp/tmpzfxi4co5.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfxi4co5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfxi4co5.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpzfxi4co5.jl:14\n\
    \   [2] top-level scope at /tmp/tmpzfxi4co5.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfxi4co5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfxi4co5.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpzfxi4co5.jl:14\n\
    \   [2] top-level scope at /tmp/tmpzfxi4co5.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfxi4co5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpzfxi4co5.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpzfxi4co5.jl:14\n\
    \   [2] top-level scope at /tmp/tmpzfxi4co5.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzfxi4co5.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzfxi4co5.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if !any(i % 10 == 0 for i in x)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6tfr1h9x.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1422, 1] == [1, 15, 33]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6tfr1h9x.jl:21\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6tfr1h9x.jl:20\ntest set: Test Failed at /tmp/tmp6tfr1h9x.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [12345, 2033, 111, 151] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp6tfr1h9x.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6tfr1h9x.jl:20\ntest set: Test Failed at /tmp/tmp6tfr1h9x.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 103,\
    \ 31] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp6tfr1h9x.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6tfr1h9x.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6tfr1h9x.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgwcer83n.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgwcer83n.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgwcer83n.jl:20\ntest set: Test Failed at /tmp/tmpgwcer83n.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpgwcer83n.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgwcer83n.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgwcer83n.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_xz7cq__.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_xz7cq__.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_xz7cq__.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_xz7cq__.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_xz7cq__.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_xz7cq__.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_xz7cq__.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_xz7cq__.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_xz7cq__.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_xz7cq__.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_xz7cq__.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_xz7cq__.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_xz7cq__.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_xz7cq__.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_xz7cq__.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_xz7cq__.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_xz7cq__.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x) do x\n        x_str = string(x)\n        !occursin(r\"\
    [02468]\", x_str)\n    end)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return filter(x) do xi\n        !any(isodd, digits(xi))\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqqnk9rmg.jl:22\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: Int64[] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqqnk9rmg.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqqnk9rmg.jl:21\\ntest set: Test Failed at /tmp/tmpqqnk9rmg.jl:24\\\
    n  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\\n   Evaluated:\
    \ Int64[] == [111, 151]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqqnk9rmg.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqqnk9rmg.jl:21\\ntest set: Test Failed at /tmp/tmpqqnk9rmg.jl:25\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: Int64[]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqqnk9rmg.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqqnk9rmg.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    y = []\n    for i in x\n        if !contains(digits(i),2)\
    \ && !contains(digits(i),4) && !contains(digits(i),6) && !contains(digits(i),8)\n\
    \            push!(y,i)\n        end\n    end\n    return sort(y)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmptaeki8y9.jl:27\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  UndefVarError: contains\
    \ not defined\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmptaeki8y9.jl:16\n\
    \   [2] top-level scope at /tmp/tmptaeki8y9.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptaeki8y9.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmptaeki8y9.jl:28\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  UndefVarError: contains not defined\n\
    \  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmptaeki8y9.jl:16\n\
    \   [2] top-level scope at /tmp/tmptaeki8y9.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptaeki8y9.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmptaeki8y9.jl:29\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] unique_digits(::Array{Int64,1}) at /tmp/tmptaeki8y9.jl:16\n   [2] top-level\
    \ scope at /tmp/tmptaeki8y9.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptaeki8y9.jl:26\n  \ntest set: Error During\
    \ Test at /tmp/tmptaeki8y9.jl:30\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] unique_digits(::Array{Int64,1}) at /tmp/tmptaeki8y9.jl:16\n   [2] top-level\
    \ scope at /tmp/tmptaeki8y9.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptaeki8y9.jl:26\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptaeki8y9.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpv8wtrszm.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpv8wtrszm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpv8wtrszm.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8wtrszm.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpv8wtrszm.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpv8wtrszm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpv8wtrszm.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8wtrszm.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpv8wtrszm.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpv8wtrszm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpv8wtrszm.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8wtrszm.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpv8wtrszm.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpv8wtrszm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpv8wtrszm.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8wtrszm.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv8wtrszm.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(isodd, digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw3j8dyiz.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw3j8dyiz.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw3j8dyiz.jl:19\ntest set: Test Failed at /tmp/tmpw3j8dyiz.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpw3j8dyiz.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw3j8dyiz.jl:19\ntest set: Test Failed at /tmp/tmpw3j8dyiz.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpw3j8dyiz.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw3j8dyiz.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw3j8dyiz.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpykwjxhxq.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpykwjxhxq.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpykwjxhxq.jl:20\ntest set: Test Failed at /tmp/tmpykwjxhxq.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpykwjxhxq.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpykwjxhxq.jl:20\ntest set: Test Failed at /tmp/tmpykwjxhxq.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpykwjxhxq.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpykwjxhxq.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpykwjxhxq.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(i -> i % 2 == 0, digits(x)), x))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return [i for i in x if all(d % 2 != 0 for d in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmnv6dwu0.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmnv6dwu0.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmnv6dwu0.jl:20\ntest set: Test Failed at /tmp/tmpmnv6dwu0.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpmnv6dwu0.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmnv6dwu0.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmnv6dwu0.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(x[findall(x) do x\n        x_str = string(x)\n        !occursin(r\"\
    [02468]\", x_str)\n    end])\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpc1j8h_4n.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpc1j8h_4n.jl:14\n\
    \   [2] top-level scope at /tmp/tmpc1j8h_4n.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc1j8h_4n.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpc1j8h_4n.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpc1j8h_4n.jl:14\n\
    \   [2] top-level scope at /tmp/tmpc1j8h_4n.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc1j8h_4n.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpc1j8h_4n.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpc1j8h_4n.jl:14\n\
    \   [2] top-level scope at /tmp/tmpc1j8h_4n.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc1j8h_4n.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpc1j8h_4n.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpc1j8h_4n.jl:14\n\
    \   [2] top-level scope at /tmp/tmpc1j8h_4n.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc1j8h_4n.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc1j8h_4n.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9evqf8__.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9evqf8__.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9evqf8__.jl:20\ntest set: Test Failed at /tmp/tmp9evqf8__.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp9evqf8__.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9evqf8__.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9evqf8__.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    x_unique = []\n    for i in x\n        if !any(i % 2 == 0 for i in digits(i))\n\
    \            push!(x_unique, i)\n        end\n    end\n    sort(x_unique)\nend\n\
    using Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3s0773g_.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3s0773g_.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3s0773g_.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3s0773g_.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp3s0773g_.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3s0773g_.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3s0773g_.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3s0773g_.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp3s0773g_.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3s0773g_.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3s0773g_.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3s0773g_.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp3s0773g_.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3s0773g_.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3s0773g_.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3s0773g_.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3s0773g_.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j%2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp44uvpw7g.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp44uvpw7g.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp44uvpw7g.jl:20\ntest set: Test Failed at /tmp/tmp44uvpw7g.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp44uvpw7g.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp44uvpw7g.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp44uvpw7g.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxr10gsze.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxr10gsze.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxr10gsze.jl:20\ntest set: Test Failed at /tmp/tmpxr10gsze.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpxr10gsze.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxr10gsze.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxr10gsze.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if !any(i % 2 == 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpafwcjtpt.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpafwcjtpt.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpafwcjtpt.jl:20\ntest set: Test Failed at /tmp/tmpafwcjtpt.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpafwcjtpt.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpafwcjtpt.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpafwcjtpt.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprce62mqy.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprce62mqy.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprce62mqy.jl:20\ntest set: Test Failed at /tmp/tmprce62mqy.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmprce62mqy.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprce62mqy.jl:20\ntest set: Test Failed at /tmp/tmprce62mqy.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmprce62mqy.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprce62mqy.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprce62mqy.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6ln35bay.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6ln35bay.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ln35bay.jl:20\ntest set: Test Failed at /tmp/tmp6ln35bay.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp6ln35bay.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ln35bay.jl:20\ntest set: Test Failed at /tmp/tmp6ln35bay.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp6ln35bay.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ln35bay.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ln35bay.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    x_unique = Int64[]\n    for i in x\n        if iseven(i) == false\n     \
    \       push!(x_unique, i)\n        end\n    end\n    sort(x_unique)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpslf3vit0.jl:27\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated: [323] == Int64[]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpslf3vit0.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpslf3vit0.jl:25\ntest set: Test Failed at /tmp/tmpslf3vit0.jl:28\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [111, 151, 2033, 12345] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpslf3vit0.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpslf3vit0.jl:25\ntest set: Test Failed at /tmp/tmpslf3vit0.jl:29\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [31, 103,\
    \ 135] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpslf3vit0.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpslf3vit0.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpslf3vit0.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if !(any(i % 2 == 0 for i in digits(i)))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp92hn8c5s.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp92hn8c5s.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp92hn8c5s.jl:20\ntest set: Test Failed at /tmp/tmp92hn8c5s.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp92hn8c5s.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp92hn8c5s.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp92hn8c5s.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if !any(i % 2 == 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4600i7v9.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4600i7v9.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4600i7v9.jl:20\ntest set: Test Failed at /tmp/tmp4600i7v9.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp4600i7v9.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4600i7v9.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4600i7v9.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return [i for i in x if !any(i % 2 == 0 for i in digits(i))]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpti32fdo8.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpti32fdo8.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpti32fdo8.jl:19\ntest set: Test Failed at /tmp/tmpti32fdo8.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpti32fdo8.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpti32fdo8.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpti32fdo8.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphk85pocf.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmphk85pocf.jl:14\n\
    \   [2] top-level scope at /tmp/tmphk85pocf.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphk85pocf.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmphk85pocf.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmphk85pocf.jl:14\n\
    \   [2] top-level scope at /tmp/tmphk85pocf.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphk85pocf.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmphk85pocf.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmphk85pocf.jl:14\n\
    \   [2] top-level scope at /tmp/tmphk85pocf.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphk85pocf.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmphk85pocf.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmphk85pocf.jl:14\n\
    \   [2] top-level scope at /tmp/tmphk85pocf.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphk85pocf.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphk85pocf.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    x_unique = []\n    for i in x\n        if !(any(i % 2 == 0 for i in digits(i)))\n\
    \            push!(x_unique, i)\n        end\n    end\n    return sort(x_unique)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !has_even_digit(x), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpsw0wclu0.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\\n  UndefVarError:\
    \ has_even_digit not defined\\n  Stacktrace:\\n   [1] (::var\"#3#4\")(::Int64)\
    \ at /tmp/tmpsw0wclu0.jl:13\\n   [2] filter(::var\"#3#4\", ::Array{Int64,1}) at\
    \ ./array.jl:2375\\n   [3] unique_digits(::Array{Int64,1}) at /tmp/tmpsw0wclu0.jl:13\\\
    n   [4] top-level scope at /tmp/tmpsw0wclu0.jl:20\\n   [5] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [6] top-level scope at /tmp/tmpsw0wclu0.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsw0wclu0.jl:21\\n  Test threw exception\\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\\n  UndefVarError: has_even_digit not defined\\\
    n  Stacktrace:\\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmpsw0wclu0.jl:13\\n\
    \   [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmpsw0wclu0.jl:13\\n   [4] top-level scope at /tmp/tmpsw0wclu0.jl:21\\\
    n   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [6] top-level scope at /tmp/tmpsw0wclu0.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsw0wclu0.jl:22\\n  Test threw exception\\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\\n  UndefVarError: has_even_digit not defined\\\
    n  Stacktrace:\\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmpsw0wclu0.jl:13\\n\
    \   [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmpsw0wclu0.jl:13\\n   [4] top-level scope at /tmp/tmpsw0wclu0.jl:22\\\
    n   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [6] top-level scope at /tmp/tmpsw0wclu0.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsw0wclu0.jl:23\\n  Test threw exception\\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\\n  UndefVarError: has_even_digit not defined\\n  Stacktrace:\\\
    n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmpsw0wclu0.jl:13\\n   [2] filter(::var\"\
    #3#4\", ::Array{Int64,1}) at ./array.jl:2375\\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmpsw0wclu0.jl:13\\n   [4] top-level scope at /tmp/tmpsw0wclu0.jl:23\\\
    n   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [6] top-level scope at /tmp/tmpsw0wclu0.jl:19\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !(any(i % 2 == 0 for i in digits(i)))\n\
    \            push!(y, i)\n        end\n    end\n    return sort(y)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return filter(x) do x\n        for i in digits(x)\n            if i % 2 ==\
    \ 0\n                return false\n            end\n        end\n        return\
    \ true\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppus_n6bs.jl:27\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppus_n6bs.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppus_n6bs.jl:26\ntest set: Test Failed at /tmp/tmppus_n6bs.jl:30\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmppus_n6bs.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppus_n6bs.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppus_n6bs.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcde35ztq.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpcde35ztq.jl:14\n\
    \   [2] top-level scope at /tmp/tmpcde35ztq.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcde35ztq.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpcde35ztq.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpcde35ztq.jl:14\n\
    \   [2] top-level scope at /tmp/tmpcde35ztq.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcde35ztq.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpcde35ztq.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpcde35ztq.jl:14\n\
    \   [2] top-level scope at /tmp/tmpcde35ztq.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcde35ztq.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpcde35ztq.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpcde35ztq.jl:14\n\
    \   [2] top-level scope at /tmp/tmpcde35ztq.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcde35ztq.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcde35ztq.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return [i for i in x if all(i%2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdbe402at.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdbe402at.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdbe402at.jl:20\ntest set: Test Failed at /tmp/tmpdbe402at.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpdbe402at.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdbe402at.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdbe402at.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpu3ruitl4.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu3ruitl4.jl:14\n\
    \   [2] top-level scope at /tmp/tmpu3ruitl4.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu3ruitl4.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3ruitl4.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu3ruitl4.jl:14\n\
    \   [2] top-level scope at /tmp/tmpu3ruitl4.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu3ruitl4.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3ruitl4.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu3ruitl4.jl:14\n\
    \   [2] top-level scope at /tmp/tmpu3ruitl4.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu3ruitl4.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3ruitl4.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu3ruitl4.jl:14\n\
    \   [2] top-level scope at /tmp/tmpu3ruitl4.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu3ruitl4.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu3ruitl4.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\n \n \n \nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpt_fyb6hl.jl:23\\n  Test threw\
    \ exception\\n  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpt_fyb6hl.jl:14\\\
    n   [2] top-level scope at /tmp/tmpt_fyb6hl.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpt_fyb6hl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpt_fyb6hl.jl:24\\n  Test threw exception\\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpt_fyb6hl.jl:14\\\
    n   [2] top-level scope at /tmp/tmpt_fyb6hl.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpt_fyb6hl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpt_fyb6hl.jl:25\\n  Test threw exception\\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpt_fyb6hl.jl:14\\\
    n   [2] top-level scope at /tmp/tmpt_fyb6hl.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpt_fyb6hl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpt_fyb6hl.jl:26\\n  Test threw exception\\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpt_fyb6hl.jl:14\\\
    n   [2] top-level scope at /tmp/tmpt_fyb6hl.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpt_fyb6hl.jl:22\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9x6xjp5a.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9x6xjp5a.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9x6xjp5a.jl:20\ntest set: Test Failed at /tmp/tmp9x6xjp5a.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp9x6xjp5a.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9x6xjp5a.jl:20\ntest set: Test Failed at /tmp/tmp9x6xjp5a.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp9x6xjp5a.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9x6xjp5a.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9x6xjp5a.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return x\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6ii4kyy2.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1422, 1] == [1, 15, 33]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6ii4kyy2.jl:21\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ii4kyy2.jl:20\ntest set: Test Failed at /tmp/tmp6ii4kyy2.jl:22\n\
    \  Expression: candidate([152, 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated:\
    \ [152, 323, 1422, 10] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp6ii4kyy2.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ii4kyy2.jl:20\ntest set: Test Failed at /tmp/tmp6ii4kyy2.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [12345, 2033, 111, 151] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp6ii4kyy2.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ii4kyy2.jl:20\ntest set: Test Failed at /tmp/tmp6ii4kyy2.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 103,\
    \ 31] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp6ii4kyy2.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ii4kyy2.jl:20\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ii4kyy2.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return x\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp28ytwlxd.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1422, 1] == [1, 15, 33]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp28ytwlxd.jl:21\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28ytwlxd.jl:20\ntest set: Test Failed at /tmp/tmp28ytwlxd.jl:22\n\
    \  Expression: candidate([152, 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated:\
    \ [152, 323, 1422, 10] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp28ytwlxd.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28ytwlxd.jl:20\ntest set: Test Failed at /tmp/tmp28ytwlxd.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [12345, 2033, 111, 151] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp28ytwlxd.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28ytwlxd.jl:20\ntest set: Test Failed at /tmp/tmp28ytwlxd.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 103,\
    \ 31] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp28ytwlxd.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28ytwlxd.jl:20\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp28ytwlxd.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpay_fs315.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpay_fs315.jl:14\n\
    \   [2] top-level scope at /tmp/tmpay_fs315.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpay_fs315.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpay_fs315.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpay_fs315.jl:14\n\
    \   [2] top-level scope at /tmp/tmpay_fs315.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpay_fs315.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpay_fs315.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpay_fs315.jl:14\n\
    \   [2] top-level scope at /tmp/tmpay_fs315.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpay_fs315.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpay_fs315.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpay_fs315.jl:14\n\
    \   [2] top-level scope at /tmp/tmpay_fs315.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpay_fs315.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpay_fs315.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x->!any(isodd, digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpowit870q.jl:20\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: Int64[] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpowit870q.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpowit870q.jl:19\\ntest set: Test Failed at /tmp/tmpowit870q.jl:22\\\
    n  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\\n   Evaluated:\
    \ Int64[] == [111, 151]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpowit870q.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpowit870q.jl:19\\ntest set: Test Failed at /tmp/tmpowit870q.jl:23\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: Int64[]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpowit870q.jl:23\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpowit870q.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk0203jru.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk0203jru.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk0203jru.jl:20\ntest set: Test Failed at /tmp/tmpk0203jru.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpk0203jru.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk0203jru.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk0203jru.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2ygyoswl.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2ygyoswl.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2ygyoswl.jl:20\ntest set: Test Failed at /tmp/tmp2ygyoswl.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp2ygyoswl.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2ygyoswl.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2ygyoswl.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return filter(x) do x\n        !any(isodd, digits(x))\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp38rjnbed.jl:22\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp38rjnbed.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp38rjnbed.jl:21\ntest set: Test Failed at /tmp/tmp38rjnbed.jl:24\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp38rjnbed.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp38rjnbed.jl:21\ntest set: Test Failed at /tmp/tmp38rjnbed.jl:25\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp38rjnbed.jl:25\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp38rjnbed.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp38rjnbed.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(i % 2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp110qca0q.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp110qca0q.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp110qca0q.jl:20\ntest set: Test Failed at /tmp/tmp110qca0q.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp110qca0q.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp110qca0q.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp110qca0q.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpjivaqpxm.jl:21\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: [15, 33, 1] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpjivaqpxm.jl:21\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjivaqpxm.jl:20\\ntest set: Test Failed at /tmp/tmpjivaqpxm.jl:24\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: [135, 31]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpjivaqpxm.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjivaqpxm.jl:20\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     2      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxjnjc2sm.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxjnjc2sm.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxjnjc2sm.jl:20\ntest set: Test Failed at /tmp/tmpxjnjc2sm.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpxjnjc2sm.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxjnjc2sm.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxjnjc2sm.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    x_unique = []\n    for i in x\n        if !(any(isodd, digits(i)))\n    \
    \        push!(x_unique, i)\n        end\n    end\n    sort(x_unique)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7qfznxeo.jl:26\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7qfznxeo.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7qfznxeo.jl:25\ntest set: Test Failed at /tmp/tmp7qfznxeo.jl:28\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp7qfznxeo.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7qfznxeo.jl:25\ntest set: Test Failed at /tmp/tmp7qfznxeo.jl:29\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp7qfznxeo.jl:29\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7qfznxeo.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7qfznxeo.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return x\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbi5kac7d.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1422, 1] == [1, 15, 33]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbi5kac7d.jl:21\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbi5kac7d.jl:20\ntest set: Test Failed at /tmp/tmpbi5kac7d.jl:22\n\
    \  Expression: candidate([152, 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated:\
    \ [152, 323, 1422, 10] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpbi5kac7d.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbi5kac7d.jl:20\ntest set: Test Failed at /tmp/tmpbi5kac7d.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [12345, 2033, 111, 151] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpbi5kac7d.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbi5kac7d.jl:20\ntest set: Test Failed at /tmp/tmpbi5kac7d.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 103,\
    \ 31] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpbi5kac7d.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbi5kac7d.jl:20\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbi5kac7d.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpu28m_pdi.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu28m_pdi.jl:14\\\
    n   [2] top-level scope at /tmp/tmpu28m_pdi.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu28m_pdi.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu28m_pdi.jl:21\\n  Test threw exception\\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu28m_pdi.jl:14\\\
    n   [2] top-level scope at /tmp/tmpu28m_pdi.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu28m_pdi.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu28m_pdi.jl:22\\n  Test threw exception\\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu28m_pdi.jl:14\\\
    n   [2] top-level scope at /tmp/tmpu28m_pdi.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu28m_pdi.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu28m_pdi.jl:23\\n  Test threw exception\\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu28m_pdi.jl:14\\\
    n   [2] top-level scope at /tmp/tmpu28m_pdi.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu28m_pdi.jl:19\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # Your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1qffclyn.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp1qffclyn.jl:14\n\
    \   [2] top-level scope at /tmp/tmp1qffclyn.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1qffclyn.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp1qffclyn.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp1qffclyn.jl:14\n\
    \   [2] top-level scope at /tmp/tmp1qffclyn.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1qffclyn.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp1qffclyn.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp1qffclyn.jl:14\n\
    \   [2] top-level scope at /tmp/tmp1qffclyn.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1qffclyn.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp1qffclyn.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp1qffclyn.jl:14\n\
    \   [2] top-level scope at /tmp/tmp1qffclyn.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1qffclyn.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1qffclyn.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if i % 2 == 0\n            continue\n   \
    \     else\n            push!(y, i)\n        end\n    end\n    return sort(y)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprkg41ri3.jl:29\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated: [323] == Int64[]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprkg41ri3.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprkg41ri3.jl:27\ntest set: Test Failed at /tmp/tmprkg41ri3.jl:30\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [111, 151, 2033, 12345] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmprkg41ri3.jl:30\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprkg41ri3.jl:27\ntest set: Test Failed at /tmp/tmprkg41ri3.jl:31\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [31, 103,\
    \ 135] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmprkg41ri3.jl:31\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprkg41ri3.jl:27\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprkg41ri3.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplqbejvh9.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplqbejvh9.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplqbejvh9.jl:20\ntest set: Test Failed at /tmp/tmplqbejvh9.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmplqbejvh9.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplqbejvh9.jl:20\ntest set: Test Failed at /tmp/tmplqbejvh9.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmplqbejvh9.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplqbejvh9.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplqbejvh9.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa1p__2b8.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpa1p__2b8.jl:14\n\
    \   [2] top-level scope at /tmp/tmpa1p__2b8.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1p__2b8.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1p__2b8.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpa1p__2b8.jl:14\n\
    \   [2] top-level scope at /tmp/tmpa1p__2b8.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1p__2b8.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1p__2b8.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpa1p__2b8.jl:14\n\
    \   [2] top-level scope at /tmp/tmpa1p__2b8.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1p__2b8.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpa1p__2b8.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpa1p__2b8.jl:14\n\
    \   [2] top-level scope at /tmp/tmpa1p__2b8.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa1p__2b8.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa1p__2b8.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl_xkfd1w.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpl_xkfd1w.jl:14\n\
    \   [2] top-level scope at /tmp/tmpl_xkfd1w.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl_xkfd1w.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpl_xkfd1w.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpl_xkfd1w.jl:14\n\
    \   [2] top-level scope at /tmp/tmpl_xkfd1w.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl_xkfd1w.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpl_xkfd1w.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpl_xkfd1w.jl:14\n\
    \   [2] top-level scope at /tmp/tmpl_xkfd1w.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl_xkfd1w.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpl_xkfd1w.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpl_xkfd1w.jl:14\n\
    \   [2] top-level scope at /tmp/tmpl_xkfd1w.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl_xkfd1w.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl_xkfd1w.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if !has_even_digit(i)]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpru4iri_b.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  UndefVarError: has_even_digit\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at ./none:0\n  \
    \ [2] iterate at ./iterators.jl:430 [inlined]\n   [3] iterate at ./generator.jl:44\
    \ [inlined]\n   [4] grow_to!(::Array{Int64,1}, ::Base.Generator{Base.Iterators.Filter{var\"\
    #3#4\",Array{Int64,1}},typeof(identity)}) at ./array.jl:726\n   [5] collect at\
    \ ./array.jl:663 [inlined]\n   [6] unique_digits(::Array{Int64,1}) at /tmp/tmpru4iri_b.jl:14\n\
    \   [7] top-level scope at /tmp/tmpru4iri_b.jl:21\n   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpru4iri_b.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpru4iri_b.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at ./none:0\n   [2] iterate at\
    \ ./iterators.jl:430 [inlined]\n   [3] iterate at ./generator.jl:44 [inlined]\n\
    \   [4] grow_to!(::Array{Int64,1}, ::Base.Generator{Base.Iterators.Filter{var\"\
    #3#4\",Array{Int64,1}},typeof(identity)}) at ./array.jl:726\n   [5] collect at\
    \ ./array.jl:663 [inlined]\n   [6] unique_digits(::Array{Int64,1}) at /tmp/tmpru4iri_b.jl:14\n\
    \   [7] top-level scope at /tmp/tmpru4iri_b.jl:22\n   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpru4iri_b.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpru4iri_b.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at ./none:0\n   [2] iterate at\
    \ ./iterators.jl:430 [inlined]\n   [3] iterate at ./generator.jl:44 [inlined]\n\
    \   [4] grow_to!(::Array{Int64,1}, ::Base.Generator{Base.Iterators.Filter{var\"\
    #3#4\",Array{Int64,1}},typeof(identity)}) at ./array.jl:726\n   [5] collect at\
    \ ./array.jl:663 [inlined]\n   [6] unique_digits(::Array{Int64,1}) at /tmp/tmpru4iri_b.jl:14\n\
    \   [7] top-level scope at /tmp/tmpru4iri_b.jl:23\n   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpru4iri_b.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpru4iri_b.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  UndefVarError: has_even_digit not defined\n  Stacktrace:\n\
    \   [1] (::var\"#3#4\")(::Int64) at ./none:0\n   [2] iterate at ./iterators.jl:430\
    \ [inlined]\n   [3] iterate at ./generator.jl:44 [inlined]\n   [4] grow_to!(::Array{Int64,1},\
    \ ::Base.Generator{Base.Iterators.Filter{var\"#3#4\",Array{Int64,1}},typeof(identity)})\
    \ at ./array.jl:726\n   [5] collect at ./array.jl:663 [inlined]\n   [6] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmpru4iri_b.jl:14\n   [7] top-level scope at /tmp/tmpru4iri_b.jl:24\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpru4iri_b.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpru4iri_b.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    x_unique = Int64[]\n    for i in x\n        if !(contains(string(i), \"2\"\
    ) || contains(string(i), \"4\") || contains(string(i), \"6\") || contains(string(i),\
    \ \"8\") || contains(string(i), \"0\"))\n            push!(x_unique, i)\n    \
    \    end\n    end\n    return sort(x_unique)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15,\
    \ 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345,\
    \ 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpgkbnql6m.jl:26\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  UndefVarError: contains\
    \ not defined\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpgkbnql6m.jl:15\n\
    \   [2] top-level scope at /tmp/tmpgkbnql6m.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgkbnql6m.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpgkbnql6m.jl:27\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  UndefVarError: contains not defined\n\
    \  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpgkbnql6m.jl:15\n\
    \   [2] top-level scope at /tmp/tmpgkbnql6m.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgkbnql6m.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpgkbnql6m.jl:28\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpgkbnql6m.jl:15\n   [2] top-level\
    \ scope at /tmp/tmpgkbnql6m.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgkbnql6m.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpgkbnql6m.jl:29\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpgkbnql6m.jl:15\n   [2] top-level\
    \ scope at /tmp/tmpgkbnql6m.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgkbnql6m.jl:25\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgkbnql6m.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    #raise NotImplementedError()\n    return [i for i in\
    \ x if all(i % 2 != 0 for i in digits(i))]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15,\
    \ 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345,\
    \ 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpx6u14w5d.jl:22\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx6u14w5d.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx6u14w5d.jl:21\ntest set: Test Failed at /tmp/tmpx6u14w5d.jl:25\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpx6u14w5d.jl:25\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx6u14w5d.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx6u14w5d.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp0z3f8dbw.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp0z3f8dbw.jl:14\\\
    n   [2] top-level scope at /tmp/tmp0z3f8dbw.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0z3f8dbw.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0z3f8dbw.jl:21\\n  Test threw exception\\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp0z3f8dbw.jl:14\\\
    n   [2] top-level scope at /tmp/tmp0z3f8dbw.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0z3f8dbw.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0z3f8dbw.jl:22\\n  Test threw exception\\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp0z3f8dbw.jl:14\\\
    n   [2] top-level scope at /tmp/tmp0z3f8dbw.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0z3f8dbw.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0z3f8dbw.jl:23\\n  Test threw exception\\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp0z3f8dbw.jl:14\\\
    n   [2] top-level scope at /tmp/tmp0z3f8dbw.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0z3f8dbw.jl:19\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return [i for i in x if all(i % 2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpayinpnk0.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpayinpnk0.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpayinpnk0.jl:20\ntest set: Test Failed at /tmp/tmpayinpnk0.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpayinpnk0.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpayinpnk0.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpayinpnk0.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpztjdzm6z.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpztjdzm6z.jl:14\n\
    \   [2] top-level scope at /tmp/tmpztjdzm6z.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpztjdzm6z.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpztjdzm6z.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpztjdzm6z.jl:14\n\
    \   [2] top-level scope at /tmp/tmpztjdzm6z.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpztjdzm6z.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpztjdzm6z.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpztjdzm6z.jl:14\n\
    \   [2] top-level scope at /tmp/tmpztjdzm6z.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpztjdzm6z.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpztjdzm6z.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpztjdzm6z.jl:14\n\
    \   [2] top-level scope at /tmp/tmpztjdzm6z.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpztjdzm6z.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpztjdzm6z.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !(any(i % 2 == 0 for i in digits(i)))\n\
    \            push!(y, i)\n        end\n    end\n    return sort(y)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !any(i % 2 == 0 for i in digits(i))\n\
    \            push!(y, i)\n        end\n    end\n    sort(y)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp51vb2vfn.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp51vb2vfn.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp51vb2vfn.jl:20\ntest set: Test Failed at /tmp/tmp51vb2vfn.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp51vb2vfn.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp51vb2vfn.jl:20\ntest set: Test Failed at /tmp/tmp51vb2vfn.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp51vb2vfn.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp51vb2vfn.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp51vb2vfn.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(isodd, digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp128nan8d.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp128nan8d.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp128nan8d.jl:19\ntest set: Test Failed at /tmp/tmp128nan8d.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp128nan8d.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp128nan8d.jl:19\ntest set: Test Failed at /tmp/tmp128nan8d.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp128nan8d.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp128nan8d.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp128nan8d.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !has_even_digit(x), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_dhoe7ks.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  UndefVarError: has_even_digit\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmp_dhoe7ks.jl:13\n\
    \   [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmp_dhoe7ks.jl:13\n   [4] top-level scope at /tmp/tmp_dhoe7ks.jl:20\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmp_dhoe7ks.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp_dhoe7ks.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmp_dhoe7ks.jl:13\n  \
    \ [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmp_dhoe7ks.jl:13\n   [4] top-level scope at /tmp/tmp_dhoe7ks.jl:21\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmp_dhoe7ks.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp_dhoe7ks.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmp_dhoe7ks.jl:13\n  \
    \ [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmp_dhoe7ks.jl:13\n   [4] top-level scope at /tmp/tmp_dhoe7ks.jl:22\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmp_dhoe7ks.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp_dhoe7ks.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  UndefVarError: has_even_digit not defined\n  Stacktrace:\n\
    \   [1] (::var\"#3#4\")(::Int64) at /tmp/tmp_dhoe7ks.jl:13\n   [2] filter(::var\"\
    #3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmp_dhoe7ks.jl:13\n   [4] top-level scope at /tmp/tmp_dhoe7ks.jl:23\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmp_dhoe7ks.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_dhoe7ks.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_stt08j3.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_stt08j3.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_stt08j3.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_stt08j3.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp_stt08j3.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_stt08j3.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_stt08j3.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_stt08j3.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp_stt08j3.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_stt08j3.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_stt08j3.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_stt08j3.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp_stt08j3.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_stt08j3.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_stt08j3.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_stt08j3.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_stt08j3.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(isodd, digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv2ushnsg.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv2ushnsg.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv2ushnsg.jl:19\ntest set: Test Failed at /tmp/tmpv2ushnsg.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpv2ushnsg.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv2ushnsg.jl:19\ntest set: Test Failed at /tmp/tmpv2ushnsg.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpv2ushnsg.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv2ushnsg.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv2ushnsg.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpyrmdl5k7.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpyrmdl5k7.jl:14\n\
    \   [2] top-level scope at /tmp/tmpyrmdl5k7.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyrmdl5k7.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpyrmdl5k7.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpyrmdl5k7.jl:14\n\
    \   [2] top-level scope at /tmp/tmpyrmdl5k7.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyrmdl5k7.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpyrmdl5k7.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpyrmdl5k7.jl:14\n\
    \   [2] top-level scope at /tmp/tmpyrmdl5k7.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyrmdl5k7.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpyrmdl5k7.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpyrmdl5k7.jl:14\n\
    \   [2] top-level scope at /tmp/tmpyrmdl5k7.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyrmdl5k7.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyrmdl5k7.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> all(digits(x) .% 2 .!= 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(i % 2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfre14ub9.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfre14ub9.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfre14ub9.jl:20\ntest set: Test Failed at /tmp/tmpfre14ub9.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpfre14ub9.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfre14ub9.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfre14ub9.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpurnr0ulh.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpurnr0ulh.jl:14\n\
    \   [2] top-level scope at /tmp/tmpurnr0ulh.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpurnr0ulh.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpurnr0ulh.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpurnr0ulh.jl:14\n\
    \   [2] top-level scope at /tmp/tmpurnr0ulh.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpurnr0ulh.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpurnr0ulh.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpurnr0ulh.jl:14\n\
    \   [2] top-level scope at /tmp/tmpurnr0ulh.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpurnr0ulh.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpurnr0ulh.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpurnr0ulh.jl:14\n\
    \   [2] top-level scope at /tmp/tmpurnr0ulh.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpurnr0ulh.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpurnr0ulh.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpp0xl47tz.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpp0xl47tz.jl:14\n\
    \   [2] top-level scope at /tmp/tmpp0xl47tz.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp0xl47tz.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpp0xl47tz.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpp0xl47tz.jl:14\n\
    \   [2] top-level scope at /tmp/tmpp0xl47tz.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp0xl47tz.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpp0xl47tz.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpp0xl47tz.jl:14\n\
    \   [2] top-level scope at /tmp/tmpp0xl47tz.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp0xl47tz.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpp0xl47tz.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpp0xl47tz.jl:14\n\
    \   [2] top-level scope at /tmp/tmpp0xl47tz.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp0xl47tz.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp0xl47tz.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(i%2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp5ss2dl8a.jl:21\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: [15, 33, 1] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp5ss2dl8a.jl:21\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5ss2dl8a.jl:20\\ntest set: Test Failed at /tmp/tmp5ss2dl8a.jl:24\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: [135, 31]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5ss2dl8a.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5ss2dl8a.jl:20\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbjdp19yh.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbjdp19yh.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbjdp19yh.jl:20\ntest set: Test Failed at /tmp/tmpbjdp19yh.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpbjdp19yh.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbjdp19yh.jl:20\ntest set: Test Failed at /tmp/tmpbjdp19yh.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpbjdp19yh.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbjdp19yh.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbjdp19yh.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpm2ozmjoj.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpm2ozmjoj.jl:14\n\
    \   [2] top-level scope at /tmp/tmpm2ozmjoj.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm2ozmjoj.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpm2ozmjoj.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpm2ozmjoj.jl:14\n\
    \   [2] top-level scope at /tmp/tmpm2ozmjoj.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm2ozmjoj.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpm2ozmjoj.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpm2ozmjoj.jl:14\n\
    \   [2] top-level scope at /tmp/tmpm2ozmjoj.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm2ozmjoj.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpm2ozmjoj.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpm2ozmjoj.jl:14\n\
    \   [2] top-level scope at /tmp/tmpm2ozmjoj.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm2ozmjoj.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm2ozmjoj.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x) do x\n        for i in digits(x)\n            if i\
    \ % 2 == 0\n                return false\n            end\n        end\n     \
    \   return true\n    end)\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpuj51mffm.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpuj51mffm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpuj51mffm.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuj51mffm.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpuj51mffm.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpuj51mffm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpuj51mffm.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuj51mffm.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpuj51mffm.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpuj51mffm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpuj51mffm.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuj51mffm.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpuj51mffm.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpuj51mffm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpuj51mffm.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuj51mffm.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuj51mffm.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpooz34tf8.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpooz34tf8.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpooz34tf8.jl:19\ntest set: Test Failed at /tmp/tmpooz34tf8.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpooz34tf8.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpooz34tf8.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpooz34tf8.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(isodd, digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzpp6wkpm.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzpp6wkpm.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzpp6wkpm.jl:19\ntest set: Test Failed at /tmp/tmpzpp6wkpm.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpzpp6wkpm.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzpp6wkpm.jl:19\ntest set: Test Failed at /tmp/tmpzpp6wkpm.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpzpp6wkpm.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzpp6wkpm.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzpp6wkpm.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5_bu_sfq.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5_bu_sfq.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5_bu_sfq.jl:20\ntest set: Test Failed at /tmp/tmp5_bu_sfq.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp5_bu_sfq.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5_bu_sfq.jl:20\ntest set: Test Failed at /tmp/tmp5_bu_sfq.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp5_bu_sfq.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5_bu_sfq.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5_bu_sfq.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj31cjx__.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj31cjx__.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj31cjx__.jl:20\ntest set: Test Failed at /tmp/tmpj31cjx__.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpj31cjx__.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj31cjx__.jl:20\ntest set: Test Failed at /tmp/tmpj31cjx__.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpj31cjx__.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj31cjx__.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj31cjx__.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return filter(x) do x\n        !any(digits(x) .% 2 .== 0)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp23t6l42m.jl:22\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp23t6l42m.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp23t6l42m.jl:21\ntest set: Test Failed at /tmp/tmp23t6l42m.jl:25\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp23t6l42m.jl:25\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp23t6l42m.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp23t6l42m.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsu4zy148.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpsu4zy148.jl:14\n\
    \   [2] top-level scope at /tmp/tmpsu4zy148.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsu4zy148.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpsu4zy148.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpsu4zy148.jl:14\n\
    \   [2] top-level scope at /tmp/tmpsu4zy148.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsu4zy148.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpsu4zy148.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpsu4zy148.jl:14\n\
    \   [2] top-level scope at /tmp/tmpsu4zy148.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsu4zy148.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpsu4zy148.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpsu4zy148.jl:14\n\
    \   [2] top-level scope at /tmp/tmpsu4zy148.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsu4zy148.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsu4zy148.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    x_unique = []\n    for i in x\n        if !(contains(string(i), \"2\") ||\
    \ contains(string(i), \"4\") || contains(string(i), \"6\") || contains(string(i),\
    \ \"8\") || contains(string(i), \"0\"))\n            push!(x_unique, i)\n    \
    \    end\n    end\n    return sort(x_unique)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15,\
    \ 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345,\
    \ 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpk9lku7w2.jl:26\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  UndefVarError: contains\
    \ not defined\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpk9lku7w2.jl:15\n\
    \   [2] top-level scope at /tmp/tmpk9lku7w2.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9lku7w2.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpk9lku7w2.jl:27\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  UndefVarError: contains not defined\n\
    \  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpk9lku7w2.jl:15\n\
    \   [2] top-level scope at /tmp/tmpk9lku7w2.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9lku7w2.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpk9lku7w2.jl:28\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpk9lku7w2.jl:15\n   [2] top-level\
    \ scope at /tmp/tmpk9lku7w2.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9lku7w2.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpk9lku7w2.jl:29\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpk9lku7w2.jl:15\n   [2] top-level\
    \ scope at /tmp/tmpk9lku7w2.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9lku7w2.jl:25\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk9lku7w2.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [y for y in x if all(i % 2 == 1 for i in digits(y))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnb9zgyml.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnb9zgyml.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnb9zgyml.jl:20\ntest set: Test Failed at /tmp/tmpnb9zgyml.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpnb9zgyml.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnb9zgyml.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnb9zgyml.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(i % 2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjc8je_hy.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjc8je_hy.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjc8je_hy.jl:20\ntest set: Test Failed at /tmp/tmpjc8je_hy.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpjc8je_hy.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjc8je_hy.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjc8je_hy.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(i%2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq5774ing.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq5774ing.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq5774ing.jl:20\ntest set: Test Failed at /tmp/tmpq5774ing.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpq5774ing.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq5774ing.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq5774ing.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6jkhx98s.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp6jkhx98s.jl:14\n\
    \   [2] top-level scope at /tmp/tmp6jkhx98s.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6jkhx98s.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp6jkhx98s.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp6jkhx98s.jl:14\n\
    \   [2] top-level scope at /tmp/tmp6jkhx98s.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6jkhx98s.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp6jkhx98s.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp6jkhx98s.jl:14\n\
    \   [2] top-level scope at /tmp/tmp6jkhx98s.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6jkhx98s.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp6jkhx98s.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp6jkhx98s.jl:14\n\
    \   [2] top-level scope at /tmp/tmp6jkhx98s.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6jkhx98s.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6jkhx98s.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(isodd, digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp2n0rkfup.jl:20\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: Int64[] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp2n0rkfup.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2n0rkfup.jl:19\\ntest set: Test Failed at /tmp/tmp2n0rkfup.jl:22\\\
    n  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\\n   Evaluated:\
    \ Int64[] == [111, 151]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2n0rkfup.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2n0rkfup.jl:19\\ntest set: Test Failed at /tmp/tmp2n0rkfup.jl:23\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: Int64[]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2n0rkfup.jl:23\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2n0rkfup.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjnnt9ael.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjnnt9ael.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjnnt9ael.jl:20\ntest set: Test Failed at /tmp/tmpjnnt9ael.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpjnnt9ael.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjnnt9ael.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjnnt9ael.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpggj9lg8y.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpggj9lg8y.jl:14\n\
    \   [2] top-level scope at /tmp/tmpggj9lg8y.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpggj9lg8y.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpggj9lg8y.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpggj9lg8y.jl:14\n\
    \   [2] top-level scope at /tmp/tmpggj9lg8y.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpggj9lg8y.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpggj9lg8y.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpggj9lg8y.jl:14\n\
    \   [2] top-level scope at /tmp/tmpggj9lg8y.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpggj9lg8y.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpggj9lg8y.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpggj9lg8y.jl:14\n\
    \   [2] top-level scope at /tmp/tmpggj9lg8y.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpggj9lg8y.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpggj9lg8y.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return x\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy86c3gdp.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1422, 1] == [1, 15, 33]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpy86c3gdp.jl:21\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy86c3gdp.jl:20\ntest set: Test Failed at /tmp/tmpy86c3gdp.jl:22\n\
    \  Expression: candidate([152, 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated:\
    \ [152, 323, 1422, 10] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpy86c3gdp.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy86c3gdp.jl:20\ntest set: Test Failed at /tmp/tmpy86c3gdp.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [12345, 2033, 111, 151] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpy86c3gdp.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy86c3gdp.jl:20\ntest set: Test Failed at /tmp/tmpy86c3gdp.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 103,\
    \ 31] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpy86c3gdp.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy86c3gdp.jl:20\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy86c3gdp.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpu3ol6uns.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu3ol6uns.jl:14\n\
    \   [2] top-level scope at /tmp/tmpu3ol6uns.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu3ol6uns.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3ol6uns.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu3ol6uns.jl:14\n\
    \   [2] top-level scope at /tmp/tmpu3ol6uns.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu3ol6uns.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3ol6uns.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu3ol6uns.jl:14\n\
    \   [2] top-level scope at /tmp/tmpu3ol6uns.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu3ol6uns.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpu3ol6uns.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpu3ol6uns.jl:14\n\
    \   [2] top-level scope at /tmp/tmpu3ol6uns.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpu3ol6uns.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu3ol6uns.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return filter(x) do x\n        !any(digits(x) .% 2 .== 0)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplgg8f2tq.jl:22\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplgg8f2tq.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplgg8f2tq.jl:21\ntest set: Test Failed at /tmp/tmplgg8f2tq.jl:25\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmplgg8f2tq.jl:25\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplgg8f2tq.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplgg8f2tq.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !has_even_digit(x), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprnndszgu.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  UndefVarError: has_even_digit\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmprnndszgu.jl:13\n\
    \   [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmprnndszgu.jl:13\n   [4] top-level scope at /tmp/tmprnndszgu.jl:20\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmprnndszgu.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmprnndszgu.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmprnndszgu.jl:13\n  \
    \ [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmprnndszgu.jl:13\n   [4] top-level scope at /tmp/tmprnndszgu.jl:21\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmprnndszgu.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmprnndszgu.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmprnndszgu.jl:13\n  \
    \ [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmprnndszgu.jl:13\n   [4] top-level scope at /tmp/tmprnndszgu.jl:22\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmprnndszgu.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmprnndszgu.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  UndefVarError: has_even_digit not defined\n  Stacktrace:\n\
    \   [1] (::var\"#3#4\")(::Int64) at /tmp/tmprnndszgu.jl:13\n   [2] filter(::var\"\
    #3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmprnndszgu.jl:13\n   [4] top-level scope at /tmp/tmprnndszgu.jl:23\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmprnndszgu.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprnndszgu.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return [i for i in x if !any(i % 2 == 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp34dvs5rq.jl:21\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: [15, 33, 1] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp34dvs5rq.jl:21\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp34dvs5rq.jl:20\\ntest set: Test Failed at /tmp/tmp34dvs5rq.jl:24\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: [135, 31]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp34dvs5rq.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp34dvs5rq.jl:20\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     2      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvm2voi_8.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvm2voi_8.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvm2voi_8.jl:20\ntest set: Test Failed at /tmp/tmpvm2voi_8.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpvm2voi_8.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvm2voi_8.jl:20\ntest set: Test Failed at /tmp/tmpvm2voi_8.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpvm2voi_8.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvm2voi_8.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvm2voi_8.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2x2gpug4.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp2x2gpug4.jl:14\\\
    n   [2] top-level scope at /tmp/tmp2x2gpug4.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2x2gpug4.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2x2gpug4.jl:21\\n  Test threw exception\\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp2x2gpug4.jl:14\\\
    n   [2] top-level scope at /tmp/tmp2x2gpug4.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2x2gpug4.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2x2gpug4.jl:22\\n  Test threw exception\\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp2x2gpug4.jl:14\\\
    n   [2] top-level scope at /tmp/tmp2x2gpug4.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2x2gpug4.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2x2gpug4.jl:23\\n  Test threw exception\\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp2x2gpug4.jl:14\\\
    n   [2] top-level scope at /tmp/tmp2x2gpug4.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2x2gpug4.jl:19\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(isodd, digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcixwq23d.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcixwq23d.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcixwq23d.jl:19\ntest set: Test Failed at /tmp/tmpcixwq23d.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpcixwq23d.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcixwq23d.jl:19\ntest set: Test Failed at /tmp/tmpcixwq23d.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpcixwq23d.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcixwq23d.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcixwq23d.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3_d2vnfw.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3_d2vnfw.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3_d2vnfw.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3_d2vnfw.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp3_d2vnfw.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3_d2vnfw.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3_d2vnfw.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3_d2vnfw.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp3_d2vnfw.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3_d2vnfw.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3_d2vnfw.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3_d2vnfw.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp3_d2vnfw.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3_d2vnfw.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3_d2vnfw.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3_d2vnfw.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3_d2vnfw.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !any(i % 2 == 0 for i in digits(i))\n\
    \            push!(y, i)\n        end\n    end\n    sort(y)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(x[findall(x) do xi\n        return all(digits(xi)) do xij\n \
    \           return xij % 2 != 0\n        end\n    end])\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpphmy517l.jl:21\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: Int64[] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpphmy517l.jl:21\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpphmy517l.jl:20\\ntest set: Test Failed at /tmp/tmpphmy517l.jl:23\\\
    n  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\\n   Evaluated:\
    \ Int64[] == [111, 151]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpphmy517l.jl:23\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpphmy517l.jl:20\\ntest set: Test Failed at /tmp/tmpphmy517l.jl:24\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: Int64[]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpphmy517l.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpphmy517l.jl:20\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !(i % 2 == 0)\n            push!(y, i)\n\
    \        end\n    end\n    return sort(y)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15,\
    \ 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345,\
    \ 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp583y4wvb.jl:27\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated: [323] == Int64[]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp583y4wvb.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp583y4wvb.jl:25\ntest set: Test Failed at /tmp/tmp583y4wvb.jl:28\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [111, 151, 2033, 12345] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp583y4wvb.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp583y4wvb.jl:25\ntest set: Test Failed at /tmp/tmp583y4wvb.jl:29\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [31, 103,\
    \ 135] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp583y4wvb.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp583y4wvb.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp583y4wvb.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(isodd, digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpikqmxrs2.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpikqmxrs2.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpikqmxrs2.jl:19\ntest set: Test Failed at /tmp/tmpikqmxrs2.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpikqmxrs2.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpikqmxrs2.jl:19\ntest set: Test Failed at /tmp/tmpikqmxrs2.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpikqmxrs2.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpikqmxrs2.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpikqmxrs2.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3kck3cke.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3kck3cke.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3kck3cke.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3kck3cke.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp3kck3cke.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3kck3cke.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3kck3cke.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3kck3cke.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp3kck3cke.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3kck3cke.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3kck3cke.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3kck3cke.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp3kck3cke.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp3kck3cke.jl:14\n\
    \   [2] top-level scope at /tmp/tmp3kck3cke.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3kck3cke.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3kck3cke.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphl2oc50r.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphl2oc50r.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphl2oc50r.jl:19\ntest set: Test Failed at /tmp/tmphl2oc50r.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmphl2oc50r.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphl2oc50r.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphl2oc50r.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpbs_8_eox.jl:21\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: Int64[] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpbs_8_eox.jl:21\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbs_8_eox.jl:20\\ntest set: Test Failed at /tmp/tmpbs_8_eox.jl:23\\\
    n  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\\n   Evaluated:\
    \ Int64[] == [111, 151]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpbs_8_eox.jl:23\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbs_8_eox.jl:20\\ntest set: Test Failed at /tmp/tmpbs_8_eox.jl:24\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: Int64[]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpbs_8_eox.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbs_8_eox.jl:20\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqjwn6dlq.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpqjwn6dlq.jl:14\n\
    \   [2] top-level scope at /tmp/tmpqjwn6dlq.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqjwn6dlq.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpqjwn6dlq.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpqjwn6dlq.jl:14\n\
    \   [2] top-level scope at /tmp/tmpqjwn6dlq.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqjwn6dlq.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpqjwn6dlq.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpqjwn6dlq.jl:14\n\
    \   [2] top-level scope at /tmp/tmpqjwn6dlq.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqjwn6dlq.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpqjwn6dlq.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpqjwn6dlq.jl:14\n\
    \   [2] top-level scope at /tmp/tmpqjwn6dlq.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqjwn6dlq.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqjwn6dlq.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpikat2glb.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpikat2glb.jl:14\n\
    \   [2] top-level scope at /tmp/tmpikat2glb.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpikat2glb.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpikat2glb.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpikat2glb.jl:14\n\
    \   [2] top-level scope at /tmp/tmpikat2glb.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpikat2glb.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpikat2glb.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpikat2glb.jl:14\n\
    \   [2] top-level scope at /tmp/tmpikat2glb.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpikat2glb.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpikat2glb.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpikat2glb.jl:14\n\
    \   [2] top-level scope at /tmp/tmpikat2glb.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpikat2glb.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpikat2glb.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !(contains(string(i), \"2\") || contains(string(i),\
    \ \"4\") || contains(string(i), \"6\") || contains(string(i), \"8\") || contains(string(i),\
    \ \"0\"))\n            push!(y, i)\n        end\n    end\n    sort(y)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp628ond3b.jl:26\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  UndefVarError: contains\
    \ not defined\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp628ond3b.jl:15\n\
    \   [2] top-level scope at /tmp/tmp628ond3b.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp628ond3b.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmp628ond3b.jl:27\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  UndefVarError: contains not defined\n\
    \  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp628ond3b.jl:15\n\
    \   [2] top-level scope at /tmp/tmp628ond3b.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp628ond3b.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmp628ond3b.jl:28\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp628ond3b.jl:15\n   [2] top-level\
    \ scope at /tmp/tmp628ond3b.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp628ond3b.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmp628ond3b.jl:29\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  UndefVarError: contains not defined\n  Stacktrace:\n\
    \   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp628ond3b.jl:15\n   [2] top-level\
    \ scope at /tmp/tmp628ond3b.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp628ond3b.jl:25\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp628ond3b.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !(any(i % 2 == 0 for i in digits(i)))\n\
    \            push!(y, i)\n        end\n    end\n    return sort(y)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # Your code here\n    return x\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0lesiuix.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1422, 1] == [1, 15, 33]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0lesiuix.jl:21\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0lesiuix.jl:20\ntest set: Test Failed at /tmp/tmp0lesiuix.jl:22\n\
    \  Expression: candidate([152, 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated:\
    \ [152, 323, 1422, 10] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmp0lesiuix.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0lesiuix.jl:20\ntest set: Test Failed at /tmp/tmp0lesiuix.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [12345, 2033, 111, 151] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp0lesiuix.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0lesiuix.jl:20\ntest set: Test Failed at /tmp/tmp0lesiuix.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 103,\
    \ 31] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp0lesiuix.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0lesiuix.jl:20\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0lesiuix.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpp2d372jr.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpp2d372jr.jl:14\n\
    \   [2] top-level scope at /tmp/tmpp2d372jr.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp2d372jr.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpp2d372jr.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpp2d372jr.jl:14\n\
    \   [2] top-level scope at /tmp/tmpp2d372jr.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp2d372jr.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpp2d372jr.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpp2d372jr.jl:14\n\
    \   [2] top-level scope at /tmp/tmpp2d372jr.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp2d372jr.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpp2d372jr.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpp2d372jr.jl:14\n\
    \   [2] top-level scope at /tmp/tmpp2d372jr.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp2d372jr.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp2d372jr.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if !any(i % 2 == 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpznbkf2n6.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpznbkf2n6.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpznbkf2n6.jl:20\ntest set: Test Failed at /tmp/tmpznbkf2n6.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpznbkf2n6.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpznbkf2n6.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpznbkf2n6.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8g8hqnmt.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp8g8hqnmt.jl:14\n\
    \   [2] top-level scope at /tmp/tmp8g8hqnmt.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8g8hqnmt.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp8g8hqnmt.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp8g8hqnmt.jl:14\n\
    \   [2] top-level scope at /tmp/tmp8g8hqnmt.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8g8hqnmt.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp8g8hqnmt.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp8g8hqnmt.jl:14\n\
    \   [2] top-level scope at /tmp/tmp8g8hqnmt.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8g8hqnmt.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp8g8hqnmt.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp8g8hqnmt.jl:14\n\
    \   [2] top-level scope at /tmp/tmp8g8hqnmt.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8g8hqnmt.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8g8hqnmt.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(isodd, digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbxaj8fcl.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbxaj8fcl.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbxaj8fcl.jl:19\ntest set: Test Failed at /tmp/tmpbxaj8fcl.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpbxaj8fcl.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbxaj8fcl.jl:19\ntest set: Test Failed at /tmp/tmpbxaj8fcl.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpbxaj8fcl.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbxaj8fcl.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbxaj8fcl.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(isodd, digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4eytgjhg.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4eytgjhg.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4eytgjhg.jl:19\ntest set: Test Failed at /tmp/tmp4eytgjhg.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp4eytgjhg.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4eytgjhg.jl:19\ntest set: Test Failed at /tmp/tmp4eytgjhg.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp4eytgjhg.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4eytgjhg.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4eytgjhg.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptbw45pt9.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptbw45pt9.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptbw45pt9.jl:20\ntest set: Test Failed at /tmp/tmptbw45pt9.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmptbw45pt9.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptbw45pt9.jl:20\ntest set: Test Failed at /tmp/tmptbw45pt9.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmptbw45pt9.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptbw45pt9.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptbw45pt9.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return [i for i in x if !any(isodd, digits(i))]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnq1onib6.jl:20\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnq1onib6.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnq1onib6.jl:19\ntest set: Test Failed at /tmp/tmpnq1onib6.jl:22\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpnq1onib6.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnq1onib6.jl:19\ntest set: Test Failed at /tmp/tmpnq1onib6.jl:23\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpnq1onib6.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnq1onib6.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnq1onib6.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp166fml3r.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp166fml3r.jl:14\n\
    \   [2] top-level scope at /tmp/tmp166fml3r.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp166fml3r.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp166fml3r.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp166fml3r.jl:14\n\
    \   [2] top-level scope at /tmp/tmp166fml3r.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp166fml3r.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp166fml3r.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp166fml3r.jl:14\n\
    \   [2] top-level scope at /tmp/tmp166fml3r.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp166fml3r.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp166fml3r.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp166fml3r.jl:14\n\
    \   [2] top-level scope at /tmp/tmp166fml3r.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp166fml3r.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp166fml3r.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x) do x\n        for i in x\n            if i % 2 == 0\n\
    \                return false\n            end\n        end\n        return true\n\
    \    end)\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t\
    @test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323,\
    \ 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111, 151])\
    \ == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8y2v5syc.jl:28\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated: [323] == Int64[]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8y2v5syc.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8y2v5syc.jl:26\ntest set: Test Failed at /tmp/tmp8y2v5syc.jl:29\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [111, 151, 2033, 12345] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp8y2v5syc.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8y2v5syc.jl:26\ntest set: Test Failed at /tmp/tmp8y2v5syc.jl:30\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [31, 103,\
    \ 135] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp8y2v5syc.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8y2v5syc.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8y2v5syc.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpglxq2wmz.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpglxq2wmz.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpglxq2wmz.jl:20\ntest set: Test Failed at /tmp/tmpglxq2wmz.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpglxq2wmz.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpglxq2wmz.jl:20\ntest set: Test Failed at /tmp/tmpglxq2wmz.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpglxq2wmz.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpglxq2wmz.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpglxq2wmz.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_8c12q00.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_8c12q00.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_8c12q00.jl:20\ntest set: Test Failed at /tmp/tmp_8c12q00.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp_8c12q00.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_8c12q00.jl:20\ntest set: Test Failed at /tmp/tmp_8c12q00.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp_8c12q00.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_8c12q00.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_8c12q00.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpn5lb6duf.jl:20\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: [15, 33, 1] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpn5lb6duf.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpn5lb6duf.jl:19\\ntest set: Test Failed at /tmp/tmpn5lb6duf.jl:23\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: [135, 31]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpn5lb6duf.jl:23\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpn5lb6duf.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     2      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxfovgnt3.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpxfovgnt3.jl:14\n\
    \   [2] top-level scope at /tmp/tmpxfovgnt3.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxfovgnt3.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpxfovgnt3.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpxfovgnt3.jl:14\n\
    \   [2] top-level scope at /tmp/tmpxfovgnt3.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxfovgnt3.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpxfovgnt3.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpxfovgnt3.jl:14\n\
    \   [2] top-level scope at /tmp/tmpxfovgnt3.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxfovgnt3.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpxfovgnt3.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpxfovgnt3.jl:14\n\
    \   [2] top-level scope at /tmp/tmpxfovgnt3.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxfovgnt3.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxfovgnt3.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # Your code here\n    return [i for i in x if all(i % 2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmqkq9o5c.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmqkq9o5c.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmqkq9o5c.jl:20\ntest set: Test Failed at /tmp/tmpmqkq9o5c.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpmqkq9o5c.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmqkq9o5c.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmqkq9o5c.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !has_even_digit(x), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa67f1ih9.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  UndefVarError: has_even_digit\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmpa67f1ih9.jl:13\n\
    \   [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmpa67f1ih9.jl:13\n   [4] top-level scope at /tmp/tmpa67f1ih9.jl:20\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmpa67f1ih9.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpa67f1ih9.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmpa67f1ih9.jl:13\n  \
    \ [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmpa67f1ih9.jl:13\n   [4] top-level scope at /tmp/tmpa67f1ih9.jl:21\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmpa67f1ih9.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpa67f1ih9.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  UndefVarError: has_even_digit not defined\n\
    \  Stacktrace:\n   [1] (::var\"#3#4\")(::Int64) at /tmp/tmpa67f1ih9.jl:13\n  \
    \ [2] filter(::var\"#3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmpa67f1ih9.jl:13\n   [4] top-level scope at /tmp/tmpa67f1ih9.jl:22\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmpa67f1ih9.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpa67f1ih9.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  UndefVarError: has_even_digit not defined\n  Stacktrace:\n\
    \   [1] (::var\"#3#4\")(::Int64) at /tmp/tmpa67f1ih9.jl:13\n   [2] filter(::var\"\
    #3#4\", ::Array{Int64,1}) at ./array.jl:2375\n   [3] unique_digits(::Array{Int64,1})\
    \ at /tmp/tmpa67f1ih9.jl:13\n   [4] top-level scope at /tmp/tmpa67f1ih9.jl:23\n\
    \   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [6] top-level scope at /tmp/tmpa67f1ih9.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa67f1ih9.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> all(digits(x) .% 2 .!= 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp87mfuwih.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp87mfuwih.jl:14\n\
    \   [2] top-level scope at /tmp/tmp87mfuwih.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp87mfuwih.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp87mfuwih.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp87mfuwih.jl:14\n\
    \   [2] top-level scope at /tmp/tmp87mfuwih.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp87mfuwih.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp87mfuwih.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp87mfuwih.jl:14\n\
    \   [2] top-level scope at /tmp/tmp87mfuwih.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp87mfuwih.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp87mfuwih.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp87mfuwih.jl:14\n\
    \   [2] top-level scope at /tmp/tmp87mfuwih.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp87mfuwih.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp87mfuwih.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !(any(i % 2 == 0 for i in digits(i)))\n\
    \            push!(y, i)\n        end\n    end\n    sort(y)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(x[findall(x) do i\n        return all(digits(i)) do j\n     \
    \       return j % 2 != 0\n        end\n    end])\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppkg7eepd.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmppkg7eepd.jl:14\n\
    \   [2] top-level scope at /tmp/tmppkg7eepd.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppkg7eepd.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmppkg7eepd.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmppkg7eepd.jl:14\n\
    \   [2] top-level scope at /tmp/tmppkg7eepd.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppkg7eepd.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmppkg7eepd.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmppkg7eepd.jl:14\n\
    \   [2] top-level scope at /tmp/tmppkg7eepd.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppkg7eepd.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmppkg7eepd.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmppkg7eepd.jl:14\n\
    \   [2] top-level scope at /tmp/tmppkg7eepd.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppkg7eepd.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppkg7eepd.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqngszieb.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpqngszieb.jl:14\n\
    \   [2] top-level scope at /tmp/tmpqngszieb.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqngszieb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpqngszieb.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpqngszieb.jl:14\n\
    \   [2] top-level scope at /tmp/tmpqngszieb.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqngszieb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpqngszieb.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpqngszieb.jl:14\n\
    \   [2] top-level scope at /tmp/tmpqngszieb.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqngszieb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpqngszieb.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpqngszieb.jl:14\n\
    \   [2] top-level scope at /tmp/tmpqngszieb.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqngszieb.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqngszieb.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_yuhj1t5.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_yuhj1t5.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_yuhj1t5.jl:20\ntest set: Test Failed at /tmp/tmp_yuhj1t5.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp_yuhj1t5.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_yuhj1t5.jl:20\ntest set: Test Failed at /tmp/tmp_yuhj1t5.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp_yuhj1t5.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_yuhj1t5.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_yuhj1t5.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x) do x\n        for i in x\n            if i % 2 == 0\n\
    \                return false\n            end\n        end\n        return true\n\
    \    end)\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t\
    @test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323,\
    \ 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111, 151])\
    \ == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfeo8ekv3.jl:28\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated: [323] == Int64[]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfeo8ekv3.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfeo8ekv3.jl:26\ntest set: Test Failed at /tmp/tmpfeo8ekv3.jl:29\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [111, 151, 2033, 12345] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpfeo8ekv3.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfeo8ekv3.jl:26\ntest set: Test Failed at /tmp/tmpfeo8ekv3.jl:30\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [31, 103,\
    \ 135] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpfeo8ekv3.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfeo8ekv3.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfeo8ekv3.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpccxkzxvz.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpccxkzxvz.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpccxkzxvz.jl:20\ntest set: Test Failed at /tmp/tmpccxkzxvz.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpccxkzxvz.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpccxkzxvz.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpccxkzxvz.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpahch2i5_.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpahch2i5_.jl:14\\\
    n   [2] top-level scope at /tmp/tmpahch2i5_.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpahch2i5_.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpahch2i5_.jl:21\\n  Test threw exception\\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpahch2i5_.jl:14\\\
    n   [2] top-level scope at /tmp/tmpahch2i5_.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpahch2i5_.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpahch2i5_.jl:22\\n  Test threw exception\\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpahch2i5_.jl:14\\\
    n   [2] top-level scope at /tmp/tmpahch2i5_.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpahch2i5_.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpahch2i5_.jl:23\\n  Test threw exception\\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpahch2i5_.jl:14\\\
    n   [2] top-level scope at /tmp/tmpahch2i5_.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpahch2i5_.jl:19\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7bfnbmrt.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp7bfnbmrt.jl:14\n\
    \   [2] top-level scope at /tmp/tmp7bfnbmrt.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7bfnbmrt.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp7bfnbmrt.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp7bfnbmrt.jl:14\n\
    \   [2] top-level scope at /tmp/tmp7bfnbmrt.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7bfnbmrt.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp7bfnbmrt.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp7bfnbmrt.jl:14\n\
    \   [2] top-level scope at /tmp/tmp7bfnbmrt.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7bfnbmrt.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp7bfnbmrt.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp7bfnbmrt.jl:14\n\
    \   [2] top-level scope at /tmp/tmp7bfnbmrt.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7bfnbmrt.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7bfnbmrt.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7spqhzfs.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7spqhzfs.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7spqhzfs.jl:20\ntest set: Test Failed at /tmp/tmp7spqhzfs.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmp7spqhzfs.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7spqhzfs.jl:20\ntest set: Test Failed at /tmp/tmp7spqhzfs.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp7spqhzfs.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7spqhzfs.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7spqhzfs.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(x[findall(x) do x\n        all(digits(x) .% 2 .!= 0)\n    end])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return filter(x) do x\n        !any(digits(x)) do d\n            d % 2 ==\
    \ 0\n        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvzges32z.jl:24\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvzges32z.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvzges32z.jl:23\ntest set: Test Failed at /tmp/tmpvzges32z.jl:27\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpvzges32z.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvzges32z.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvzges32z.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> all(i -> i % 2 != 0, digits(x)), x))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkur0ldnm.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpkur0ldnm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpkur0ldnm.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkur0ldnm.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpkur0ldnm.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpkur0ldnm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpkur0ldnm.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkur0ldnm.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpkur0ldnm.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpkur0ldnm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpkur0ldnm.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkur0ldnm.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpkur0ldnm.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpkur0ldnm.jl:14\n\
    \   [2] top-level scope at /tmp/tmpkur0ldnm.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkur0ldnm.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkur0ldnm.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\n    return [i for i in x if all(i%2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzunkunzb.jl:21\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: [15, 33, 1] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpzunkunzb.jl:21\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzunkunzb.jl:20\\ntest set: Test Failed at /tmp/tmpzunkunzb.jl:24\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: [135, 31]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzunkunzb.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzunkunzb.jl:20\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # Your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsb26tlse.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpsb26tlse.jl:14\n\
    \   [2] top-level scope at /tmp/tmpsb26tlse.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsb26tlse.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpsb26tlse.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpsb26tlse.jl:14\n\
    \   [2] top-level scope at /tmp/tmpsb26tlse.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsb26tlse.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpsb26tlse.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpsb26tlse.jl:14\n\
    \   [2] top-level scope at /tmp/tmpsb26tlse.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsb26tlse.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpsb26tlse.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpsb26tlse.jl:14\n\
    \   [2] top-level scope at /tmp/tmpsb26tlse.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsb26tlse.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsb26tlse.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # Your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpf4zv0bbw.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpf4zv0bbw.jl:14\\\
    n   [2] top-level scope at /tmp/tmpf4zv0bbw.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpf4zv0bbw.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpf4zv0bbw.jl:22\\n  Test threw exception\\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpf4zv0bbw.jl:14\\\
    n   [2] top-level scope at /tmp/tmpf4zv0bbw.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpf4zv0bbw.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpf4zv0bbw.jl:23\\n  Test threw exception\\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpf4zv0bbw.jl:14\\\
    n   [2] top-level scope at /tmp/tmpf4zv0bbw.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpf4zv0bbw.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpf4zv0bbw.jl:24\\n  Test threw exception\\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpf4zv0bbw.jl:14\\\
    n   [2] top-level scope at /tmp/tmpf4zv0bbw.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpf4zv0bbw.jl:20\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !any(i % 2 == 0 for i in digits(i))\n\
    \            push!(y, i)\n        end\n    end\n    return sort(y)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpazbfrk3m.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpazbfrk3m.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpazbfrk3m.jl:20\ntest set: Test Failed at /tmp/tmpazbfrk3m.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpazbfrk3m.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpazbfrk3m.jl:20\ntest set: Test Failed at /tmp/tmpazbfrk3m.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpazbfrk3m.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpazbfrk3m.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpazbfrk3m.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgsrp93pv.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpgsrp93pv.jl:14\n\
    \   [2] top-level scope at /tmp/tmpgsrp93pv.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgsrp93pv.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpgsrp93pv.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpgsrp93pv.jl:14\n\
    \   [2] top-level scope at /tmp/tmpgsrp93pv.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgsrp93pv.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpgsrp93pv.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpgsrp93pv.jl:14\n\
    \   [2] top-level scope at /tmp/tmpgsrp93pv.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgsrp93pv.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpgsrp93pv.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpgsrp93pv.jl:14\n\
    \   [2] top-level scope at /tmp/tmpgsrp93pv.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgsrp93pv.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgsrp93pv.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd_28_wwi.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpd_28_wwi.jl:14\n\
    \   [2] top-level scope at /tmp/tmpd_28_wwi.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd_28_wwi.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpd_28_wwi.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpd_28_wwi.jl:14\n\
    \   [2] top-level scope at /tmp/tmpd_28_wwi.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd_28_wwi.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpd_28_wwi.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpd_28_wwi.jl:14\n\
    \   [2] top-level scope at /tmp/tmpd_28_wwi.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd_28_wwi.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpd_28_wwi.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpd_28_wwi.jl:14\n\
    \   [2] top-level scope at /tmp/tmpd_28_wwi.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd_28_wwi.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd_28_wwi.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(j % 2 != 0 for j in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpmjem5liw.jl:21\\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\\n   Evaluated: [15, 33, 1] == [1, 15, 33]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpmjem5liw.jl:21\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmjem5liw.jl:20\\ntest set: Test Failed at /tmp/tmpmjem5liw.jl:24\\\
    n  Expression: candidate([135, 103, 31]) == [31, 135]\\n   Evaluated: [135, 31]\
    \ == [31, 135]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpmjem5liw.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmjem5liw.jl:20\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # TODO: Write your code here\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) ==\
    \ [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmmlkq7u1.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: Int64[] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmmlkq7u1.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmmlkq7u1.jl:20\ntest set: Test Failed at /tmp/tmpmmlkq7u1.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ Int64[] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpmmlkq7u1.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmmlkq7u1.jl:20\ntest set: Test Failed at /tmp/tmpmmlkq7u1.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: Int64[] ==\
    \ [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpmmlkq7u1.jl:24\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmmlkq7u1.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmmlkq7u1.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjq6j87bn.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpjq6j87bn.jl:14\n\
    \   [2] top-level scope at /tmp/tmpjq6j87bn.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjq6j87bn.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpjq6j87bn.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpjq6j87bn.jl:14\n\
    \   [2] top-level scope at /tmp/tmpjq6j87bn.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjq6j87bn.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpjq6j87bn.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpjq6j87bn.jl:14\n\
    \   [2] top-level scope at /tmp/tmpjq6j87bn.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjq6j87bn.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpjq6j87bn.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpjq6j87bn.jl:14\n\
    \   [2] top-level scope at /tmp/tmpjq6j87bn.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjq6j87bn.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjq6j87bn.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_5dnp0h4.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_5dnp0h4.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_5dnp0h4.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_5dnp0h4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_5dnp0h4.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_5dnp0h4.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_5dnp0h4.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_5dnp0h4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_5dnp0h4.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_5dnp0h4.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_5dnp0h4.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_5dnp0h4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_5dnp0h4.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp_5dnp0h4.jl:14\n\
    \   [2] top-level scope at /tmp/tmp_5dnp0h4.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_5dnp0h4.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_5dnp0h4.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return x\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoxm8haru.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1422, 1] == [1, 15, 33]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpoxm8haru.jl:21\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoxm8haru.jl:20\ntest set: Test Failed at /tmp/tmpoxm8haru.jl:22\n\
    \  Expression: candidate([152, 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated:\
    \ [152, 323, 1422, 10] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpoxm8haru.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoxm8haru.jl:20\ntest set: Test Failed at /tmp/tmpoxm8haru.jl:23\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [12345, 2033, 111, 151] == [111, 151]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpoxm8haru.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoxm8haru.jl:20\ntest set: Test Failed at /tmp/tmpoxm8haru.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 103,\
    \ 31] == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmpoxm8haru.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoxm8haru.jl:20\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoxm8haru.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !(any(i % 2 == 0 for i in digits(i)))\n\
    \            push!(y, i)\n        end\n    end\n    return sort(y)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [y for y in x if all(z % 2 != 0 for z in digits(y))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5p8b6q9c.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5p8b6q9c.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5p8b6q9c.jl:20\ntest set: Test Failed at /tmp/tmp5p8b6q9c.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp5p8b6q9c.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5p8b6q9c.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5p8b6q9c.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy62x37kt.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpy62x37kt.jl:14\n\
    \   [2] top-level scope at /tmp/tmpy62x37kt.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy62x37kt.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpy62x37kt.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpy62x37kt.jl:14\n\
    \   [2] top-level scope at /tmp/tmpy62x37kt.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy62x37kt.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpy62x37kt.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpy62x37kt.jl:14\n\
    \   [2] top-level scope at /tmp/tmpy62x37kt.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy62x37kt.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpy62x37kt.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpy62x37kt.jl:14\n\
    \   [2] top-level scope at /tmp/tmpy62x37kt.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy62x37kt.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy62x37kt.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7yv313x5.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp7yv313x5.jl:14\n\
    \   [2] top-level scope at /tmp/tmp7yv313x5.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7yv313x5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp7yv313x5.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp7yv313x5.jl:14\n\
    \   [2] top-level scope at /tmp/tmp7yv313x5.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7yv313x5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp7yv313x5.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp7yv313x5.jl:14\n\
    \   [2] top-level scope at /tmp/tmp7yv313x5.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7yv313x5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp7yv313x5.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp7yv313x5.jl:14\n\
    \   [2] top-level scope at /tmp/tmp7yv313x5.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7yv313x5.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7yv313x5.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> all(digits(x) .% 2 .!= 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    return sort(filter(x -> !any(digits(x) .% 2 .== 0), x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6925affi.jl:21\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp6925affi.jl:14\n\
    \   [2] top-level scope at /tmp/tmp6925affi.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6925affi.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp6925affi.jl:22\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp6925affi.jl:14\n\
    \   [2] top-level scope at /tmp/tmp6925affi.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6925affi.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp6925affi.jl:23\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp6925affi.jl:14\n\
    \   [2] top-level scope at /tmp/tmp6925affi.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6925affi.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp6925affi.jl:24\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp6925affi.jl:14\n\
    \   [2] top-level scope at /tmp/tmp6925affi.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6925affi.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6925affi.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0tt55_qh.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp0tt55_qh.jl:14\n\
    \   [2] top-level scope at /tmp/tmp0tt55_qh.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0tt55_qh.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp0tt55_qh.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp0tt55_qh.jl:14\n\
    \   [2] top-level scope at /tmp/tmp0tt55_qh.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0tt55_qh.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp0tt55_qh.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp0tt55_qh.jl:14\n\
    \   [2] top-level scope at /tmp/tmp0tt55_qh.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0tt55_qh.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp0tt55_qh.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmp0tt55_qh.jl:14\n\
    \   [2] top-level scope at /tmp/tmp0tt55_qh.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0tt55_qh.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0tt55_qh.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj4copb5v.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpj4copb5v.jl:14\n\
    \   [2] top-level scope at /tmp/tmpj4copb5v.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4copb5v.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4copb5v.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpj4copb5v.jl:14\n\
    \   [2] top-level scope at /tmp/tmpj4copb5v.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4copb5v.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4copb5v.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpj4copb5v.jl:14\n\
    \   [2] top-level scope at /tmp/tmpj4copb5v.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4copb5v.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4copb5v.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpj4copb5v.jl:14\n\
    \   [2] top-level scope at /tmp/tmpj4copb5v.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4copb5v.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj4copb5v.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !(any(i % 2 == 0 for i in digits(i)))\n\
    \            push!(y, i)\n        end\n    end\n    return sort(y)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    y = []\n    for i in x\n        if !(any(i % 10 == 0 for i in digits(i)))\n\
    \            push!(y, i)\n        end\n    end\n    sort(y)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422,\
    \ 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz23deuc7.jl:26\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [1, 15, 33, 1422] == [1, 15, 33]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpz23deuc7.jl:26\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz23deuc7.jl:25\ntest set: Test Failed at /tmp/tmpz23deuc7.jl:27\n\
    \  Expression: candidate([152, 323, 1422, 10]) == Vector{Int64}([])\n   Evaluated:\
    \ [152, 323, 1422] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpz23deuc7.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz23deuc7.jl:25\ntest set: Test Failed at /tmp/tmpz23deuc7.jl:28\n\
    \  Expression: candidate([12345, 2033, 111, 151]) == [111, 151]\n   Evaluated:\
    \ [111, 151, 12345] == [111, 151]\nStacktrace:\n [1] top-level scope at /tmp/tmpz23deuc7.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz23deuc7.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz23deuc7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpctrl4wge.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpctrl4wge.jl:14\n\
    \   [2] top-level scope at /tmp/tmpctrl4wge.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpctrl4wge.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpctrl4wge.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpctrl4wge.jl:14\n\
    \   [2] top-level scope at /tmp/tmpctrl4wge.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpctrl4wge.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpctrl4wge.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpctrl4wge.jl:14\n\
    \   [2] top-level scope at /tmp/tmpctrl4wge.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpctrl4wge.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpctrl4wge.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpctrl4wge.jl:14\n\
    \   [2] top-level scope at /tmp/tmpctrl4wge.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpctrl4wge.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpctrl4wge.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpds5bj74_.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpds5bj74_.jl:14\n\
    \   [2] top-level scope at /tmp/tmpds5bj74_.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpds5bj74_.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpds5bj74_.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpds5bj74_.jl:14\n\
    \   [2] top-level scope at /tmp/tmpds5bj74_.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpds5bj74_.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpds5bj74_.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpds5bj74_.jl:14\n\
    \   [2] top-level scope at /tmp/tmpds5bj74_.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpds5bj74_.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpds5bj74_.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpds5bj74_.jl:14\n\
    \   [2] top-level scope at /tmp/tmpds5bj74_.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpds5bj74_.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpds5bj74_.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpridonh8k.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpridonh8k.jl:14\n\
    \   [2] top-level scope at /tmp/tmpridonh8k.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpridonh8k.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpridonh8k.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpridonh8k.jl:14\n\
    \   [2] top-level scope at /tmp/tmpridonh8k.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpridonh8k.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpridonh8k.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpridonh8k.jl:14\n\
    \   [2] top-level scope at /tmp/tmpridonh8k.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpridonh8k.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpridonh8k.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpridonh8k.jl:14\n\
    \   [2] top-level scope at /tmp/tmpridonh8k.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpridonh8k.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpridonh8k.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\
    \t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111,\
    \ 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpehem0k1e.jl:20\n  Test threw exception\n\
    \  Expression: candidate([15, 33, 1422, 1]) == [1, 15, 33]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpehem0k1e.jl:14\n\
    \   [2] top-level scope at /tmp/tmpehem0k1e.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpehem0k1e.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpehem0k1e.jl:21\n  Test threw exception\n  Expression: candidate([152,\
    \ 323, 1422, 10]) == Vector{Int64}([])\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpehem0k1e.jl:14\n\
    \   [2] top-level scope at /tmp/tmpehem0k1e.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpehem0k1e.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpehem0k1e.jl:22\n  Test threw exception\n  Expression: candidate([12345,\
    \ 2033, 111, 151]) == [111, 151]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Array{Int64,1}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpehem0k1e.jl:14\n\
    \   [2] top-level scope at /tmp/tmpehem0k1e.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpehem0k1e.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpehem0k1e.jl:23\n  Test threw exception\n  Expression: candidate([135,\
    \ 103, 31]) == [31, 135]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] unique_digits(::Array{Int64,1}) at /tmp/tmpehem0k1e.jl:14\n\
    \   [2] top-level scope at /tmp/tmpehem0k1e.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpehem0k1e.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpehem0k1e.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Given a list of positive integers x. return a sorted list of all\
    \ \n    elements that hasn't any even digit.\n\n    Note: Returned list should\
    \ be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15,\
    \ 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n\
    \    []\n    \"\"\"\nfunction unique_digits(x::Vector{Int64})::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [i for i in x if all(i % 2 != 0 for i in digits(i))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\
    \t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135,\
    \ 103, 31]) == [31, 135])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5no6kh41.jl:21\n  Expression: candidate([15,\
    \ 33, 1422, 1]) == [1, 15, 33]\n   Evaluated: [15, 33, 1] == [1, 15, 33]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5no6kh41.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5no6kh41.jl:20\ntest set: Test Failed at /tmp/tmp5no6kh41.jl:24\n\
    \  Expression: candidate([135, 103, 31]) == [31, 135]\n   Evaluated: [135, 31]\
    \ == [31, 135]\nStacktrace:\n [1] top-level scope at /tmp/tmp5no6kh41.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5no6kh41.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5no6kh41.jl:18\n"
  exit_code: 1
  status: SyntaxError
