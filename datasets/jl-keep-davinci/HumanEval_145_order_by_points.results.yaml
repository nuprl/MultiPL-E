name: HumanEval_145_order_by_points
language: julia
results:
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return []\n    end\n    return sort(nums,\
    \ by = x -> (sum(digits(x)), x))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1,\
    \ -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiu6ffjfr.jl:22\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpiu6ffjfr.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiu6ffjfr.jl:21\ntest set: Test Failed at /tmp/tmpiu6ffjfr.jl:23\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiu6ffjfr.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiu6ffjfr.jl:21\ntest set: Test Failed at /tmp/tmpiu6ffjfr.jl:25\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpiu6ffjfr.jl:25\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiu6ffjfr.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiu6ffjfr.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    nums_sum = [sum(digits(i)) for i in nums]\n    return sortperm(nums_sum)[nums]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqka84eni.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  BoundsError: attempt to access 5-element Array{Int64,1} at index [[1,\
    \ 11, -1, -11, -12]]\\n  Stacktrace:\\n   [1] throw_boundserror(::Array{Int64,1},\
    \ ::Tuple{Array{Int64,1}}) at ./abstractarray.jl:537\\n   [2] checkbounds at ./abstractarray.jl:502\
    \ [inlined]\\n   [3] _getindex at ./multidimensional.jl:726 [inlined]\\n   [4]\
    \ getindex at ./abstractarray.jl:980 [inlined]\\n   [5] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpqka84eni.jl:13\\n   [6] top-level scope at /tmp/tmpqka84eni.jl:20\\\
    n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [8] top-level scope at /tmp/tmpqka84eni.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqka84eni.jl:21\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  BoundsError: attempt\
    \ to access 15-element Array{Int64,1} at index [[1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]]\\n  Stacktrace:\\n   [1] throw_boundserror(::Array{Int64,1},\
    \ ::Tuple{Array{Int64,1}}) at ./abstractarray.jl:537\\n   [2] checkbounds at ./abstractarray.jl:502\
    \ [inlined]\\n   [3] _getindex at ./multidimensional.jl:726 [inlined]\\n   [4]\
    \ getindex at ./abstractarray.jl:980 [inlined]\\n   [5] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpqka84eni.jl:13\\n   [6] top-level scope at /tmp/tmpqka84eni.jl:21\\\
    n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [8] top-level scope at /tmp/tmpqka84eni.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqka84eni.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  BoundsError:\
    \ attempt to access 8-element Array{Int64,1} at index [[1, -11, -32, 43, 54, -98,\
    \ 2, -3]]\\n  Stacktrace:\\n   [1] throw_boundserror(::Array{Int64,1}, ::Tuple{Array{Int64,1}})\
    \ at ./abstractarray.jl:537\\n   [2] checkbounds at ./abstractarray.jl:502 [inlined]\\\
    n   [3] _getindex at ./multidimensional.jl:726 [inlined]\\n   [4] getindex at\
    \ ./abstractarray.jl:980 [inlined]\\n   [5] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpqka84eni.jl:13\\n   [6] top-level scope at /tmp/tmpqka84eni.jl:23\\\
    n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [8] top-level scope at /tmp/tmpqka84eni.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqka84eni.jl:25\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  BoundsError: attempt\
    \ to access 7-element Array{Int64,1} at index [[0, 6, 6, -76, -21, 23, 4]]\\n\
    \  Stacktrace:\\n   [1] throw_boundserror(::Array{Int64,1}, ::Tuple{Array{Int64,1}})\
    \ at ./abstractarray.jl:537\\n   [2] checkbounds at ./abstractarray.jl:502 [inlined]\\\
    n   [3] _getindex at ./multidimensional.jl:726 [inlined]\\n   [4] getindex at\
    \ ./abstractarray.jl:980 [inlined]\\n   [5] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpqka84eni.jl:13\\n   [6] top-level scope at /tmp/tmpqka84eni.jl:25\\\
    n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [8] top-level scope at /tmp/tmpqka84eni.jl:19\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      4      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    nums_sorted = sort(nums, by = x -> sum(digits(x)))\n    return nums_sorted\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpol2c8zsp.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpol2c8zsp.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpol2c8zsp.jl:19\ntest set: Test Failed at /tmp/tmpol2c8zsp.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpol2c8zsp.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpol2c8zsp.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpol2c8zsp.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8_sr8edk.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8_sr8edk.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8_sr8edk.jl:18\\ntest set: Test Failed at /tmp/tmp8_sr8edk.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8_sr8edk.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8_sr8edk.jl:18\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmphkr2yabc.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmphkr2yabc.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphkr2yabc.jl:18\\ntest set: Test Failed at /tmp/tmphkr2yabc.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmphkr2yabc.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphkr2yabc.jl:18\\ntest set: Test Failed at /tmp/tmphkr2yabc.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmphkr2yabc.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphkr2yabc.jl:18\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sortperm(nums, by=x->sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmptozaprf9.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [5, 4, 3, 1, 2]\
    \ == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmptozaprf9.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptozaprf9.jl:18\\ntest set: Test Failed at /tmp/tmptozaprf9.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [14, 5, 12, 9, 8, 2, 6, 7, 1, 4, 10, 15, 13, 3, 11] == [0, 2, 3,\
    \ 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmptozaprf9.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptozaprf9.jl:18\\ntest set: Test Failed at /tmp/tmptozaprf9.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [6, 3, 8, 2, 1, 7, 4, 5] == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmptozaprf9.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptozaprf9.jl:18\\ntest set: Test Failed at /tmp/tmptozaprf9.jl:24\\\
    n  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\\n   Evaluated: [4, 5, 1, 7, 6, 2, 3] == [-76, -21, 0, 4, 23, 6, 6]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmptozaprf9.jl:24\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptozaprf9.jl:18\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     4      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    sums = [sum(digits(x)) for x in nums]\n    return [nums[i] for i in sortperm(sums)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnanpq8va.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpnanpq8va.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnanpq8va.jl:19\ntest set: Test Failed at /tmp/tmpnanpq8va.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpnanpq8va.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnanpq8va.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnanpq8va.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkgg0bxmo.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpkgg0bxmo.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkgg0bxmo.jl:18\ntest set: Test Failed at /tmp/tmpkgg0bxmo.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkgg0bxmo.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkgg0bxmo.jl:18\ntest set: Test Failed at /tmp/tmpkgg0bxmo.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpkgg0bxmo.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkgg0bxmo.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkgg0bxmo.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvze5mjgw.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvze5mjgw.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvze5mjgw.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvze5mjgw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvze5mjgw.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvze5mjgw.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvze5mjgw.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvze5mjgw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvze5mjgw.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvze5mjgw.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvze5mjgw.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvze5mjgw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvze5mjgw.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvze5mjgw.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvze5mjgw.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvze5mjgw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvze5mjgw.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvze5mjgw.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvze5mjgw.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvze5mjgw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvze5mjgw.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvze5mjgw.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvze5mjgw.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvze5mjgw.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvze5mjgw.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpe6mvry5e.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpe6mvry5e.jl:13\n\
    \   [2] top-level scope at /tmp/tmpe6mvry5e.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6mvry5e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6mvry5e.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpe6mvry5e.jl:13\n\
    \   [2] top-level scope at /tmp/tmpe6mvry5e.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6mvry5e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6mvry5e.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpe6mvry5e.jl:13\n\
    \   [2] top-level scope at /tmp/tmpe6mvry5e.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6mvry5e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6mvry5e.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpe6mvry5e.jl:13\n\
    \   [2] top-level scope at /tmp/tmpe6mvry5e.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6mvry5e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6mvry5e.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpe6mvry5e.jl:13\n\
    \   [2] top-level scope at /tmp/tmpe6mvry5e.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6mvry5e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6mvry5e.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpe6mvry5e.jl:13\n\
    \   [2] top-level scope at /tmp/tmpe6mvry5e.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe6mvry5e.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe6mvry5e.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpykg7tm4l.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpykg7tm4l.jl:13\n\
    \   [2] top-level scope at /tmp/tmpykg7tm4l.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpykg7tm4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpykg7tm4l.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpykg7tm4l.jl:13\n\
    \   [2] top-level scope at /tmp/tmpykg7tm4l.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpykg7tm4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpykg7tm4l.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpykg7tm4l.jl:13\n\
    \   [2] top-level scope at /tmp/tmpykg7tm4l.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpykg7tm4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpykg7tm4l.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpykg7tm4l.jl:13\n\
    \   [2] top-level scope at /tmp/tmpykg7tm4l.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpykg7tm4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpykg7tm4l.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpykg7tm4l.jl:13\n\
    \   [2] top-level scope at /tmp/tmpykg7tm4l.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpykg7tm4l.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpykg7tm4l.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpykg7tm4l.jl:13\n\
    \   [2] top-level scope at /tmp/tmpykg7tm4l.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpykg7tm4l.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpykg7tm4l.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj3_zyph2.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpj3_zyph2.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj3_zyph2.jl:18\ntest set: Test Failed at /tmp/tmpj3_zyph2.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj3_zyph2.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj3_zyph2.jl:18\ntest set: Test Failed at /tmp/tmpj3_zyph2.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpj3_zyph2.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj3_zyph2.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj3_zyph2.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sortperm(sum.(digits.(nums)), 1:length(nums))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp57qptpmx.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp57qptpmx.jl:12\n   [2] top-level scope at /tmp/tmp57qptpmx.jl:19\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp57qptpmx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp57qptpmx.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp57qptpmx.jl:12\n\
    \   [2] top-level scope at /tmp/tmp57qptpmx.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp57qptpmx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp57qptpmx.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching sortperm(::Array{Int64,1},\
    \ ::UnitRange{Int64})\n  Closest candidates are:\n    sortperm(::AbstractArray{T,1}\
    \ where T; alg, lt, by, rev, order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp57qptpmx.jl:12\n   [2] top-level scope at /tmp/tmp57qptpmx.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp57qptpmx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp57qptpmx.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp57qptpmx.jl:12\n   [2] top-level scope at /tmp/tmp57qptpmx.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp57qptpmx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp57qptpmx.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp57qptpmx.jl:12\n   [2] top-level scope at /tmp/tmp57qptpmx.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp57qptpmx.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp57qptpmx.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp57qptpmx.jl:12\n\
    \   [2] top-level scope at /tmp/tmp57qptpmx.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp57qptpmx.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp57qptpmx.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpvj0ncn7j.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvj0ncn7j.jl:13\\\
    n   [2] top-level scope at /tmp/tmpvj0ncn7j.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpvj0ncn7j.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpvj0ncn7j.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvj0ncn7j.jl:13\\\
    n   [2] top-level scope at /tmp/tmpvj0ncn7j.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpvj0ncn7j.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpvj0ncn7j.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvj0ncn7j.jl:13\\\
    n   [2] top-level scope at /tmp/tmpvj0ncn7j.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpvj0ncn7j.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpvj0ncn7j.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvj0ncn7j.jl:13\\\
    n   [2] top-level scope at /tmp/tmpvj0ncn7j.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpvj0ncn7j.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpvj0ncn7j.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvj0ncn7j.jl:13\\\
    n   [2] top-level scope at /tmp/tmpvj0ncn7j.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpvj0ncn7j.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpvj0ncn7j.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvj0ncn7j.jl:13\\\
    n   [2] top-level scope at /tmp/tmpvj0ncn7j.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpvj0ncn7j.jl:18\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     6      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    nums_sorted = sort(nums, by = x -> sum(digits(x)))\n    return nums_sorted\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxu820era.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpxu820era.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxu820era.jl:19\ntest set: Test Failed at /tmp/tmpxu820era.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpxu820era.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxu820era.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxu820era.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzhmsixpa.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpzhmsixpa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpzhmsixpa.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhmsixpa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhmsixpa.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpzhmsixpa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpzhmsixpa.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhmsixpa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhmsixpa.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpzhmsixpa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpzhmsixpa.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhmsixpa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhmsixpa.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpzhmsixpa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpzhmsixpa.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhmsixpa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhmsixpa.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpzhmsixpa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpzhmsixpa.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhmsixpa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhmsixpa.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpzhmsixpa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpzhmsixpa.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhmsixpa.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzhmsixpa.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp6xj6g2vw.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6xj6g2vw.jl:13\\\
    n   [2] top-level scope at /tmp/tmp6xj6g2vw.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xj6g2vw.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6xj6g2vw.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6xj6g2vw.jl:13\\\
    n   [2] top-level scope at /tmp/tmp6xj6g2vw.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xj6g2vw.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6xj6g2vw.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6xj6g2vw.jl:13\\\
    n   [2] top-level scope at /tmp/tmp6xj6g2vw.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xj6g2vw.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6xj6g2vw.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6xj6g2vw.jl:13\\\
    n   [2] top-level scope at /tmp/tmp6xj6g2vw.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xj6g2vw.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6xj6g2vw.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6xj6g2vw.jl:13\\\
    n   [2] top-level scope at /tmp/tmp6xj6g2vw.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xj6g2vw.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6xj6g2vw.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6xj6g2vw.jl:13\\\
    n   [2] top-level scope at /tmp/tmp6xj6g2vw.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xj6g2vw.jl:18\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6zhr290j.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6zhr290j.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6zhr290j.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6zhr290j.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6zhr290j.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6zhr290j.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6zhr290j.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6zhr290j.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6zhr290j.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6zhr290j.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6zhr290j.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6zhr290j.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6zhr290j.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6zhr290j.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6zhr290j.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6zhr290j.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6zhr290j.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6zhr290j.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6zhr290j.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6zhr290j.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6zhr290j.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6zhr290j.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6zhr290j.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6zhr290j.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6zhr290j.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # sort by sum of digits, then by index\n    return sortperm(nums, by=x->(sum(digits(x)),\
    \ x))\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbgy64btw.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [5, 4, 3, 1, 2] ==\
    \ [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpbgy64btw.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbgy64btw.jl:19\ntest set: Test Failed at /tmp/tmpbgy64btw.jl:21\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [14, 5, 12, 9, 8, 2, 6, 7, 10, 15, 4, 1, 13, 3, 11] == [0, 2, 3,\
    \ 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbgy64btw.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbgy64btw.jl:19\ntest set: Test Failed at /tmp/tmpbgy64btw.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [6, 3, 8, 2, 1, 7, 4, 5] == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpbgy64btw.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbgy64btw.jl:19\ntest set: Test Failed at /tmp/tmpbgy64btw.jl:25\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [4, 5, 1, 7, 6, 2, 3] == [-76, -21, 0, 4, 23, 6, 6]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbgy64btw.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbgy64btw.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     4      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbgy64btw.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sortperm(sum.(digits.(nums)), by=nums)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl6__p4_v.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ objects of type Array{Int64,1} are not callable\n  Use square brackets [] for\
    \ indexing an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}},\
    \ ::Int64, ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n\
    \   [3] sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmpl6__p4_v.jl:12\n\
    \   [8] top-level scope at /tmp/tmpl6__p4_v.jl:19\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpl6__p4_v.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpl6__p4_v.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: objects\
    \ of type Array{Int64,1} are not callable\n  Use square brackets [] for indexing\
    \ an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}}, ::Int64,\
    \ ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n   [3]\
    \ sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmpl6__p4_v.jl:12\n\
    \   [8] top-level scope at /tmp/tmpl6__p4_v.jl:20\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpl6__p4_v.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpl6__p4_v.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ objects of type Array{Int64,1} are not callable\n  Use square brackets [] for\
    \ indexing an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}},\
    \ ::Int64, ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n\
    \   [3] sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmpl6__p4_v.jl:12\n\
    \   [8] top-level scope at /tmp/tmpl6__p4_v.jl:22\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpl6__p4_v.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpl6__p4_v.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ objects of type Array{Int64,1} are not callable\n  Use square brackets [] for\
    \ indexing an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}},\
    \ ::Int64, ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n\
    \   [3] sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmpl6__p4_v.jl:12\n\
    \   [8] top-level scope at /tmp/tmpl6__p4_v.jl:23\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpl6__p4_v.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpl6__p4_v.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: objects\
    \ of type Array{Int64,1} are not callable\n  Use square brackets [] for indexing\
    \ an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}}, ::Int64,\
    \ ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n   [3]\
    \ sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmpl6__p4_v.jl:12\n\
    \   [8] top-level scope at /tmp/tmpl6__p4_v.jl:24\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpl6__p4_v.jl:18\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl6__p4_v.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfyveg_ym.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfyveg_ym.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfyveg_ym.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfyveg_ym.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfyveg_ym.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfyveg_ym.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfyveg_ym.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfyveg_ym.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfyveg_ym.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfyveg_ym.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfyveg_ym.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfyveg_ym.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfyveg_ym.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfyveg_ym.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfyveg_ym.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfyveg_ym.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfyveg_ym.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfyveg_ym.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfyveg_ym.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfyveg_ym.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfyveg_ym.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfyveg_ym.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfyveg_ym.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfyveg_ym.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfyveg_ym.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4hdroy81.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp4hdroy81.jl:13\n\
    \   [2] top-level scope at /tmp/tmp4hdroy81.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4hdroy81.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp4hdroy81.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp4hdroy81.jl:13\n\
    \   [2] top-level scope at /tmp/tmp4hdroy81.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4hdroy81.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp4hdroy81.jl:22\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp4hdroy81.jl:13\n\
    \   [2] top-level scope at /tmp/tmp4hdroy81.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4hdroy81.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp4hdroy81.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp4hdroy81.jl:13\n\
    \   [2] top-level scope at /tmp/tmp4hdroy81.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4hdroy81.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp4hdroy81.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp4hdroy81.jl:13\n\
    \   [2] top-level scope at /tmp/tmp4hdroy81.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4hdroy81.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp4hdroy81.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp4hdroy81.jl:13\n\
    \   [2] top-level scope at /tmp/tmp4hdroy81.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4hdroy81.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4hdroy81.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpsrny7byv.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsrny7byv.jl:13\\\
    n   [2] top-level scope at /tmp/tmpsrny7byv.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsrny7byv.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsrny7byv.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsrny7byv.jl:13\\\
    n   [2] top-level scope at /tmp/tmpsrny7byv.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsrny7byv.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsrny7byv.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsrny7byv.jl:13\\\
    n   [2] top-level scope at /tmp/tmpsrny7byv.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsrny7byv.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsrny7byv.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsrny7byv.jl:13\\\
    n   [2] top-level scope at /tmp/tmpsrny7byv.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsrny7byv.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsrny7byv.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsrny7byv.jl:13\\\
    n   [2] top-level scope at /tmp/tmpsrny7byv.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsrny7byv.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsrny7byv.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsrny7byv.jl:13\\\
    n   [2] top-level scope at /tmp/tmpsrny7byv.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsrny7byv.jl:18\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)),x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcia5ib_z.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpcia5ib_z.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcia5ib_z.jl:18\ntest set: Test Failed at /tmp/tmpcia5ib_z.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcia5ib_z.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcia5ib_z.jl:18\ntest set: Test Failed at /tmp/tmpcia5ib_z.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpcia5ib_z.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcia5ib_z.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcia5ib_z.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return nums\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1,\
    \ -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53,\
    \ 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37,\
    \ 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8lv3h09l.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [1, 11, -1, -11,\
    \ -12] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp8lv3h09l.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8lv3h09l.jl:19\ntest set: Test Failed at /tmp/tmp8lv3h09l.jl:21\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8lv3h09l.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8lv3h09l.jl:19\ntest set: Test Failed at /tmp/tmp8lv3h09l.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [1, -11, -32, 43, 54, -98, 2, -3] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp8lv3h09l.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8lv3h09l.jl:19\ntest set: Test Failed at /tmp/tmp8lv3h09l.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11,\
    \ 3, 4, 5, 6, 7, 8, 9]\n   Evaluated: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] == [1,\
    \ 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nStacktrace:\n [1] top-level scope at /tmp/tmp8lv3h09l.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8lv3h09l.jl:19\ntest set: Test Failed at /tmp/tmp8lv3h09l.jl:25\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [0, 6, 6, -76, -21, 23, 4] == [-76, -21, 0, 4, 23, 6, 6]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8lv3h09l.jl:25\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8lv3h09l.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8lv3h09l.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy50b86rh.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpy50b86rh.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy50b86rh.jl:18\ntest set: Test Failed at /tmp/tmpy50b86rh.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy50b86rh.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy50b86rh.jl:18\ntest set: Test Failed at /tmp/tmpy50b86rh.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpy50b86rh.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy50b86rh.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy50b86rh.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1y0_u3lv.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp1y0_u3lv.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1y0_u3lv.jl:18\ntest set: Test Failed at /tmp/tmp1y0_u3lv.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1y0_u3lv.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1y0_u3lv.jl:18\ntest set: Test Failed at /tmp/tmp1y0_u3lv.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp1y0_u3lv.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1y0_u3lv.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1y0_u3lv.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    nums_with_sum = [(sum(digits(x)), x) for x in nums]\n    sorted_nums =\
    \ sort(nums_with_sum, by=x->x[1])\n    return [x[2] for x in sorted_nums]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj_ip5tns.jl:21\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpj_ip5tns.jl:21\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj_ip5tns.jl:20\ntest set: Test Failed at /tmp/tmpj_ip5tns.jl:24\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpj_ip5tns.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj_ip5tns.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj_ip5tns.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5atb3ckl.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp5atb3ckl.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5atb3ckl.jl:18\ntest set: Test Failed at /tmp/tmp5atb3ckl.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5atb3ckl.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5atb3ckl.jl:18\ntest set: Test Failed at /tmp/tmp5atb3ckl.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp5atb3ckl.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5atb3ckl.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5atb3ckl.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = [sum(digits(n))\
    \ for n in nums]\n    return nums[sortperm(sums)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1sun48xk.jl:23\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp1sun48xk.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1sun48xk.jl:22\ntest set: Test Failed at /tmp/tmp1sun48xk.jl:26\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp1sun48xk.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1sun48xk.jl:22\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1sun48xk.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpsl7yz3yp.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsl7yz3yp.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsl7yz3yp.jl:18\\ntest set: Test Failed at /tmp/tmpsl7yz3yp.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsl7yz3yp.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsl7yz3yp.jl:18\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp128a43l4.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp128a43l4.jl:13\n\
    \   [2] top-level scope at /tmp/tmp128a43l4.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp128a43l4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp128a43l4.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp128a43l4.jl:13\n\
    \   [2] top-level scope at /tmp/tmp128a43l4.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp128a43l4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp128a43l4.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp128a43l4.jl:13\n\
    \   [2] top-level scope at /tmp/tmp128a43l4.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp128a43l4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp128a43l4.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp128a43l4.jl:13\n\
    \   [2] top-level scope at /tmp/tmp128a43l4.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp128a43l4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp128a43l4.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp128a43l4.jl:13\n\
    \   [2] top-level scope at /tmp/tmp128a43l4.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp128a43l4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp128a43l4.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp128a43l4.jl:13\n\
    \   [2] top-level scope at /tmp/tmp128a43l4.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp128a43l4.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp128a43l4.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpifrmudg8.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpifrmudg8.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpifrmudg8.jl:18\ntest set: Test Failed at /tmp/tmpifrmudg8.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpifrmudg8.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpifrmudg8.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpifrmudg8.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkmaj1bc4.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpkmaj1bc4.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkmaj1bc4.jl:18\ntest set: Test Failed at /tmp/tmpkmaj1bc4.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkmaj1bc4.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkmaj1bc4.jl:18\ntest set: Test Failed at /tmp/tmpkmaj1bc4.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpkmaj1bc4.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkmaj1bc4.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkmaj1bc4.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return []\n    end\n    sums = [sum(digits(x))\
    \ for x in nums]\n    return [nums[i] for i in sortperm(sums)]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzw2x00tl.jl:23\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpzw2x00tl.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzw2x00tl.jl:22\ntest set: Test Failed at /tmp/tmpzw2x00tl.jl:26\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpzw2x00tl.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzw2x00tl.jl:22\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzw2x00tl.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sortperm(sum.(digits.(nums)), 1:length(nums))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjmq2omtl.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpjmq2omtl.jl:12\n   [2] top-level scope at /tmp/tmpjmq2omtl.jl:19\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjmq2omtl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjmq2omtl.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpjmq2omtl.jl:12\n\
    \   [2] top-level scope at /tmp/tmpjmq2omtl.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjmq2omtl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjmq2omtl.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching sortperm(::Array{Int64,1},\
    \ ::UnitRange{Int64})\n  Closest candidates are:\n    sortperm(::AbstractArray{T,1}\
    \ where T; alg, lt, by, rev, order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpjmq2omtl.jl:12\n   [2] top-level scope at /tmp/tmpjmq2omtl.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjmq2omtl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjmq2omtl.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpjmq2omtl.jl:12\n   [2] top-level scope at /tmp/tmpjmq2omtl.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjmq2omtl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjmq2omtl.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpjmq2omtl.jl:12\n   [2] top-level scope at /tmp/tmpjmq2omtl.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjmq2omtl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjmq2omtl.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpjmq2omtl.jl:12\n\
    \   [2] top-level scope at /tmp/tmpjmq2omtl.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjmq2omtl.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjmq2omtl.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpasxaqwl6.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpasxaqwl6.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpasxaqwl6.jl:18\ntest set: Test Failed at /tmp/tmpasxaqwl6.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpasxaqwl6.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpasxaqwl6.jl:18\ntest set: Test Failed at /tmp/tmpasxaqwl6.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpasxaqwl6.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpasxaqwl6.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpasxaqwl6.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_b14pdzz.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_b14pdzz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_b14pdzz.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_b14pdzz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_b14pdzz.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_b14pdzz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_b14pdzz.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_b14pdzz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_b14pdzz.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_b14pdzz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_b14pdzz.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_b14pdzz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_b14pdzz.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_b14pdzz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_b14pdzz.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_b14pdzz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_b14pdzz.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_b14pdzz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_b14pdzz.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_b14pdzz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_b14pdzz.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_b14pdzz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_b14pdzz.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_b14pdzz.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_b14pdzz.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # sort by sum of digits\n    # if there are several items with similar\
    \ sum of their digits,\n    # order them based on their index in original list.\n\
    \    # return the sorted list\n    return sort(nums, by=x->(sum(digits(x)), findall(x->x==x,\
    \ nums)[1]))\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphnbnsxkr.jl:23\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmphnbnsxkr.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphnbnsxkr.jl:22\ntest set: Test Failed at /tmp/tmphnbnsxkr.jl:26\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmphnbnsxkr.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphnbnsxkr.jl:22\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphnbnsxkr.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmprvp557my.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmprvp557my.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprvp557my.jl:18\\ntest set: Test Failed at /tmp/tmprvp557my.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmprvp557my.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprvp557my.jl:18\\ntest set: Test Failed at /tmp/tmprvp557my.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmprvp557my.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprvp557my.jl:18\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = zeros(length(nums))\n\
    \    for i in 1:length(nums)\n        sums[i] = sum(digits(nums[i]))\n    end\n\
    \    return nums[sortperm(sums)]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1,\
    \ -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7a_hgmy0.jl:26\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp7a_hgmy0.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7a_hgmy0.jl:25\ntest set: Test Failed at /tmp/tmp7a_hgmy0.jl:29\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp7a_hgmy0.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7a_hgmy0.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7a_hgmy0.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    return sort(nums,\
    \ by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7_c10dlj.jl:22\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp7_c10dlj.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7_c10dlj.jl:21\ntest set: Test Failed at /tmp/tmp7_c10dlj.jl:23\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7_c10dlj.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7_c10dlj.jl:21\ntest set: Test Failed at /tmp/tmp7_c10dlj.jl:25\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp7_c10dlj.jl:25\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7_c10dlj.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7_c10dlj.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpyz5_llk3.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpyz5_llk3.jl:13\\\
    n   [2] top-level scope at /tmp/tmpyz5_llk3.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpyz5_llk3.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpyz5_llk3.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpyz5_llk3.jl:13\\\
    n   [2] top-level scope at /tmp/tmpyz5_llk3.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpyz5_llk3.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpyz5_llk3.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpyz5_llk3.jl:13\\\
    n   [2] top-level scope at /tmp/tmpyz5_llk3.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpyz5_llk3.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpyz5_llk3.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpyz5_llk3.jl:13\\\
    n   [2] top-level scope at /tmp/tmpyz5_llk3.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpyz5_llk3.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpyz5_llk3.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpyz5_llk3.jl:13\\\
    n   [2] top-level scope at /tmp/tmpyz5_llk3.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpyz5_llk3.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpyz5_llk3.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpyz5_llk3.jl:13\\\
    n   [2] top-level scope at /tmp/tmpyz5_llk3.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpyz5_llk3.jl:18\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     6      6\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return nums\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1,\
    \ -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53,\
    \ 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37,\
    \ 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmo0pf8ho.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [1, 11, -1, -11,\
    \ -12] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpmo0pf8ho.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmo0pf8ho.jl:19\ntest set: Test Failed at /tmp/tmpmo0pf8ho.jl:21\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmo0pf8ho.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmo0pf8ho.jl:19\ntest set: Test Failed at /tmp/tmpmo0pf8ho.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [1, -11, -32, 43, 54, -98, 2, -3] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpmo0pf8ho.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmo0pf8ho.jl:19\ntest set: Test Failed at /tmp/tmpmo0pf8ho.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11,\
    \ 3, 4, 5, 6, 7, 8, 9]\n   Evaluated: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] == [1,\
    \ 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nStacktrace:\n [1] top-level scope at /tmp/tmpmo0pf8ho.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmo0pf8ho.jl:19\ntest set: Test Failed at /tmp/tmpmo0pf8ho.jl:25\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [0, 6, 6, -76, -21, 23, 4] == [-76, -21, 0, 4, 23, 6, 6]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmo0pf8ho.jl:25\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmo0pf8ho.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmo0pf8ho.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvcpjh3ci.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpvcpjh3ci.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvcpjh3ci.jl:18\ntest set: Test Failed at /tmp/tmpvcpjh3ci.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvcpjh3ci.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvcpjh3ci.jl:18\ntest set: Test Failed at /tmp/tmpvcpjh3ci.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpvcpjh3ci.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvcpjh3ci.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvcpjh3ci.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = [sum(digits(n))\
    \ for n in nums]\n    return nums[sortperm(sums)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpy5nhjdbh.jl:23\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpy5nhjdbh.jl:23\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy5nhjdbh.jl:22\\ntest set: Test Failed at /tmp/tmpy5nhjdbh.jl:26\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpy5nhjdbh.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy5nhjdbh.jl:22\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     2      6\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpy5nhjdbh.jl:20\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa5j6p5gp.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpa5j6p5gp.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa5j6p5gp.jl:18\ntest set: Test Failed at /tmp/tmpa5j6p5gp.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa5j6p5gp.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa5j6p5gp.jl:18\ntest set: Test Failed at /tmp/tmpa5j6p5gp.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpa5j6p5gp.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa5j6p5gp.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa5j6p5gp.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return nums\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1,\
    \ -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53,\
    \ 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37,\
    \ 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp1xtnvxr.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [1, 11, -1, -11,\
    \ -12] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpp1xtnvxr.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1xtnvxr.jl:19\ntest set: Test Failed at /tmp/tmpp1xtnvxr.jl:21\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp1xtnvxr.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1xtnvxr.jl:19\ntest set: Test Failed at /tmp/tmpp1xtnvxr.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [1, -11, -32, 43, 54, -98, 2, -3] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpp1xtnvxr.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1xtnvxr.jl:19\ntest set: Test Failed at /tmp/tmpp1xtnvxr.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11,\
    \ 3, 4, 5, 6, 7, 8, 9]\n   Evaluated: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] == [1,\
    \ 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nStacktrace:\n [1] top-level scope at /tmp/tmpp1xtnvxr.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1xtnvxr.jl:19\ntest set: Test Failed at /tmp/tmpp1xtnvxr.jl:25\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [0, 6, 6, -76, -21, 23, 4] == [-76, -21, 0, 4, 23, 6, 6]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpp1xtnvxr.jl:25\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1xtnvxr.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp1xtnvxr.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1r8jzwh3.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp1r8jzwh3.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1r8jzwh3.jl:18\ntest set: Test Failed at /tmp/tmp1r8jzwh3.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1r8jzwh3.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1r8jzwh3.jl:18\ntest set: Test Failed at /tmp/tmp1r8jzwh3.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp1r8jzwh3.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1r8jzwh3.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1r8jzwh3.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_dzg0pqq.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_dzg0pqq.jl:13\\\
    n   [2] top-level scope at /tmp/tmp_dzg0pqq.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_dzg0pqq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_dzg0pqq.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_dzg0pqq.jl:13\\\
    n   [2] top-level scope at /tmp/tmp_dzg0pqq.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_dzg0pqq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_dzg0pqq.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_dzg0pqq.jl:13\\\
    n   [2] top-level scope at /tmp/tmp_dzg0pqq.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_dzg0pqq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_dzg0pqq.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_dzg0pqq.jl:13\\\
    n   [2] top-level scope at /tmp/tmp_dzg0pqq.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_dzg0pqq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_dzg0pqq.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_dzg0pqq.jl:13\\\
    n   [2] top-level scope at /tmp/tmp_dzg0pqq.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_dzg0pqq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp_dzg0pqq.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_dzg0pqq.jl:13\\\
    n   [2] top-level scope at /tmp/tmp_dzg0pqq.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp_dzg0pqq.jl:18\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp3z7b2278.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3z7b2278.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3z7b2278.jl:18\\ntest set: Test Failed at /tmp/tmp3z7b2278.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp3z7b2278.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3z7b2278.jl:18\\ntest set: Test Failed at /tmp/tmp3z7b2278.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3z7b2278.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3z7b2278.jl:18\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     3      6\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd3wbx5ow.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpd3wbx5ow.jl:13\n\
    \   [2] top-level scope at /tmp/tmpd3wbx5ow.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd3wbx5ow.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpd3wbx5ow.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpd3wbx5ow.jl:13\n\
    \   [2] top-level scope at /tmp/tmpd3wbx5ow.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd3wbx5ow.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpd3wbx5ow.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpd3wbx5ow.jl:13\n\
    \   [2] top-level scope at /tmp/tmpd3wbx5ow.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd3wbx5ow.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpd3wbx5ow.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpd3wbx5ow.jl:13\n\
    \   [2] top-level scope at /tmp/tmpd3wbx5ow.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd3wbx5ow.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpd3wbx5ow.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpd3wbx5ow.jl:13\n\
    \   [2] top-level scope at /tmp/tmpd3wbx5ow.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd3wbx5ow.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpd3wbx5ow.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpd3wbx5ow.jl:13\n\
    \   [2] top-level scope at /tmp/tmpd3wbx5ow.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd3wbx5ow.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd3wbx5ow.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    sorted_nums = sort(nums, by=x->sum(digits(x)))\n    return sorted_nums\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxe1w4iy1.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpxe1w4iy1.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxe1w4iy1.jl:19\ntest set: Test Failed at /tmp/tmpxe1w4iy1.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpxe1w4iy1.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxe1w4iy1.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxe1w4iy1.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpbvsm27mq.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpbvsm27mq.jl:13\\\
    n   [2] top-level scope at /tmp/tmpbvsm27mq.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbvsm27mq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbvsm27mq.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpbvsm27mq.jl:13\\\
    n   [2] top-level scope at /tmp/tmpbvsm27mq.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbvsm27mq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbvsm27mq.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpbvsm27mq.jl:13\\\
    n   [2] top-level scope at /tmp/tmpbvsm27mq.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbvsm27mq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbvsm27mq.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpbvsm27mq.jl:13\\\
    n   [2] top-level scope at /tmp/tmpbvsm27mq.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbvsm27mq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbvsm27mq.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpbvsm27mq.jl:13\\\
    n   [2] top-level scope at /tmp/tmpbvsm27mq.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbvsm27mq.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbvsm27mq.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpbvsm27mq.jl:13\\\
    n   [2] top-level scope at /tmp/tmpbvsm27mq.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpbvsm27mq.jl:18\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     6      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1gnqsdbw.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1gnqsdbw.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1gnqsdbw.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gnqsdbw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1gnqsdbw.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1gnqsdbw.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1gnqsdbw.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gnqsdbw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1gnqsdbw.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1gnqsdbw.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1gnqsdbw.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gnqsdbw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1gnqsdbw.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1gnqsdbw.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1gnqsdbw.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gnqsdbw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1gnqsdbw.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1gnqsdbw.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1gnqsdbw.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gnqsdbw.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1gnqsdbw.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1gnqsdbw.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1gnqsdbw.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gnqsdbw.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1gnqsdbw.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdc_vuy7s.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdc_vuy7s.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdc_vuy7s.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdc_vuy7s.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdc_vuy7s.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdc_vuy7s.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdc_vuy7s.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdc_vuy7s.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdc_vuy7s.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdc_vuy7s.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdc_vuy7s.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdc_vuy7s.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdc_vuy7s.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdc_vuy7s.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdc_vuy7s.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdc_vuy7s.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdc_vuy7s.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdc_vuy7s.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdc_vuy7s.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdc_vuy7s.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdc_vuy7s.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdc_vuy7s.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdc_vuy7s.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdc_vuy7s.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdc_vuy7s.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(x, -x))\nend\nusing Test\n\n@testset begin\n\n\
    candidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1,\
    \ -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53,\
    \ 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37,\
    \ 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpalpjyg04.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpalpjyg04.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpalpjyg04.jl:18\ntest set: Test Failed at /tmp/tmpalpjyg04.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 37, 46, 53, 56, 145, 423, 423, 423, 463, 1234, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpalpjyg04.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpalpjyg04.jl:18\ntest set: Test Failed at /tmp/tmpalpjyg04.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -11, -3, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpalpjyg04.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpalpjyg04.jl:18\ntest set: Test Failed at /tmp/tmpalpjyg04.jl:23\n\
    \  Expression: candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11,\
    \ 3, 4, 5, 6, 7, 8, 9]\n   Evaluated: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] == [1,\
    \ 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nStacktrace:\n [1] top-level scope at /tmp/tmpalpjyg04.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpalpjyg04.jl:18\ntest set: Test Failed at /tmp/tmpalpjyg04.jl:24\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [-76, -21, 0, 4, 6, 6, 23] == [-76, -21, 0, 4, 23, 6, 6]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpalpjyg04.jl:24\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpalpjyg04.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpalpjyg04.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = [sum(digits(x))\
    \ for x in nums]\n    indices = sortperm(sums)\n    return nums[indices]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpas2e5ox9.jl:24\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpas2e5ox9.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpas2e5ox9.jl:23\ntest set: Test Failed at /tmp/tmpas2e5ox9.jl:27\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpas2e5ox9.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpas2e5ox9.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpas2e5ox9.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd4yoqrrz.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpd4yoqrrz.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd4yoqrrz.jl:18\ntest set: Test Failed at /tmp/tmpd4yoqrrz.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd4yoqrrz.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd4yoqrrz.jl:18\ntest set: Test Failed at /tmp/tmpd4yoqrrz.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpd4yoqrrz.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd4yoqrrz.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd4yoqrrz.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpi927vv7z.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi927vv7z.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi927vv7z.jl:18\\ntest set: Test Failed at /tmp/tmpi927vv7z.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpi927vv7z.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi927vv7z.jl:18\\ntest set: Test Failed at /tmp/tmpi927vv7z.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi927vv7z.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi927vv7z.jl:18\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpvmx_73jz.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpvmx_73jz.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvmx_73jz.jl:18\\ntest set: Test Failed at /tmp/tmpvmx_73jz.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpvmx_73jz.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvmx_73jz.jl:18\\ntest set: Test Failed at /tmp/tmpvmx_73jz.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpvmx_73jz.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvmx_73jz.jl:18\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     3      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmlm1gjas.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpmlm1gjas.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmlm1gjas.jl:18\ntest set: Test Failed at /tmp/tmpmlm1gjas.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpmlm1gjas.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmlm1gjas.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmlm1gjas.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    sums = [sum(digits(x)) for x in nums]\n    return sortperm(sums, 1)[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpi3jx5gsz.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::Int64)\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi3jx5gsz.jl:13\n\
    \   [2] top-level scope at /tmp/tmpi3jx5gsz.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi3jx5gsz.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpi3jx5gsz.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n  \
    \  sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at sort.jl:904\n\
    \  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi3jx5gsz.jl:13\n\
    \   [2] top-level scope at /tmp/tmpi3jx5gsz.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi3jx5gsz.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpi3jx5gsz.jl:22\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching sortperm(::Array{Int64,1},\
    \ ::Int64)\n  Closest candidates are:\n    sortperm(::AbstractArray{T,1} where\
    \ T; alg, lt, by, rev, order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpi3jx5gsz.jl:13\n   [2] top-level scope at /tmp/tmpi3jx5gsz.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi3jx5gsz.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpi3jx5gsz.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::Int64)\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi3jx5gsz.jl:13\n\
    \   [2] top-level scope at /tmp/tmpi3jx5gsz.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi3jx5gsz.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpi3jx5gsz.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::Int64)\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi3jx5gsz.jl:13\n\
    \   [2] top-level scope at /tmp/tmpi3jx5gsz.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi3jx5gsz.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpi3jx5gsz.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n  \
    \  sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at sort.jl:904\n\
    \  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi3jx5gsz.jl:13\n\
    \   [2] top-level scope at /tmp/tmpi3jx5gsz.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi3jx5gsz.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi3jx5gsz.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp35cnotr.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpp35cnotr.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp35cnotr.jl:18\ntest set: Test Failed at /tmp/tmpp35cnotr.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp35cnotr.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp35cnotr.jl:18\ntest set: Test Failed at /tmp/tmpp35cnotr.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpp35cnotr.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp35cnotr.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp35cnotr.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkp0i6voa.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkp0i6voa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkp0i6voa.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkp0i6voa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpkp0i6voa.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkp0i6voa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkp0i6voa.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkp0i6voa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpkp0i6voa.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkp0i6voa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkp0i6voa.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkp0i6voa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpkp0i6voa.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkp0i6voa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkp0i6voa.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkp0i6voa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpkp0i6voa.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkp0i6voa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkp0i6voa.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkp0i6voa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpkp0i6voa.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkp0i6voa.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkp0i6voa.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkp0i6voa.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkp0i6voa.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sortperm(sum.(digits.(nums)), 1:length(nums))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2n6hg_s4.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp2n6hg_s4.jl:12\n   [2] top-level scope at /tmp/tmp2n6hg_s4.jl:19\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2n6hg_s4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2n6hg_s4.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2n6hg_s4.jl:12\n\
    \   [2] top-level scope at /tmp/tmp2n6hg_s4.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2n6hg_s4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2n6hg_s4.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching sortperm(::Array{Int64,1},\
    \ ::UnitRange{Int64})\n  Closest candidates are:\n    sortperm(::AbstractArray{T,1}\
    \ where T; alg, lt, by, rev, order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp2n6hg_s4.jl:12\n   [2] top-level scope at /tmp/tmp2n6hg_s4.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2n6hg_s4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2n6hg_s4.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp2n6hg_s4.jl:12\n   [2] top-level scope at /tmp/tmp2n6hg_s4.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2n6hg_s4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2n6hg_s4.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp2n6hg_s4.jl:12\n   [2] top-level scope at /tmp/tmp2n6hg_s4.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2n6hg_s4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2n6hg_s4.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2n6hg_s4.jl:12\n\
    \   [2] top-level scope at /tmp/tmp2n6hg_s4.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2n6hg_s4.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2n6hg_s4.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    # sort by sum\
    \ of digits\n    sort!(nums, by = x -> sum(digits(x)))\n    return nums\nend\n\
    using Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmzuflfuw.jl:24\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpmzuflfuw.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmzuflfuw.jl:23\ntest set: Test Failed at /tmp/tmpmzuflfuw.jl:27\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpmzuflfuw.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmzuflfuw.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmzuflfuw.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sortperm(sum.(abs.(digits.(nums))), collect(1:length(nums)))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpurth4r9e.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ no method matching abs(::Array{Int64,1})\n  Closest candidates are:\n    abs(!Matched::Pkg.Resolve.FieldValue)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/fieldvalues.jl:61\n\
    \    abs(!Matched::Pkg.Resolve.VersionWeight) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/versionweights.jl:36\n\
    \    abs(!Matched::Missing) at missing.jl:100\n    ...\n  Stacktrace:\n   [1]\
    \ _broadcast_getindex_evalf at ./broadcast.jl:631 [inlined]\n   [2] _broadcast_getindex\
    \ at ./broadcast.jl:604 [inlined]\n   [3] _getindex at ./broadcast.jl:628 [inlined]\n\
    \   [4] _broadcast_getindex at ./broadcast.jl:603 [inlined]\n   [5] getindex at\
    \ ./broadcast.jl:564 [inlined]\n   [6] copy at ./broadcast.jl:854 [inlined]\n\
    \   [7] materialize at ./broadcast.jl:820 [inlined]\n   [8] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpurth4r9e.jl:12\n   [9] top-level scope at /tmp/tmpurth4r9e.jl:19\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpurth4r9e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpurth4r9e.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: no method\
    \ matching abs(::Array{Int64,1})\n  Closest candidates are:\n    abs(!Matched::Pkg.Resolve.FieldValue)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/fieldvalues.jl:61\n\
    \    abs(!Matched::Pkg.Resolve.VersionWeight) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/versionweights.jl:36\n\
    \    abs(!Matched::Missing) at missing.jl:100\n    ...\n  Stacktrace:\n   [1]\
    \ _broadcast_getindex_evalf at ./broadcast.jl:631 [inlined]\n   [2] _broadcast_getindex\
    \ at ./broadcast.jl:604 [inlined]\n   [3] _getindex at ./broadcast.jl:628 [inlined]\n\
    \   [4] _broadcast_getindex at ./broadcast.jl:603 [inlined]\n   [5] getindex at\
    \ ./broadcast.jl:564 [inlined]\n   [6] copy at ./broadcast.jl:854 [inlined]\n\
    \   [7] materialize at ./broadcast.jl:820 [inlined]\n   [8] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpurth4r9e.jl:12\n   [9] top-level scope at /tmp/tmpurth4r9e.jl:20\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpurth4r9e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpurth4r9e.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching sortperm(::Array{Union{},1},\
    \ ::Array{Int64,1})\n  Closest candidates are:\n    sortperm(::AbstractArray{T,1}\
    \ where T; alg, lt, by, rev, order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpurth4r9e.jl:12\n   [2] top-level scope at /tmp/tmpurth4r9e.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpurth4r9e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpurth4r9e.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ no method matching abs(::Array{Int64,1})\n  Closest candidates are:\n    abs(!Matched::Pkg.Resolve.FieldValue)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/fieldvalues.jl:61\n\
    \    abs(!Matched::Pkg.Resolve.VersionWeight) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/versionweights.jl:36\n\
    \    abs(!Matched::Missing) at missing.jl:100\n    ...\n  Stacktrace:\n   [1]\
    \ _broadcast_getindex_evalf at ./broadcast.jl:631 [inlined]\n   [2] _broadcast_getindex\
    \ at ./broadcast.jl:604 [inlined]\n   [3] _getindex at ./broadcast.jl:628 [inlined]\n\
    \   [4] _broadcast_getindex at ./broadcast.jl:603 [inlined]\n   [5] getindex at\
    \ ./broadcast.jl:564 [inlined]\n   [6] copy at ./broadcast.jl:854 [inlined]\n\
    \   [7] materialize at ./broadcast.jl:820 [inlined]\n   [8] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpurth4r9e.jl:12\n   [9] top-level scope at /tmp/tmpurth4r9e.jl:22\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpurth4r9e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpurth4r9e.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ no method matching abs(::Array{Int64,1})\n  Closest candidates are:\n    abs(!Matched::Pkg.Resolve.FieldValue)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/fieldvalues.jl:61\n\
    \    abs(!Matched::Pkg.Resolve.VersionWeight) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/versionweights.jl:36\n\
    \    abs(!Matched::Missing) at missing.jl:100\n    ...\n  Stacktrace:\n   [1]\
    \ _broadcast_getindex_evalf at ./broadcast.jl:631 [inlined]\n   [2] _broadcast_getindex\
    \ at ./broadcast.jl:604 [inlined]\n   [3] _getindex at ./broadcast.jl:628 [inlined]\n\
    \   [4] _broadcast_getindex at ./broadcast.jl:603 [inlined]\n   [5] getindex at\
    \ ./broadcast.jl:564 [inlined]\n   [6] copy at ./broadcast.jl:854 [inlined]\n\
    \   [7] materialize at ./broadcast.jl:820 [inlined]\n   [8] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpurth4r9e.jl:12\n   [9] top-level scope at /tmp/tmpurth4r9e.jl:23\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpurth4r9e.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpurth4r9e.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: no method\
    \ matching abs(::Array{Int64,1})\n  Closest candidates are:\n    abs(!Matched::Pkg.Resolve.FieldValue)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/fieldvalues.jl:61\n\
    \    abs(!Matched::Pkg.Resolve.VersionWeight) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Pkg/src/Resolve/versionweights.jl:36\n\
    \    abs(!Matched::Missing) at missing.jl:100\n    ...\n  Stacktrace:\n   [1]\
    \ _broadcast_getindex_evalf at ./broadcast.jl:631 [inlined]\n   [2] _broadcast_getindex\
    \ at ./broadcast.jl:604 [inlined]\n   [3] _getindex at ./broadcast.jl:628 [inlined]\n\
    \   [4] _broadcast_getindex at ./broadcast.jl:603 [inlined]\n   [5] getindex at\
    \ ./broadcast.jl:564 [inlined]\n   [6] copy at ./broadcast.jl:854 [inlined]\n\
    \   [7] materialize at ./broadcast.jl:820 [inlined]\n   [8] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpurth4r9e.jl:12\n   [9] top-level scope at /tmp/tmpurth4r9e.jl:24\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmpurth4r9e.jl:18\n  \nTest Summary: | Error\
    \  Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpurth4r9e.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = [sum(digits(x))\
    \ for x in nums]\n    return sortperm(sums)[sortperm(nums)]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw8k_48nm.jl:23\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [2, 1, 3, 5, 4] ==\
    \ [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpw8k_48nm.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw8k_48nm.jl:22\ntest set: Test Failed at /tmp/tmpw8k_48nm.jl:24\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [3, 8, 15, 1, 4, 11, 7, 13, 9, 5, 2, 6, 12, 14, 10] == [0, 2, 3,\
    \ 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpw8k_48nm.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw8k_48nm.jl:22\ntest set: Test Failed at /tmp/tmpw8k_48nm.jl:26\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [7, 8, 3, 5, 6, 4, 2, 1] == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpw8k_48nm.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw8k_48nm.jl:22\ntest set: Test Failed at /tmp/tmpw8k_48nm.jl:28\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [7, 6, 4, 3, 5, 1, 2] == [-76, -21, 0, 4, 23, 6, 6]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw8k_48nm.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw8k_48nm.jl:22\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     4      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw8k_48nm.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7zw_0lm6.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp7zw_0lm6.jl:13\n\
    \   [2] top-level scope at /tmp/tmp7zw_0lm6.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7zw_0lm6.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp7zw_0lm6.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp7zw_0lm6.jl:13\n\
    \   [2] top-level scope at /tmp/tmp7zw_0lm6.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7zw_0lm6.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp7zw_0lm6.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp7zw_0lm6.jl:13\n\
    \   [2] top-level scope at /tmp/tmp7zw_0lm6.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7zw_0lm6.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp7zw_0lm6.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp7zw_0lm6.jl:13\n\
    \   [2] top-level scope at /tmp/tmp7zw_0lm6.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7zw_0lm6.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp7zw_0lm6.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp7zw_0lm6.jl:13\n\
    \   [2] top-level scope at /tmp/tmp7zw_0lm6.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7zw_0lm6.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp7zw_0lm6.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp7zw_0lm6.jl:13\n\
    \   [2] top-level scope at /tmp/tmp7zw_0lm6.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7zw_0lm6.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7zw_0lm6.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return []\n    end\n    sums = zeros(length(nums))\n\
    \    for i in 1:length(nums)\n        sums[i] = sum(digits(nums[i]))\n    end\n\
    \    return nums[sortperm(sums)]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1,\
    \ -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbizci1r0.jl:26\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpbizci1r0.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbizci1r0.jl:25\ntest set: Test Failed at /tmp/tmpbizci1r0.jl:29\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpbizci1r0.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbizci1r0.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbizci1r0.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnvllddm7.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnvllddm7.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnvllddm7.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnvllddm7.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnvllddm7.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnvllddm7.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnvllddm7.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnvllddm7.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnvllddm7.jl:22\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnvllddm7.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnvllddm7.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnvllddm7.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnvllddm7.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnvllddm7.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnvllddm7.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnvllddm7.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnvllddm7.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnvllddm7.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnvllddm7.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnvllddm7.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnvllddm7.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnvllddm7.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnvllddm7.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnvllddm7.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnvllddm7.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp547_j57k.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp547_j57k.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp547_j57k.jl:18\ntest set: Test Failed at /tmp/tmp547_j57k.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp547_j57k.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp547_j57k.jl:18\ntest set: Test Failed at /tmp/tmp547_j57k.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp547_j57k.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp547_j57k.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp547_j57k.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    nums_sorted = sort(nums, by = x -> sum(digits(x)))\n    return nums_sorted\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn8zr2tgb.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpn8zr2tgb.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn8zr2tgb.jl:19\ntest set: Test Failed at /tmp/tmpn8zr2tgb.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpn8zr2tgb.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn8zr2tgb.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn8zr2tgb.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sortperm(sum.(digits.(nums)), 1:length(nums))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjjlgcfsf.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpjjlgcfsf.jl:12\n   [2] top-level scope at /tmp/tmpjjlgcfsf.jl:19\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjjlgcfsf.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjjlgcfsf.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpjjlgcfsf.jl:12\n\
    \   [2] top-level scope at /tmp/tmpjjlgcfsf.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjjlgcfsf.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjjlgcfsf.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching sortperm(::Array{Int64,1},\
    \ ::UnitRange{Int64})\n  Closest candidates are:\n    sortperm(::AbstractArray{T,1}\
    \ where T; alg, lt, by, rev, order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpjjlgcfsf.jl:12\n   [2] top-level scope at /tmp/tmpjjlgcfsf.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjjlgcfsf.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjjlgcfsf.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpjjlgcfsf.jl:12\n   [2] top-level scope at /tmp/tmpjjlgcfsf.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjjlgcfsf.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjjlgcfsf.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpjjlgcfsf.jl:12\n   [2] top-level scope at /tmp/tmpjjlgcfsf.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjjlgcfsf.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpjjlgcfsf.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpjjlgcfsf.jl:12\n\
    \   [2] top-level scope at /tmp/tmpjjlgcfsf.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjjlgcfsf.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjjlgcfsf.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwhi5xqmh.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpwhi5xqmh.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwhi5xqmh.jl:18\ntest set: Test Failed at /tmp/tmpwhi5xqmh.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwhi5xqmh.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwhi5xqmh.jl:18\ntest set: Test Failed at /tmp/tmpwhi5xqmh.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpwhi5xqmh.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwhi5xqmh.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwhi5xqmh.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpct2my04g.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpct2my04g.jl:13\n\
    \   [2] top-level scope at /tmp/tmpct2my04g.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpct2my04g.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpct2my04g.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpct2my04g.jl:13\n\
    \   [2] top-level scope at /tmp/tmpct2my04g.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpct2my04g.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpct2my04g.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpct2my04g.jl:13\n\
    \   [2] top-level scope at /tmp/tmpct2my04g.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpct2my04g.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpct2my04g.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpct2my04g.jl:13\n\
    \   [2] top-level scope at /tmp/tmpct2my04g.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpct2my04g.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpct2my04g.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpct2my04g.jl:13\n\
    \   [2] top-level scope at /tmp/tmpct2my04g.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpct2my04g.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpct2my04g.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpct2my04g.jl:13\n\
    \   [2] top-level scope at /tmp/tmpct2my04g.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpct2my04g.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpct2my04g.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = [sum(digits(n))\
    \ for n in nums]\n    return sortperm(sums)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1,\
    \ -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53,\
    \ 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37,\
    \ 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprurljdr5.jl:23\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [5, 4, 3, 1, 2] ==\
    \ [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmprurljdr5.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprurljdr5.jl:22\ntest set: Test Failed at /tmp/tmprurljdr5.jl:24\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [14, 5, 12, 9, 8, 2, 6, 7, 1, 4, 10, 15, 13, 3, 11] == [0, 2, 3,\
    \ 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmprurljdr5.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprurljdr5.jl:22\ntest set: Test Failed at /tmp/tmprurljdr5.jl:26\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [6, 3, 8, 2, 1, 7, 4, 5] == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmprurljdr5.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprurljdr5.jl:22\ntest set: Test Failed at /tmp/tmprurljdr5.jl:28\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [4, 5, 1, 7, 6, 2, 3] == [-76, -21, 0, 4, 23, 6, 6]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprurljdr5.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprurljdr5.jl:22\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     4      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprurljdr5.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    nums_with_points = [(n, sum(digits(n))) for n in nums]\n    sorted_nums_with_points\
    \ = sort(nums_with_points, by=x -> x[2])\n    return [n for (n, _) in sorted_nums_with_points]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpwg2zs4_p.jl:21\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwg2zs4_p.jl:21\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwg2zs4_p.jl:20\\ntest set: Test Failed at /tmp/tmpwg2zs4_p.jl:24\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpwg2zs4_p.jl:24\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwg2zs4_p.jl:20\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwxkv2xk0.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwxkv2xk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwxkv2xk0.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwxkv2xk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwxkv2xk0.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwxkv2xk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwxkv2xk0.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwxkv2xk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwxkv2xk0.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwxkv2xk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwxkv2xk0.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwxkv2xk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwxkv2xk0.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwxkv2xk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwxkv2xk0.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwxkv2xk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwxkv2xk0.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwxkv2xk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwxkv2xk0.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwxkv2xk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwxkv2xk0.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwxkv2xk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwxkv2xk0.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwxkv2xk0.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwxkv2xk0.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3k6dcr1a.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp3k6dcr1a.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3k6dcr1a.jl:18\ntest set: Test Failed at /tmp/tmp3k6dcr1a.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3k6dcr1a.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3k6dcr1a.jl:18\ntest set: Test Failed at /tmp/tmp3k6dcr1a.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp3k6dcr1a.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3k6dcr1a.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3k6dcr1a.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq2y1af9q.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpq2y1af9q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpq2y1af9q.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq2y1af9q.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq2y1af9q.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpq2y1af9q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpq2y1af9q.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq2y1af9q.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq2y1af9q.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpq2y1af9q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpq2y1af9q.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq2y1af9q.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq2y1af9q.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpq2y1af9q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpq2y1af9q.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq2y1af9q.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq2y1af9q.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpq2y1af9q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpq2y1af9q.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq2y1af9q.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpq2y1af9q.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpq2y1af9q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpq2y1af9q.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq2y1af9q.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq2y1af9q.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpshu6g_ps.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpshu6g_ps.jl:13\\\
    n   [2] top-level scope at /tmp/tmpshu6g_ps.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpshu6g_ps.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpshu6g_ps.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpshu6g_ps.jl:13\\\
    n   [2] top-level scope at /tmp/tmpshu6g_ps.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpshu6g_ps.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpshu6g_ps.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpshu6g_ps.jl:13\\\
    n   [2] top-level scope at /tmp/tmpshu6g_ps.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpshu6g_ps.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpshu6g_ps.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpshu6g_ps.jl:13\\\
    n   [2] top-level scope at /tmp/tmpshu6g_ps.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpshu6g_ps.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpshu6g_ps.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpshu6g_ps.jl:13\\\
    n   [2] top-level scope at /tmp/tmpshu6g_ps.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpshu6g_ps.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpshu6g_ps.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpshu6g_ps.jl:13\\\
    n   [2] top-level scope at /tmp/tmpshu6g_ps.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpshu6g_ps.jl:18\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # sort by sum of digits\n    # if sum of digits is equal, sort by index\n\
    \    # sort by index\n    # sort by sum of digits\n    # sort by index\n    #\
    \ sort by sum of digits\n    # sort by index\n    # sort by sum of digits\n  \
    \  # sort by index\n    # sort by sum of digits\n    # sort by index\n    # sort\
    \ by sum of digits\n    # sort by index\n    # sort by sum of digits\n    # sort\
    \ by index\n    # sort by sum of digits\n    # sort by index\n    # sort by sum\
    \ of digits\n    # sort by index\n    # sort by sum of digits\n    # sort by index\n\
    \    # sort by sum of digits\n    # sort by index\n    # sort by sum of digits\n\
    \    # sort by index\n    # sort by sum of digits\n    # sort by index\n    #\
    \ sort by sum of digits\n    # sort by index\n    # sort by sum of digits\n  \
    \  # sort by index\n    # sort by sum of digits\n    # sort by index\n    # sort\
    \ by sum of digits\n    # sort by index\n    # sort by sum of digits\n    # sort\
    \ by index\n    # sort by sum of digits\n    # sort by index\n    # sort by sum\
    \ of digits\n    # sort by index\n    # sort by sum of digits\n    # sort by index\n\
    \    # sort by sum of digits\n    # sort by index\n    # sort by sum of digits\n\
    \    # sort by index\n    # sort by sum of digits\n    # sort by index\n    #\
    \ sort by sum of digits\n    # sort by index\n    # sort by sum of digits\n  \
    \  # sort by index\n    # sort by sum of digits\n    # sort by index\n    # sort\
    \ by sum of digits\n    # sort by index\n    # sort by sum of digits\n    # sort\
    \ by index\n    # sort by sum of digits\n    # sort by index\n    # sort by sum\
    \ of digits\n    # sort by index\n    # sort by sum of digits\n    # sort by index\n\
    \    # sort by sum of digits\n    # sort by index\n    # sort by sum of digits\n\
    \    # sort by index\n    # sort by sum of digits\n    # sort by index\n    #\
    \ sort by sum of digits\n\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw3hrnd99.jl:11\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpw3hrnd99.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpw3hrnd99.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc75f4heu.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpc75f4heu.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc75f4heu.jl:18\ntest set: Test Failed at /tmp/tmpc75f4heu.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc75f4heu.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc75f4heu.jl:18\ntest set: Test Failed at /tmp/tmpc75f4heu.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpc75f4heu.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc75f4heu.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc75f4heu.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0ftuk56h.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp0ftuk56h.jl:13\n\
    \   [2] top-level scope at /tmp/tmp0ftuk56h.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ftuk56h.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ftuk56h.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp0ftuk56h.jl:13\n\
    \   [2] top-level scope at /tmp/tmp0ftuk56h.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ftuk56h.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ftuk56h.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp0ftuk56h.jl:13\n\
    \   [2] top-level scope at /tmp/tmp0ftuk56h.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ftuk56h.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ftuk56h.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp0ftuk56h.jl:13\n\
    \   [2] top-level scope at /tmp/tmp0ftuk56h.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ftuk56h.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ftuk56h.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp0ftuk56h.jl:13\n\
    \   [2] top-level scope at /tmp/tmp0ftuk56h.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ftuk56h.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp0ftuk56h.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp0ftuk56h.jl:13\n\
    \   [2] top-level scope at /tmp/tmp0ftuk56h.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0ftuk56h.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0ftuk56h.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(x, sum(digits(x))))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpncpiw5hj.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpncpiw5hj.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncpiw5hj.jl:18\ntest set: Test Failed at /tmp/tmpncpiw5hj.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 37, 46, 53, 56, 145, 423, 423, 423, 463, 1234, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpncpiw5hj.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncpiw5hj.jl:18\ntest set: Test Failed at /tmp/tmpncpiw5hj.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -11, -3, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpncpiw5hj.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncpiw5hj.jl:18\ntest set: Test Failed at /tmp/tmpncpiw5hj.jl:23\n\
    \  Expression: candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11,\
    \ 3, 4, 5, 6, 7, 8, 9]\n   Evaluated: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] == [1,\
    \ 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nStacktrace:\n [1] top-level scope at /tmp/tmpncpiw5hj.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncpiw5hj.jl:18\ntest set: Test Failed at /tmp/tmpncpiw5hj.jl:24\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [-76, -21, 0, 4, 6, 6, 23] == [-76, -21, 0, 4, 23, 6, 6]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpncpiw5hj.jl:24\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpncpiw5hj.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpncpiw5hj.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_t6ur7vs.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_t6ur7vs.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_t6ur7vs.jl:18\\ntest set: Test Failed at /tmp/tmp_t6ur7vs.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp_t6ur7vs.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_t6ur7vs.jl:18\\ntest set: Test Failed at /tmp/tmp_t6ur7vs.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_t6ur7vs.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_t6ur7vs.jl:18\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf23tpodn.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpf23tpodn.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf23tpodn.jl:18\ntest set: Test Failed at /tmp/tmpf23tpodn.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf23tpodn.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf23tpodn.jl:18\ntest set: Test Failed at /tmp/tmpf23tpodn.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpf23tpodn.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf23tpodn.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf23tpodn.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> (sum(digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn6o3_cvs.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpn6o3_cvs.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn6o3_cvs.jl:18\ntest set: Test Failed at /tmp/tmpn6o3_cvs.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn6o3_cvs.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn6o3_cvs.jl:18\ntest set: Test Failed at /tmp/tmpn6o3_cvs.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpn6o3_cvs.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn6o3_cvs.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn6o3_cvs.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphzxy8dj2.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmphzxy8dj2.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphzxy8dj2.jl:18\ntest set: Test Failed at /tmp/tmphzxy8dj2.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphzxy8dj2.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphzxy8dj2.jl:18\ntest set: Test Failed at /tmp/tmphzxy8dj2.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmphzxy8dj2.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphzxy8dj2.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphzxy8dj2.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpntsmx02l.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpntsmx02l.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpntsmx02l.jl:18\ntest set: Test Failed at /tmp/tmpntsmx02l.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpntsmx02l.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpntsmx02l.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpntsmx02l.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpi1hiefm6.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi1hiefm6.jl:13\\\
    n   [2] top-level scope at /tmp/tmpi1hiefm6.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi1hiefm6.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpi1hiefm6.jl:21\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi1hiefm6.jl:13\\\
    n   [2] top-level scope at /tmp/tmpi1hiefm6.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi1hiefm6.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpi1hiefm6.jl:22\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi1hiefm6.jl:13\\\
    n   [2] top-level scope at /tmp/tmpi1hiefm6.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi1hiefm6.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpi1hiefm6.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi1hiefm6.jl:13\\\
    n   [2] top-level scope at /tmp/tmpi1hiefm6.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi1hiefm6.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpi1hiefm6.jl:24\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi1hiefm6.jl:13\\\
    n   [2] top-level scope at /tmp/tmpi1hiefm6.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi1hiefm6.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpi1hiefm6.jl:25\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpi1hiefm6.jl:13\\\
    n   [2] top-level scope at /tmp/tmpi1hiefm6.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi1hiefm6.jl:19\\n  \\nTest Summary: | Error\
    \  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp32j0k7q2.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp32j0k7q2.jl:13\n\
    \   [2] top-level scope at /tmp/tmp32j0k7q2.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp32j0k7q2.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp32j0k7q2.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp32j0k7q2.jl:13\n\
    \   [2] top-level scope at /tmp/tmp32j0k7q2.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp32j0k7q2.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp32j0k7q2.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp32j0k7q2.jl:13\n\
    \   [2] top-level scope at /tmp/tmp32j0k7q2.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp32j0k7q2.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp32j0k7q2.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp32j0k7q2.jl:13\n\
    \   [2] top-level scope at /tmp/tmp32j0k7q2.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp32j0k7q2.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp32j0k7q2.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp32j0k7q2.jl:13\n\
    \   [2] top-level scope at /tmp/tmp32j0k7q2.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp32j0k7q2.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp32j0k7q2.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp32j0k7q2.jl:13\n\
    \   [2] top-level scope at /tmp/tmp32j0k7q2.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp32j0k7q2.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp32j0k7q2.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3ba2ksbc.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp3ba2ksbc.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3ba2ksbc.jl:18\ntest set: Test Failed at /tmp/tmp3ba2ksbc.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp3ba2ksbc.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3ba2ksbc.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3ba2ksbc.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw_2hx06g.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpw_2hx06g.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw_2hx06g.jl:18\ntest set: Test Failed at /tmp/tmpw_2hx06g.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpw_2hx06g.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw_2hx06g.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw_2hx06g.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpf4yo2itt.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpf4yo2itt.jl:13\n\
    \   [2] top-level scope at /tmp/tmpf4yo2itt.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf4yo2itt.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpf4yo2itt.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpf4yo2itt.jl:13\n\
    \   [2] top-level scope at /tmp/tmpf4yo2itt.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf4yo2itt.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpf4yo2itt.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpf4yo2itt.jl:13\n\
    \   [2] top-level scope at /tmp/tmpf4yo2itt.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf4yo2itt.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpf4yo2itt.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpf4yo2itt.jl:13\n\
    \   [2] top-level scope at /tmp/tmpf4yo2itt.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf4yo2itt.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpf4yo2itt.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpf4yo2itt.jl:13\n\
    \   [2] top-level scope at /tmp/tmpf4yo2itt.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf4yo2itt.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpf4yo2itt.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpf4yo2itt.jl:13\n\
    \   [2] top-level scope at /tmp/tmpf4yo2itt.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf4yo2itt.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf4yo2itt.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpagr6lgyo.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpagr6lgyo.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpagr6lgyo.jl:18\ntest set: Test Failed at /tmp/tmpagr6lgyo.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpagr6lgyo.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpagr6lgyo.jl:18\ntest set: Test Failed at /tmp/tmpagr6lgyo.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpagr6lgyo.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpagr6lgyo.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpagr6lgyo.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1n1cd2lw.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp1n1cd2lw.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1n1cd2lw.jl:18\ntest set: Test Failed at /tmp/tmp1n1cd2lw.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1n1cd2lw.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1n1cd2lw.jl:18\ntest set: Test Failed at /tmp/tmp1n1cd2lw.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp1n1cd2lw.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1n1cd2lw.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1n1cd2lw.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcvfygrdy.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcvfygrdy.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcvfygrdy.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcvfygrdy.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcvfygrdy.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcvfygrdy.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcvfygrdy.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcvfygrdy.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcvfygrdy.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcvfygrdy.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcvfygrdy.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcvfygrdy.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcvfygrdy.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcvfygrdy.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcvfygrdy.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcvfygrdy.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcvfygrdy.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcvfygrdy.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcvfygrdy.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcvfygrdy.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcvfygrdy.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcvfygrdy.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcvfygrdy.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcvfygrdy.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcvfygrdy.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sortperm(sum.(digits.(nums)), by=nums)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2b29ey1d.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ objects of type Array{Int64,1} are not callable\n  Use square brackets [] for\
    \ indexing an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}},\
    \ ::Int64, ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n\
    \   [3] sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmp2b29ey1d.jl:12\n\
    \   [8] top-level scope at /tmp/tmp2b29ey1d.jl:19\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmp2b29ey1d.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2b29ey1d.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: objects\
    \ of type Array{Int64,1} are not callable\n  Use square brackets [] for indexing\
    \ an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}}, ::Int64,\
    \ ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n   [3]\
    \ sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmp2b29ey1d.jl:12\n\
    \   [8] top-level scope at /tmp/tmp2b29ey1d.jl:20\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmp2b29ey1d.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2b29ey1d.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ objects of type Array{Int64,1} are not callable\n  Use square brackets [] for\
    \ indexing an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}},\
    \ ::Int64, ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n\
    \   [3] sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmp2b29ey1d.jl:12\n\
    \   [8] top-level scope at /tmp/tmp2b29ey1d.jl:22\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmp2b29ey1d.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2b29ey1d.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ objects of type Array{Int64,1} are not callable\n  Use square brackets [] for\
    \ indexing an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}},\
    \ ::Int64, ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n\
    \   [3] sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmp2b29ey1d.jl:12\n\
    \   [8] top-level scope at /tmp/tmp2b29ey1d.jl:23\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmp2b29ey1d.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2b29ey1d.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: objects\
    \ of type Array{Int64,1} are not callable\n  Use square brackets [] for indexing\
    \ an Array.\n  Stacktrace:\n   [1] lt(::Base.Order.By{Array{Int64,1}}, ::Int64,\
    \ ::Int64) at ./ordering.jl:52\n   [2] lt at ./ordering.jl:58 [inlined]\n   [3]\
    \ sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort!(::Array{Int64,1}, ::Base.Sort.QuickSortAlg, ::Base.Order.Perm{Base.Order.By{Array{Int64,1}},Array{Int64,1}})\
    \ at ./sort.jl:655\n   [6] sortperm(::Array{Int64,1}; alg::Base.Sort.QuickSortAlg,\
    \ lt::Function, by::Array{Int64,1}, rev::Nothing, order::Base.Order.ForwardOrdering)\
    \ at ./sort.jl:921\n   [7] order_by_points(::Array{Int64,1}) at /tmp/tmp2b29ey1d.jl:12\n\
    \   [8] top-level scope at /tmp/tmp2b29ey1d.jl:24\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmp2b29ey1d.jl:18\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2b29ey1d.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1dpttgz4.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp1dpttgz4.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1dpttgz4.jl:18\ntest set: Test Failed at /tmp/tmp1dpttgz4.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1dpttgz4.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1dpttgz4.jl:18\ntest set: Test Failed at /tmp/tmp1dpttgz4.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp1dpttgz4.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1dpttgz4.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1dpttgz4.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpglmzebr1.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpglmzebr1.jl:13\n\
    \   [2] top-level scope at /tmp/tmpglmzebr1.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpglmzebr1.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpglmzebr1.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpglmzebr1.jl:13\n\
    \   [2] top-level scope at /tmp/tmpglmzebr1.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpglmzebr1.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpglmzebr1.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpglmzebr1.jl:13\n\
    \   [2] top-level scope at /tmp/tmpglmzebr1.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpglmzebr1.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpglmzebr1.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpglmzebr1.jl:13\n\
    \   [2] top-level scope at /tmp/tmpglmzebr1.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpglmzebr1.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpglmzebr1.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpglmzebr1.jl:13\n\
    \   [2] top-level scope at /tmp/tmpglmzebr1.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpglmzebr1.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpglmzebr1.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpglmzebr1.jl:13\n\
    \   [2] top-level scope at /tmp/tmpglmzebr1.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpglmzebr1.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpglmzebr1.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpguqtugxs.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpguqtugxs.jl:13\\\
    n   [2] top-level scope at /tmp/tmpguqtugxs.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpguqtugxs.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpguqtugxs.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpguqtugxs.jl:13\\\
    n   [2] top-level scope at /tmp/tmpguqtugxs.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpguqtugxs.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpguqtugxs.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpguqtugxs.jl:13\\\
    n   [2] top-level scope at /tmp/tmpguqtugxs.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpguqtugxs.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpguqtugxs.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpguqtugxs.jl:13\\\
    n   [2] top-level scope at /tmp/tmpguqtugxs.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpguqtugxs.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpguqtugxs.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpguqtugxs.jl:13\\\
    n   [2] top-level scope at /tmp/tmpguqtugxs.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpguqtugxs.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpguqtugxs.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpguqtugxs.jl:13\\\
    n   [2] top-level scope at /tmp/tmpguqtugxs.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpguqtugxs.jl:18\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     6      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpoek1tt9m.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpoek1tt9m.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoek1tt9m.jl:18\\ntest set: Test Failed at /tmp/tmpoek1tt9m.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpoek1tt9m.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoek1tt9m.jl:18\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     2      6\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpoek1tt9m.jl:16\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk9sr0cmi.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpk9sr0cmi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpk9sr0cmi.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9sr0cmi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpk9sr0cmi.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpk9sr0cmi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpk9sr0cmi.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9sr0cmi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpk9sr0cmi.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpk9sr0cmi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpk9sr0cmi.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9sr0cmi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpk9sr0cmi.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpk9sr0cmi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpk9sr0cmi.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9sr0cmi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpk9sr0cmi.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpk9sr0cmi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpk9sr0cmi.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9sr0cmi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpk9sr0cmi.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpk9sr0cmi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpk9sr0cmi.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk9sr0cmi.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk9sr0cmi.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpv_5xdjcj.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpv_5xdjcj.jl:13\n\
    \   [2] top-level scope at /tmp/tmpv_5xdjcj.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv_5xdjcj.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpv_5xdjcj.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpv_5xdjcj.jl:13\n\
    \   [2] top-level scope at /tmp/tmpv_5xdjcj.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv_5xdjcj.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpv_5xdjcj.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpv_5xdjcj.jl:13\n\
    \   [2] top-level scope at /tmp/tmpv_5xdjcj.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv_5xdjcj.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpv_5xdjcj.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpv_5xdjcj.jl:13\n\
    \   [2] top-level scope at /tmp/tmpv_5xdjcj.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv_5xdjcj.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpv_5xdjcj.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpv_5xdjcj.jl:13\n\
    \   [2] top-level scope at /tmp/tmpv_5xdjcj.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv_5xdjcj.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpv_5xdjcj.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpv_5xdjcj.jl:13\n\
    \   [2] top-level scope at /tmp/tmpv_5xdjcj.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv_5xdjcj.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv_5xdjcj.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxorj95qi.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxorj95qi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxorj95qi.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxorj95qi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxorj95qi.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxorj95qi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxorj95qi.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxorj95qi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxorj95qi.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxorj95qi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxorj95qi.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxorj95qi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxorj95qi.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxorj95qi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxorj95qi.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxorj95qi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxorj95qi.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxorj95qi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxorj95qi.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxorj95qi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxorj95qi.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxorj95qi.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxorj95qi.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxorj95qi.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxorj95qi.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpu3z1srlg.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpu3z1srlg.jl:13\\\
    n   [2] top-level scope at /tmp/tmpu3z1srlg.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu3z1srlg.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu3z1srlg.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpu3z1srlg.jl:13\\\
    n   [2] top-level scope at /tmp/tmpu3z1srlg.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu3z1srlg.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu3z1srlg.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpu3z1srlg.jl:13\\\
    n   [2] top-level scope at /tmp/tmpu3z1srlg.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu3z1srlg.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu3z1srlg.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpu3z1srlg.jl:13\\\
    n   [2] top-level scope at /tmp/tmpu3z1srlg.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu3z1srlg.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu3z1srlg.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpu3z1srlg.jl:13\\\
    n   [2] top-level scope at /tmp/tmpu3z1srlg.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu3z1srlg.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpu3z1srlg.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpu3z1srlg.jl:13\\\
    n   [2] top-level scope at /tmp/tmpu3z1srlg.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpu3z1srlg.jl:18\\n  \\nTest Summary: | Error\
    \  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgdkwz_ly.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpgdkwz_ly.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgdkwz_ly.jl:18\ntest set: Test Failed at /tmp/tmpgdkwz_ly.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpgdkwz_ly.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgdkwz_ly.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgdkwz_ly.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp141leq41.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp141leq41.jl:13\n\
    \   [2] top-level scope at /tmp/tmp141leq41.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp141leq41.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp141leq41.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp141leq41.jl:13\n\
    \   [2] top-level scope at /tmp/tmp141leq41.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp141leq41.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp141leq41.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp141leq41.jl:13\n\
    \   [2] top-level scope at /tmp/tmp141leq41.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp141leq41.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp141leq41.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp141leq41.jl:13\n\
    \   [2] top-level scope at /tmp/tmp141leq41.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp141leq41.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp141leq41.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp141leq41.jl:13\n\
    \   [2] top-level scope at /tmp/tmp141leq41.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp141leq41.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp141leq41.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp141leq41.jl:13\n\
    \   [2] top-level scope at /tmp/tmp141leq41.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp141leq41.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp141leq41.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp505hkebw.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp505hkebw.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp505hkebw.jl:18\ntest set: Test Failed at /tmp/tmp505hkebw.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp505hkebw.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp505hkebw.jl:18\ntest set: Test Failed at /tmp/tmp505hkebw.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp505hkebw.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp505hkebw.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp505hkebw.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    return sort(nums,\
    \ by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqtucmqxe.jl:22\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqtucmqxe.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqtucmqxe.jl:21\\ntest set: Test Failed at /tmp/tmpqtucmqxe.jl:25\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqtucmqxe.jl:25\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqtucmqxe.jl:21\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      | '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5tdztqvf.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp5tdztqvf.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5tdztqvf.jl:18\ntest set: Test Failed at /tmp/tmp5tdztqvf.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5tdztqvf.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5tdztqvf.jl:18\ntest set: Test Failed at /tmp/tmp5tdztqvf.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp5tdztqvf.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5tdztqvf.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5tdztqvf.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkaclylf5.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkaclylf5.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkaclylf5.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkaclylf5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpkaclylf5.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkaclylf5.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkaclylf5.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkaclylf5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpkaclylf5.jl:22\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkaclylf5.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkaclylf5.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkaclylf5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpkaclylf5.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkaclylf5.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkaclylf5.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkaclylf5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpkaclylf5.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkaclylf5.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkaclylf5.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkaclylf5.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpkaclylf5.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpkaclylf5.jl:13\n\
    \   [2] top-level scope at /tmp/tmpkaclylf5.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkaclylf5.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkaclylf5.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr7td81jb.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpr7td81jb.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr7td81jb.jl:18\ntest set: Test Failed at /tmp/tmpr7td81jb.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr7td81jb.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr7td81jb.jl:18\ntest set: Test Failed at /tmp/tmpr7td81jb.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpr7td81jb.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr7td81jb.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr7td81jb.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp1gc5a_sz.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp1gc5a_sz.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1gc5a_sz.jl:18\\ntest set: Test Failed at /tmp/tmp1gc5a_sz.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp1gc5a_sz.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1gc5a_sz.jl:18\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmptzkw5rd8.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmptzkw5rd8.jl:13\\\
    n   [2] top-level scope at /tmp/tmptzkw5rd8.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmptzkw5rd8.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmptzkw5rd8.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmptzkw5rd8.jl:13\\\
    n   [2] top-level scope at /tmp/tmptzkw5rd8.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmptzkw5rd8.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmptzkw5rd8.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmptzkw5rd8.jl:13\\\
    n   [2] top-level scope at /tmp/tmptzkw5rd8.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmptzkw5rd8.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmptzkw5rd8.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmptzkw5rd8.jl:13\\\
    n   [2] top-level scope at /tmp/tmptzkw5rd8.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmptzkw5rd8.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmptzkw5rd8.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmptzkw5rd8.jl:13\\\
    n   [2] top-level scope at /tmp/tmptzkw5rd8.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmptzkw5rd8.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmptzkw5rd8.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmptzkw5rd8.jl:13\\\
    n   [2] top-level scope at /tmp/tmptzkw5rd8.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmptzkw5rd8.jl:18\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      | '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvy3v5q29.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpvy3v5q29.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvy3v5q29.jl:18\ntest set: Test Failed at /tmp/tmpvy3v5q29.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpvy3v5q29.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvy3v5q29.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvy3v5q29.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3jw2wh7x.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp3jw2wh7x.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3jw2wh7x.jl:18\ntest set: Test Failed at /tmp/tmp3jw2wh7x.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3jw2wh7x.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3jw2wh7x.jl:18\ntest set: Test Failed at /tmp/tmp3jw2wh7x.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp3jw2wh7x.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3jw2wh7x.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3jw2wh7x.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if nums == []\n        return []\n    end\n    return sortperm(sum.(digits.(nums)),\
    \ 1:length(nums))\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpx7n12jak.jl:22\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpx7n12jak.jl:15\n   [2] top-level scope at /tmp/tmpx7n12jak.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpx7n12jak.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpx7n12jak.jl:23\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpx7n12jak.jl:15\n\
    \   [2] top-level scope at /tmp/tmpx7n12jak.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpx7n12jak.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpx7n12jak.jl:25\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpx7n12jak.jl:15\n   [2] top-level scope at /tmp/tmpx7n12jak.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpx7n12jak.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpx7n12jak.jl:26\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ no method matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest\
    \ candidates are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev,\
    \ order) at sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmpx7n12jak.jl:15\n   [2] top-level scope at /tmp/tmpx7n12jak.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpx7n12jak.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpx7n12jak.jl:27\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: no method\
    \ matching sortperm(::Array{Int64,1}, ::UnitRange{Int64})\n  Closest candidates\
    \ are:\n    sortperm(::AbstractArray{T,1} where T; alg, lt, by, rev, order) at\
    \ sort.jl:904\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpx7n12jak.jl:15\n\
    \   [2] top-level scope at /tmp/tmpx7n12jak.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpx7n12jak.jl:21\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx7n12jak.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp1rfgndd3.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp1rfgndd3.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1rfgndd3.jl:18\\ntest set: Test Failed at /tmp/tmp1rfgndd3.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp1rfgndd3.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1rfgndd3.jl:18\\ntest set: Test Failed at /tmp/tmp1rfgndd3.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp1rfgndd3.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1rfgndd3.jl:18\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     3      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqaayyg42.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpqaayyg42.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqaayyg42.jl:18\ntest set: Test Failed at /tmp/tmpqaayyg42.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqaayyg42.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqaayyg42.jl:18\ntest set: Test Failed at /tmp/tmpqaayyg42.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpqaayyg42.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqaayyg42.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqaayyg42.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # sort by sum of digits\n    # if sum of digits is the same, sort by index\n\
    \    # sort by index is the default behavior of sort\n    return sort(nums, by=x->sum(digits(x)))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplmllahx2.jl:22\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmplmllahx2.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplmllahx2.jl:21\ntest set: Test Failed at /tmp/tmplmllahx2.jl:25\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmplmllahx2.jl:25\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplmllahx2.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplmllahx2.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpsra9exme.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsra9exme.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsra9exme.jl:18\\ntest set: Test Failed at /tmp/tmpsra9exme.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpsra9exme.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsra9exme.jl:18\\ntest set: Test Failed at /tmp/tmpsra9exme.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsra9exme.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsra9exme.jl:18\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmputxxp12x.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmputxxp12x.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmputxxp12x.jl:18\ntest set: Test Failed at /tmp/tmputxxp12x.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmputxxp12x.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmputxxp12x.jl:18\ntest set: Test Failed at /tmp/tmputxxp12x.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmputxxp12x.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmputxxp12x.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmputxxp12x.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz_erolta.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpz_erolta.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz_erolta.jl:18\ntest set: Test Failed at /tmp/tmpz_erolta.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz_erolta.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz_erolta.jl:18\ntest set: Test Failed at /tmp/tmpz_erolta.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpz_erolta.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz_erolta.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz_erolta.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = [sum(digits(x))\
    \ for x in nums]\n    return nums[sortperm(sums)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn3c8yet2.jl:23\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpn3c8yet2.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn3c8yet2.jl:22\ntest set: Test Failed at /tmp/tmpn3c8yet2.jl:26\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpn3c8yet2.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn3c8yet2.jl:22\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn3c8yet2.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzzcuzwbg.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpzzcuzwbg.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzzcuzwbg.jl:18\ntest set: Test Failed at /tmp/tmpzzcuzwbg.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzzcuzwbg.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzzcuzwbg.jl:18\ntest set: Test Failed at /tmp/tmpzzcuzwbg.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpzzcuzwbg.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzzcuzwbg.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzzcuzwbg.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9ddxhach.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ddxhach.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ddxhach.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ddxhach.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ddxhach.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ddxhach.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ddxhach.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ddxhach.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ddxhach.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ddxhach.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ddxhach.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ddxhach.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ddxhach.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ddxhach.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ddxhach.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ddxhach.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ddxhach.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ddxhach.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ddxhach.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ddxhach.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ddxhach.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ddxhach.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ddxhach.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ddxhach.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ddxhach.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = zeros(length(nums))\n\
    \    for i in 1:length(nums)\n        sums[i] = sum(digits(nums[i]))\n    end\n\
    \    sortperm(sums)\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0dp8aav4.jl:26\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [5, 4, 3, 1, 2] ==\
    \ [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp0dp8aav4.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0dp8aav4.jl:25\ntest set: Test Failed at /tmp/tmp0dp8aav4.jl:27\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [14, 5, 12, 9, 8, 2, 6, 7, 1, 4, 10, 15, 13, 3, 11] == [0, 2, 3,\
    \ 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp0dp8aav4.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0dp8aav4.jl:25\ntest set: Test Failed at /tmp/tmp0dp8aav4.jl:29\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [6, 3, 8, 2, 1, 7, 4, 5] == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp0dp8aav4.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0dp8aav4.jl:25\ntest set: Test Failed at /tmp/tmp0dp8aav4.jl:31\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [4, 5, 1, 7, 6, 2, 3] == [-76, -21, 0, 4, 23, 6, 6]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0dp8aav4.jl:31\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0dp8aav4.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     4      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0dp8aav4.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp02ga6r15.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp02ga6r15.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp02ga6r15.jl:18\\ntest set: Test Failed at /tmp/tmp02ga6r15.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp02ga6r15.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp02ga6r15.jl:18\\ntest set: Test Failed at /tmp/tmp02ga6r15.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp02ga6r15.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp02ga6r15.jl:18\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     3      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1x3os5j_.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1x3os5j_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1x3os5j_.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1x3os5j_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1x3os5j_.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1x3os5j_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1x3os5j_.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1x3os5j_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1x3os5j_.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1x3os5j_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1x3os5j_.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1x3os5j_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1x3os5j_.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1x3os5j_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1x3os5j_.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1x3os5j_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1x3os5j_.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1x3os5j_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1x3os5j_.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1x3os5j_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp1x3os5j_.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp1x3os5j_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp1x3os5j_.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1x3os5j_.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1x3os5j_.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpta6tkr0f.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpta6tkr0f.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpta6tkr0f.jl:18\ntest set: Test Failed at /tmp/tmpta6tkr0f.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpta6tkr0f.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpta6tkr0f.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpta6tkr0f.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpaywsifxj.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpaywsifxj.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaywsifxj.jl:18\\ntest set: Test Failed at /tmp/tmpaywsifxj.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmplhj5z4ra.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplhj5z4ra.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplhj5z4ra.jl:18\\ntest set: Test Failed at /tmp/tmplhj5z4ra.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmplhj5z4ra.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplhj5z4ra.jl:18\\ntest set: Test Failed at /tmp/tmplhj5z4ra.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplhj5z4ra.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplhj5z4ra.jl:18\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     3      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9ljouvjq.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ljouvjq.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ljouvjq.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ljouvjq.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ljouvjq.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ljouvjq.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ljouvjq.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ljouvjq.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ljouvjq.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ljouvjq.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ljouvjq.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ljouvjq.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ljouvjq.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ljouvjq.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ljouvjq.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ljouvjq.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ljouvjq.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ljouvjq.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ljouvjq.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ljouvjq.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp9ljouvjq.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp9ljouvjq.jl:13\n\
    \   [2] top-level scope at /tmp/tmp9ljouvjq.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9ljouvjq.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ljouvjq.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6h5yx1oi.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6h5yx1oi.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6h5yx1oi.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6h5yx1oi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6h5yx1oi.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6h5yx1oi.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6h5yx1oi.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6h5yx1oi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6h5yx1oi.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6h5yx1oi.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6h5yx1oi.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6h5yx1oi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6h5yx1oi.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6h5yx1oi.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6h5yx1oi.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6h5yx1oi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6h5yx1oi.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6h5yx1oi.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6h5yx1oi.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6h5yx1oi.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6h5yx1oi.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6h5yx1oi.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6h5yx1oi.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6h5yx1oi.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6h5yx1oi.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3bj092r_.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3bj092r_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3bj092r_.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3bj092r_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3bj092r_.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3bj092r_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3bj092r_.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3bj092r_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3bj092r_.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3bj092r_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3bj092r_.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3bj092r_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3bj092r_.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3bj092r_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3bj092r_.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3bj092r_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3bj092r_.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3bj092r_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3bj092r_.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3bj092r_.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3bj092r_.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3bj092r_.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3bj092r_.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3bj092r_.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3bj092r_.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8f0rjocz.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp8f0rjocz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp8f0rjocz.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8f0rjocz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp8f0rjocz.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp8f0rjocz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp8f0rjocz.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8f0rjocz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp8f0rjocz.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp8f0rjocz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp8f0rjocz.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8f0rjocz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp8f0rjocz.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp8f0rjocz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp8f0rjocz.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8f0rjocz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp8f0rjocz.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp8f0rjocz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp8f0rjocz.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8f0rjocz.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp8f0rjocz.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp8f0rjocz.jl:13\n\
    \   [2] top-level scope at /tmp/tmp8f0rjocz.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8f0rjocz.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8f0rjocz.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = [sum(digits(n))\
    \ for n in nums]\n    return nums[sortperm(sums)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp43jaj5if.jl:23\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp43jaj5if.jl:23\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp43jaj5if.jl:22\\ntest set: Test Failed at /tmp/tmp43jaj5if.jl:26\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp43jaj5if.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp43jaj5if.jl:22\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3quk70ba.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3quk70ba.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3quk70ba.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3quk70ba.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3quk70ba.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3quk70ba.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3quk70ba.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3quk70ba.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3quk70ba.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3quk70ba.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3quk70ba.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3quk70ba.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3quk70ba.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3quk70ba.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3quk70ba.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3quk70ba.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3quk70ba.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3quk70ba.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3quk70ba.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3quk70ba.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp3quk70ba.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp3quk70ba.jl:13\n\
    \   [2] top-level scope at /tmp/tmp3quk70ba.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3quk70ba.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3quk70ba.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_mhyrvt6.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp_mhyrvt6.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_mhyrvt6.jl:18\ntest set: Test Failed at /tmp/tmp_mhyrvt6.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_mhyrvt6.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_mhyrvt6.jl:18\ntest set: Test Failed at /tmp/tmp_mhyrvt6.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp_mhyrvt6.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_mhyrvt6.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_mhyrvt6.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnuq43w95.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnuq43w95.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnuq43w95.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnuq43w95.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnuq43w95.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnuq43w95.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnuq43w95.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnuq43w95.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnuq43w95.jl:22\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnuq43w95.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnuq43w95.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnuq43w95.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnuq43w95.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnuq43w95.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnuq43w95.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnuq43w95.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnuq43w95.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnuq43w95.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnuq43w95.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnuq43w95.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpnuq43w95.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpnuq43w95.jl:13\n\
    \   [2] top-level scope at /tmp/tmpnuq43w95.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnuq43w95.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnuq43w95.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfm2oesk0.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfm2oesk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfm2oesk0.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm2oesk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfm2oesk0.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfm2oesk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfm2oesk0.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm2oesk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfm2oesk0.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfm2oesk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfm2oesk0.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm2oesk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfm2oesk0.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfm2oesk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfm2oesk0.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm2oesk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfm2oesk0.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfm2oesk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfm2oesk0.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm2oesk0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpfm2oesk0.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpfm2oesk0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpfm2oesk0.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm2oesk0.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfm2oesk0.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    sums = [sum(digits(x)) for x in nums]\n    return sortperm(sums)[nums]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0c2lzn31.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  BoundsError:\
    \ attempt to access 5-element Array{Int64,1} at index [[1, 11, -1, -11, -12]]\n\
    \  Stacktrace:\n   [1] throw_boundserror(::Array{Int64,1}, ::Tuple{Array{Int64,1}})\
    \ at ./abstractarray.jl:537\n   [2] checkbounds at ./abstractarray.jl:502 [inlined]\n\
    \   [3] _getindex at ./multidimensional.jl:726 [inlined]\n   [4] getindex at ./abstractarray.jl:980\
    \ [inlined]\n   [5] order_by_points(::Array{Int64,1}) at /tmp/tmp0c2lzn31.jl:13\n\
    \   [6] top-level scope at /tmp/tmp0c2lzn31.jl:20\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp0c2lzn31.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp0c2lzn31.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  BoundsError: attempt\
    \ to access 15-element Array{Int64,1} at index [[1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]]\n  Stacktrace:\n   [1] throw_boundserror(::Array{Int64,1},\
    \ ::Tuple{Array{Int64,1}}) at ./abstractarray.jl:537\n   [2] checkbounds at ./abstractarray.jl:502\
    \ [inlined]\n   [3] _getindex at ./multidimensional.jl:726 [inlined]\n   [4] getindex\
    \ at ./abstractarray.jl:980 [inlined]\n   [5] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp0c2lzn31.jl:13\n   [6] top-level scope at /tmp/tmp0c2lzn31.jl:21\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp0c2lzn31.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp0c2lzn31.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  BoundsError:\
    \ attempt to access 8-element Array{Int64,1} at index [[1, -11, -32, 43, 54, -98,\
    \ 2, -3]]\n  Stacktrace:\n   [1] throw_boundserror(::Array{Int64,1}, ::Tuple{Array{Int64,1}})\
    \ at ./abstractarray.jl:537\n   [2] checkbounds at ./abstractarray.jl:502 [inlined]\n\
    \   [3] _getindex at ./multidimensional.jl:726 [inlined]\n   [4] getindex at ./abstractarray.jl:980\
    \ [inlined]\n   [5] order_by_points(::Array{Int64,1}) at /tmp/tmp0c2lzn31.jl:13\n\
    \   [6] top-level scope at /tmp/tmp0c2lzn31.jl:23\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp0c2lzn31.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp0c2lzn31.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  BoundsError: attempt\
    \ to access 7-element Array{Int64,1} at index [[0, 6, 6, -76, -21, 23, 4]]\n \
    \ Stacktrace:\n   [1] throw_boundserror(::Array{Int64,1}, ::Tuple{Array{Int64,1}})\
    \ at ./abstractarray.jl:537\n   [2] checkbounds at ./abstractarray.jl:502 [inlined]\n\
    \   [3] _getindex at ./multidimensional.jl:726 [inlined]\n   [4] getindex at ./abstractarray.jl:980\
    \ [inlined]\n   [5] order_by_points(::Array{Int64,1}) at /tmp/tmp0c2lzn31.jl:13\n\
    \   [6] top-level scope at /tmp/tmp0c2lzn31.jl:25\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp0c2lzn31.jl:19\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      4      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0c2lzn31.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxp1rwotp.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpxp1rwotp.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxp1rwotp.jl:18\ntest set: Test Failed at /tmp/tmpxp1rwotp.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxp1rwotp.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxp1rwotp.jl:18\ntest set: Test Failed at /tmp/tmpxp1rwotp.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpxp1rwotp.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxp1rwotp.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxp1rwotp.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp28foomve.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp28foomve.jl:13\n\
    \   [2] top-level scope at /tmp/tmp28foomve.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp28foomve.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp28foomve.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp28foomve.jl:13\n\
    \   [2] top-level scope at /tmp/tmp28foomve.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp28foomve.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp28foomve.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp28foomve.jl:13\n\
    \   [2] top-level scope at /tmp/tmp28foomve.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp28foomve.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp28foomve.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp28foomve.jl:13\n\
    \   [2] top-level scope at /tmp/tmp28foomve.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp28foomve.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp28foomve.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp28foomve.jl:13\n\
    \   [2] top-level scope at /tmp/tmp28foomve.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp28foomve.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp28foomve.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp28foomve.jl:13\n\
    \   [2] top-level scope at /tmp/tmp28foomve.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp28foomve.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp28foomve.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp05o67rvc.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp05o67rvc.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp05o67rvc.jl:18\ntest set: Test Failed at /tmp/tmp05o67rvc.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp05o67rvc.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp05o67rvc.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp05o67rvc.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4j88wevj.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp4j88wevj.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4j88wevj.jl:18\ntest set: Test Failed at /tmp/tmp4j88wevj.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4j88wevj.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4j88wevj.jl:18\ntest set: Test Failed at /tmp/tmp4j88wevj.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp4j88wevj.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4j88wevj.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4j88wevj.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpfgp3k8os.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfgp3k8os.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfgp3k8os.jl:18\\ntest set: Test Failed at /tmp/tmpfgp3k8os.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpfgp3k8os.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfgp3k8os.jl:18\\ntest set: Test Failed at /tmp/tmpfgp3k8os.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfgp3k8os.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfgp3k8os.jl:18\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnc8oyf0z.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpnc8oyf0z.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnc8oyf0z.jl:18\ntest set: Test Failed at /tmp/tmpnc8oyf0z.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnc8oyf0z.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnc8oyf0z.jl:18\ntest set: Test Failed at /tmp/tmpnc8oyf0z.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpnc8oyf0z.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnc8oyf0z.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnc8oyf0z.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvb3ymmq0.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvb3ymmq0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvb3ymmq0.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvb3ymmq0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvb3ymmq0.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvb3ymmq0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvb3ymmq0.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvb3ymmq0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvb3ymmq0.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvb3ymmq0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvb3ymmq0.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvb3ymmq0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvb3ymmq0.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvb3ymmq0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvb3ymmq0.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvb3ymmq0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvb3ymmq0.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvb3ymmq0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvb3ymmq0.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvb3ymmq0.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpvb3ymmq0.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpvb3ymmq0.jl:13\n\
    \   [2] top-level scope at /tmp/tmpvb3ymmq0.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvb3ymmq0.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvb3ymmq0.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # sort by sum of digits\n    # if sum of digits is equal, sort by index\n\
    \    # if index is equal, sort by value\n    # sort(nums, by=x->(sum(digits(x)),\
    \ findall(nums .== x)[1], x))\n    sort(nums, by=x->(sum(digits(x)), findall(nums\
    \ .== x)[1], x))\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_k6af8w7.jl:23\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_k6af8w7.jl:23\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_k6af8w7.jl:22\\ntest set: Test Failed at /tmp/tmp_k6af8w7.jl:26\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_k6af8w7.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_k6af8w7.jl:22\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2sjbonp5.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2sjbonp5.jl:13\n\
    \   [2] top-level scope at /tmp/tmp2sjbonp5.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2sjbonp5.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2sjbonp5.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2sjbonp5.jl:13\n\
    \   [2] top-level scope at /tmp/tmp2sjbonp5.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2sjbonp5.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2sjbonp5.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2sjbonp5.jl:13\n\
    \   [2] top-level scope at /tmp/tmp2sjbonp5.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2sjbonp5.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2sjbonp5.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2sjbonp5.jl:13\n\
    \   [2] top-level scope at /tmp/tmp2sjbonp5.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2sjbonp5.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2sjbonp5.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2sjbonp5.jl:13\n\
    \   [2] top-level scope at /tmp/tmp2sjbonp5.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2sjbonp5.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp2sjbonp5.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2sjbonp5.jl:13\n\
    \   [2] top-level scope at /tmp/tmp2sjbonp5.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2sjbonp5.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2sjbonp5.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3tda6bhj.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp3tda6bhj.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3tda6bhj.jl:18\ntest set: Test Failed at /tmp/tmp3tda6bhj.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3tda6bhj.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3tda6bhj.jl:18\ntest set: Test Failed at /tmp/tmp3tda6bhj.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp3tda6bhj.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3tda6bhj.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3tda6bhj.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2epnzb89.jl:19\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2epnzb89.jl:13\\\
    n   [2] top-level scope at /tmp/tmp2epnzb89.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2epnzb89.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2epnzb89.jl:20\\n  Test threw exception\\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2epnzb89.jl:13\\\
    n   [2] top-level scope at /tmp/tmp2epnzb89.jl:20\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2epnzb89.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2epnzb89.jl:21\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2epnzb89.jl:13\\\
    n   [2] top-level scope at /tmp/tmp2epnzb89.jl:21\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2epnzb89.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2epnzb89.jl:22\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2epnzb89.jl:13\\\
    n   [2] top-level scope at /tmp/tmp2epnzb89.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2epnzb89.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2epnzb89.jl:23\\n  Test threw exception\\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2epnzb89.jl:13\\\
    n   [2] top-level scope at /tmp/tmp2epnzb89.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2epnzb89.jl:18\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2epnzb89.jl:24\\n  Test threw exception\\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp2epnzb89.jl:13\\\
    n   [2] top-level scope at /tmp/tmp2epnzb89.jl:24\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2epnzb89.jl:18\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsnwvxvbk.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsnwvxvbk.jl:13\n\
    \   [2] top-level scope at /tmp/tmpsnwvxvbk.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsnwvxvbk.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpsnwvxvbk.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsnwvxvbk.jl:13\n\
    \   [2] top-level scope at /tmp/tmpsnwvxvbk.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsnwvxvbk.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpsnwvxvbk.jl:22\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsnwvxvbk.jl:13\n\
    \   [2] top-level scope at /tmp/tmpsnwvxvbk.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsnwvxvbk.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpsnwvxvbk.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsnwvxvbk.jl:13\n\
    \   [2] top-level scope at /tmp/tmpsnwvxvbk.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsnwvxvbk.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpsnwvxvbk.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsnwvxvbk.jl:13\n\
    \   [2] top-level scope at /tmp/tmpsnwvxvbk.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsnwvxvbk.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpsnwvxvbk.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpsnwvxvbk.jl:13\n\
    \   [2] top-level scope at /tmp/tmpsnwvxvbk.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsnwvxvbk.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsnwvxvbk.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return []\n    end\n    sums = [sum(digits(x))\
    \ for x in nums]\n    return sortperm(sums)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1,\
    \ -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53,\
    \ 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37,\
    \ 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi7j3dwg8.jl:23\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [5, 4, 3, 1, 2] ==\
    \ [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpi7j3dwg8.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi7j3dwg8.jl:22\ntest set: Test Failed at /tmp/tmpi7j3dwg8.jl:24\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [14, 5, 12, 9, 8, 2, 6, 7, 1, 4, 10, 15, 13, 3, 11] == [0, 2, 3,\
    \ 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpi7j3dwg8.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi7j3dwg8.jl:22\ntest set: Test Failed at /tmp/tmpi7j3dwg8.jl:26\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [6, 3, 8, 2, 1, 7, 4, 5] == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpi7j3dwg8.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi7j3dwg8.jl:22\ntest set: Test Failed at /tmp/tmpi7j3dwg8.jl:28\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [4, 5, 1, 7, 6, 2, 3] == [-76, -21, 0, 4, 23, 6, 6]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi7j3dwg8.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi7j3dwg8.jl:22\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     4      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi7j3dwg8.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcsu1l96t.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcsu1l96t.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcsu1l96t.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcsu1l96t.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcsu1l96t.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcsu1l96t.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcsu1l96t.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcsu1l96t.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcsu1l96t.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcsu1l96t.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcsu1l96t.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcsu1l96t.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcsu1l96t.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcsu1l96t.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcsu1l96t.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcsu1l96t.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcsu1l96t.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcsu1l96t.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcsu1l96t.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcsu1l96t.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpcsu1l96t.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpcsu1l96t.jl:13\n\
    \   [2] top-level scope at /tmp/tmpcsu1l96t.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcsu1l96t.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcsu1l96t.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq6x07ija.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpq6x07ija.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq6x07ija.jl:18\ntest set: Test Failed at /tmp/tmpq6x07ija.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq6x07ija.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq6x07ija.jl:18\ntest set: Test Failed at /tmp/tmpq6x07ija.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpq6x07ija.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq6x07ija.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq6x07ija.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiltajyx_.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpiltajyx_.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiltajyx_.jl:18\ntest set: Test Failed at /tmp/tmpiltajyx_.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiltajyx_.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiltajyx_.jl:18\ntest set: Test Failed at /tmp/tmpiltajyx_.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpiltajyx_.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiltajyx_.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiltajyx_.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    nums_with_points = [(n, sum(digits(n))) for n in nums]\n    sorted_nums_with_points\
    \ = sort(nums_with_points, by=x -> x[2])\n    return [n for (n, _) in sorted_nums_with_points]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmphqe6wr81.jl:21\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(nums)\n        return nums\n    end\n    # sort by sum of digits\n\
    \    sorted_nums = sort(nums, by=x->sum(digits(x)))\n    # sort by index\n   \
    \ return sort(sorted_nums, by=x->findfirst(nums, x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9wudop7u.jl:25\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ no method matching findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates\
    \ are:\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\n\
    \    findfirst(!Matched::Function, ::Any) at array.jl:1776\n    findfirst(::Any)\
    \ at array.jl:1692\n  Stacktrace:\n   [1] (::var\"#4#6\"{Array{Int64,1}})(::Int64)\
    \ at /tmp/tmp9wudop7u.jl:18\n   [2] lt(::Base.Order.By{var\"#4#6\"{Array{Int64,1}}},\
    \ ::Int64, ::Int64) at ./ordering.jl:52\n   [3] sort! at ./sort.jl:480 [inlined]\n\
    \   [4] sort! at ./sort.jl:547 [inlined]\n   [5] sort! at ./sort.jl:655 [inlined]\n\
    \   [6] #sort!#7 at ./sort.jl:715 [inlined]\n   [7] sort(::Array{Int64,1}; kws::Base.Iterators.Pairs{Symbol,var\"\
    #4#6\"{Array{Int64,1}},Tuple{Symbol},NamedTuple{(:by,),Tuple{var\"#4#6\"{Array{Int64,1}}}}})\
    \ at ./sort.jl:763\n   [8] order_by_points(::Array{Int64,1}) at /tmp/tmp9wudop7u.jl:18\n\
    \   [9] top-level scope at /tmp/tmp9wudop7u.jl:25\n   [10] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmp9wudop7u.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp9wudop7u.jl:26\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: no method\
    \ matching findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n \
    \   findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n\
    \   [1] (::var\"#4#6\"{Array{Int64,1}})(::Int64) at /tmp/tmp9wudop7u.jl:18\n \
    \  [2] lt(::Base.Order.By{var\"#4#6\"{Array{Int64,1}}}, ::Int64, ::Int64) at ./ordering.jl:52\n\
    \   [3] sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort! at ./sort.jl:655 [inlined]\n   [6] #sort!#7 at ./sort.jl:715 [inlined]\n\
    \   [7] sort(::Array{Int64,1}; kws::Base.Iterators.Pairs{Symbol,var\"#4#6\"{Array{Int64,1}},Tuple{Symbol},NamedTuple{(:by,),Tuple{var\"\
    #4#6\"{Array{Int64,1}}}}}) at ./sort.jl:763\n   [8] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp9wudop7u.jl:18\n   [9] top-level scope at /tmp/tmp9wudop7u.jl:26\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmp9wudop7u.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp9wudop7u.jl:28\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ no method matching findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates\
    \ are:\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\n\
    \    findfirst(!Matched::Function, ::Any) at array.jl:1776\n    findfirst(::Any)\
    \ at array.jl:1692\n  Stacktrace:\n   [1] (::var\"#4#6\"{Array{Int64,1}})(::Int64)\
    \ at /tmp/tmp9wudop7u.jl:18\n   [2] lt(::Base.Order.By{var\"#4#6\"{Array{Int64,1}}},\
    \ ::Int64, ::Int64) at ./ordering.jl:52\n   [3] sort! at ./sort.jl:480 [inlined]\n\
    \   [4] sort! at ./sort.jl:547 [inlined]\n   [5] sort! at ./sort.jl:655 [inlined]\n\
    \   [6] #sort!#7 at ./sort.jl:715 [inlined]\n   [7] sort(::Array{Int64,1}; kws::Base.Iterators.Pairs{Symbol,var\"\
    #4#6\"{Array{Int64,1}},Tuple{Symbol},NamedTuple{(:by,),Tuple{var\"#4#6\"{Array{Int64,1}}}}})\
    \ at ./sort.jl:763\n   [8] order_by_points(::Array{Int64,1}) at /tmp/tmp9wudop7u.jl:18\n\
    \   [9] top-level scope at /tmp/tmp9wudop7u.jl:28\n   [10] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmp9wudop7u.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp9wudop7u.jl:29\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ no method matching findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates\
    \ are:\n    findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\n\
    \    findfirst(!Matched::Function, ::Any) at array.jl:1776\n    findfirst(::Any)\
    \ at array.jl:1692\n  Stacktrace:\n   [1] (::var\"#4#6\"{Array{Int64,1}})(::Int64)\
    \ at /tmp/tmp9wudop7u.jl:18\n   [2] lt(::Base.Order.By{var\"#4#6\"{Array{Int64,1}}},\
    \ ::Int64, ::Int64) at ./ordering.jl:52\n   [3] sort! at ./sort.jl:480 [inlined]\n\
    \   [4] sort! at ./sort.jl:547 [inlined]\n   [5] sort! at ./sort.jl:655 [inlined]\n\
    \   [6] #sort!#7 at ./sort.jl:715 [inlined]\n   [7] sort(::Array{Int64,1}; kws::Base.Iterators.Pairs{Symbol,var\"\
    #4#6\"{Array{Int64,1}},Tuple{Symbol},NamedTuple{(:by,),Tuple{var\"#4#6\"{Array{Int64,1}}}}})\
    \ at ./sort.jl:763\n   [8] order_by_points(::Array{Int64,1}) at /tmp/tmp9wudop7u.jl:18\n\
    \   [9] top-level scope at /tmp/tmp9wudop7u.jl:29\n   [10] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmp9wudop7u.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp9wudop7u.jl:30\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: no method\
    \ matching findfirst(::Array{Int64,1}, ::Int64)\n  Closest candidates are:\n \
    \   findfirst(::Union{AbstractString, AbstractArray}) at array.jl:1701\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1776\n    findfirst(::Any) at array.jl:1692\n  Stacktrace:\n\
    \   [1] (::var\"#4#6\"{Array{Int64,1}})(::Int64) at /tmp/tmp9wudop7u.jl:18\n \
    \  [2] lt(::Base.Order.By{var\"#4#6\"{Array{Int64,1}}}, ::Int64, ::Int64) at ./ordering.jl:52\n\
    \   [3] sort! at ./sort.jl:480 [inlined]\n   [4] sort! at ./sort.jl:547 [inlined]\n\
    \   [5] sort! at ./sort.jl:655 [inlined]\n   [6] #sort!#7 at ./sort.jl:715 [inlined]\n\
    \   [7] sort(::Array{Int64,1}; kws::Base.Iterators.Pairs{Symbol,var\"#4#6\"{Array{Int64,1}},Tuple{Symbol},NamedTuple{(:by,),Tuple{var\"\
    #4#6\"{Array{Int64,1}}}}}) at ./sort.jl:763\n   [8] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp9wudop7u.jl:18\n   [9] top-level scope at /tmp/tmp9wudop7u.jl:30\n\
    \   [10] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [11] top-level scope at /tmp/tmp9wudop7u.jl:24\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9wudop7u.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return []\n    end\n    nums_with_sum =\
    \ [sum(digits(nums[i])) for i in 1:length(nums)]\n    nums_with_sum_and_index\
    \ = [(nums_with_sum[i], i) for i in 1:length(nums)]\n    nums_with_sum_and_index_sorted\
    \ = sort(nums_with_sum_and_index, by = x -> x[1])\n    nums_sorted = [nums[nums_with_sum_and_index_sorted[i][2]]\
    \ for i in 1:length(nums)]\n    return nums_sorted\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpdoah6sii.jl:26\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdoah6sii.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdoah6sii.jl:25\\ntest set: Test Failed at /tmp/tmpdoah6sii.jl:29\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpdoah6sii.jl:29\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdoah6sii.jl:25\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     2      6\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return nums\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1,\
    \ -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53,\
    \ 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37,\
    \ 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp7_qm5_kh.jl:20\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [1, 11, -1, -11,\
    \ -12] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7_qm5_kh.jl:20\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7_qm5_kh.jl:19\\ntest set: Test Failed at /tmp/tmp7_qm5_kh.jl:21\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp7_qm5_kh.jl:21\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7_qm5_kh.jl:19\\ntest set: Test Failed at /tmp/tmp7_qm5_kh.jl:23\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [1, -11, -32, 43, 54, -98, 2, -3] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7_qm5_kh.jl:23\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7_qm5_kh.jl:19\\ntest set: Test Failed at /tmp/tmp7_qm5_kh.jl:24\\\
    n  Expression: candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11,\
    \ 3, 4, 5, 6, 7, 8, 9]\\n   Evaluated: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] ==\
    \ [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmp7_qm5_kh.jl:24\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7_qm5_kh.jl:19\\ntest set: Test Failed at /tmp/tmp7_qm5_kh.jl:25\\\
    n  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\\n   Evaluated: [0, 6, 6, -76, -21, 23, 4] == [-76, -21, 0, 4, 23, 6, 6]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp7_qm5_kh.jl:25\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7_qm5_kh.jl:19\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpuq3mx_3i.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpuq3mx_3i.jl:13\n\
    \   [2] top-level scope at /tmp/tmpuq3mx_3i.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuq3mx_3i.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpuq3mx_3i.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpuq3mx_3i.jl:13\n\
    \   [2] top-level scope at /tmp/tmpuq3mx_3i.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuq3mx_3i.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpuq3mx_3i.jl:22\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpuq3mx_3i.jl:13\n\
    \   [2] top-level scope at /tmp/tmpuq3mx_3i.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuq3mx_3i.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpuq3mx_3i.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpuq3mx_3i.jl:13\n\
    \   [2] top-level scope at /tmp/tmpuq3mx_3i.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuq3mx_3i.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpuq3mx_3i.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpuq3mx_3i.jl:13\n\
    \   [2] top-level scope at /tmp/tmpuq3mx_3i.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuq3mx_3i.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpuq3mx_3i.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpuq3mx_3i.jl:13\n\
    \   [2] top-level scope at /tmp/tmpuq3mx_3i.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpuq3mx_3i.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuq3mx_3i.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4ndypqdo.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp4ndypqdo.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ndypqdo.jl:18\ntest set: Test Failed at /tmp/tmp4ndypqdo.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4ndypqdo.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ndypqdo.jl:18\ntest set: Test Failed at /tmp/tmp4ndypqdo.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp4ndypqdo.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ndypqdo.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4ndypqdo.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4letkpj5.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp4letkpj5.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4letkpj5.jl:18\ntest set: Test Failed at /tmp/tmp4letkpj5.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4letkpj5.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4letkpj5.jl:18\ntest set: Test Failed at /tmp/tmp4letkpj5.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp4letkpj5.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4letkpj5.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4letkpj5.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4u37prao.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp4u37prao.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4u37prao.jl:18\ntest set: Test Failed at /tmp/tmp4u37prao.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp4u37prao.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4u37prao.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4u37prao.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplmerbin_.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmplmerbin_.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplmerbin_.jl:18\ntest set: Test Failed at /tmp/tmplmerbin_.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmplmerbin_.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplmerbin_.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplmerbin_.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdo07cctl.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpdo07cctl.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdo07cctl.jl:18\ntest set: Test Failed at /tmp/tmpdo07cctl.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdo07cctl.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdo07cctl.jl:18\ntest set: Test Failed at /tmp/tmpdo07cctl.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpdo07cctl.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdo07cctl.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdo07cctl.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = [sum(digits(abs(i)))\
    \ for i in nums]\n    return sortperm(sums)[nums]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp43cjslsj.jl:23\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  BoundsError:\
    \ attempt to access 5-element Array{Int64,1} at index [[1, 11, -1, -11, -12]]\n\
    \  Stacktrace:\n   [1] throw_boundserror(::Array{Int64,1}, ::Tuple{Array{Int64,1}})\
    \ at ./abstractarray.jl:537\n   [2] checkbounds at ./abstractarray.jl:502 [inlined]\n\
    \   [3] _getindex at ./multidimensional.jl:726 [inlined]\n   [4] getindex at ./abstractarray.jl:980\
    \ [inlined]\n   [5] order_by_points(::Array{Int64,1}) at /tmp/tmp43cjslsj.jl:16\n\
    \   [6] top-level scope at /tmp/tmp43cjslsj.jl:23\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp43cjslsj.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmp43cjslsj.jl:24\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  BoundsError: attempt\
    \ to access 15-element Array{Int64,1} at index [[1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]]\n  Stacktrace:\n   [1] throw_boundserror(::Array{Int64,1},\
    \ ::Tuple{Array{Int64,1}}) at ./abstractarray.jl:537\n   [2] checkbounds at ./abstractarray.jl:502\
    \ [inlined]\n   [3] _getindex at ./multidimensional.jl:726 [inlined]\n   [4] getindex\
    \ at ./abstractarray.jl:980 [inlined]\n   [5] order_by_points(::Array{Int64,1})\
    \ at /tmp/tmp43cjslsj.jl:16\n   [6] top-level scope at /tmp/tmp43cjslsj.jl:24\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp43cjslsj.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmp43cjslsj.jl:26\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  BoundsError:\
    \ attempt to access 8-element Array{Int64,1} at index [[1, -11, -32, 43, 54, -98,\
    \ 2, -3]]\n  Stacktrace:\n   [1] throw_boundserror(::Array{Int64,1}, ::Tuple{Array{Int64,1}})\
    \ at ./abstractarray.jl:537\n   [2] checkbounds at ./abstractarray.jl:502 [inlined]\n\
    \   [3] _getindex at ./multidimensional.jl:726 [inlined]\n   [4] getindex at ./abstractarray.jl:980\
    \ [inlined]\n   [5] order_by_points(::Array{Int64,1}) at /tmp/tmp43cjslsj.jl:16\n\
    \   [6] top-level scope at /tmp/tmp43cjslsj.jl:26\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp43cjslsj.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmp43cjslsj.jl:28\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  BoundsError: attempt\
    \ to access 7-element Array{Int64,1} at index [[0, 6, 6, -76, -21, 23, 4]]\n \
    \ Stacktrace:\n   [1] throw_boundserror(::Array{Int64,1}, ::Tuple{Array{Int64,1}})\
    \ at ./abstractarray.jl:537\n   [2] checkbounds at ./abstractarray.jl:502 [inlined]\n\
    \   [3] _getindex at ./multidimensional.jl:726 [inlined]\n   [4] getindex at ./abstractarray.jl:980\
    \ [inlined]\n   [5] order_by_points(::Array{Int64,1}) at /tmp/tmp43cjslsj.jl:16\n\
    \   [6] top-level scope at /tmp/tmp43cjslsj.jl:28\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp43cjslsj.jl:22\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      4      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp43cjslsj.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    nums_with_points\
    \ = [(nums[i], sum(digits(nums[i])), i) for i in 1:length(nums)]\n    sorted_nums_with_points\
    \ = sort(nums_with_points, by = x -> (x[2], x[3]))\n    return [x[1] for x in\
    \ sorted_nums_with_points]\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpetz4otp7.jl:24\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpetz4otp7.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpetz4otp7.jl:23\ntest set: Test Failed at /tmp/tmpetz4otp7.jl:27\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpetz4otp7.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpetz4otp7.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpetz4otp7.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpz2dt4erz.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpz2dt4erz.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpz2dt4erz.jl:18\\ntest set: Test Failed at /tmp/tmpz2dt4erz.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpz2dt4erz.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpz2dt4erz.jl:18\\nTest Summary: | Pass  Fail \
    \ '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdrlrkg_f.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdrlrkg_f.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdrlrkg_f.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdrlrkg_f.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdrlrkg_f.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdrlrkg_f.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdrlrkg_f.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdrlrkg_f.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdrlrkg_f.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdrlrkg_f.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdrlrkg_f.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdrlrkg_f.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdrlrkg_f.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdrlrkg_f.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdrlrkg_f.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdrlrkg_f.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdrlrkg_f.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdrlrkg_f.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdrlrkg_f.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdrlrkg_f.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpdrlrkg_f.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpdrlrkg_f.jl:13\n\
    \   [2] top-level scope at /tmp/tmpdrlrkg_f.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdrlrkg_f.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdrlrkg_f.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6cg2inja.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6cg2inja.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6cg2inja.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6cg2inja.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6cg2inja.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6cg2inja.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6cg2inja.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6cg2inja.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6cg2inja.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6cg2inja.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6cg2inja.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6cg2inja.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6cg2inja.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6cg2inja.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6cg2inja.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6cg2inja.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6cg2inja.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6cg2inja.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6cg2inja.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6cg2inja.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp6cg2inja.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6cg2inja.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6cg2inja.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6cg2inja.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6cg2inja.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphum2i6a4.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmphum2i6a4.jl:13\n\
    \   [2] top-level scope at /tmp/tmphum2i6a4.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphum2i6a4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphum2i6a4.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmphum2i6a4.jl:13\n\
    \   [2] top-level scope at /tmp/tmphum2i6a4.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphum2i6a4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphum2i6a4.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmphum2i6a4.jl:13\n\
    \   [2] top-level scope at /tmp/tmphum2i6a4.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphum2i6a4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphum2i6a4.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmphum2i6a4.jl:13\n\
    \   [2] top-level scope at /tmp/tmphum2i6a4.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphum2i6a4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphum2i6a4.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmphum2i6a4.jl:13\n\
    \   [2] top-level scope at /tmp/tmphum2i6a4.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphum2i6a4.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmphum2i6a4.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmphum2i6a4.jl:13\n\
    \   [2] top-level scope at /tmp/tmphum2i6a4.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphum2i6a4.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphum2i6a4.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwf2guhrm.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwf2guhrm.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwf2guhrm.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwf2guhrm.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwf2guhrm.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwf2guhrm.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwf2guhrm.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwf2guhrm.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwf2guhrm.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwf2guhrm.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwf2guhrm.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwf2guhrm.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwf2guhrm.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwf2guhrm.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwf2guhrm.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwf2guhrm.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwf2guhrm.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwf2guhrm.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwf2guhrm.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwf2guhrm.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpwf2guhrm.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpwf2guhrm.jl:13\n\
    \   [2] top-level scope at /tmp/tmpwf2guhrm.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwf2guhrm.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwf2guhrm.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6qk6f8p6.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp6qk6f8p6.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6qk6f8p6.jl:18\ntest set: Test Failed at /tmp/tmp6qk6f8p6.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6qk6f8p6.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6qk6f8p6.jl:18\ntest set: Test Failed at /tmp/tmp6qk6f8p6.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp6qk6f8p6.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6qk6f8p6.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6qk6f8p6.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    nums_with_points\
    \ = [(nums[i], sum(digits(nums[i])), i) for i in 1:length(nums)]\n    sorted_nums_with_points\
    \ = sort(nums_with_points, by = x -> (x[2], x[3]))\n    return [x[1] for x in\
    \ sorted_nums_with_points]\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxvt12ftb.jl:24\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpxvt12ftb.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxvt12ftb.jl:23\ntest set: Test Failed at /tmp/tmpxvt12ftb.jl:27\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpxvt12ftb.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxvt12ftb.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxvt12ftb.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp0xg2h5vv.jl:19\\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp0xg2h5vv.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0xg2h5vv.jl:18\\ntest set: Test Failed at /tmp/tmp0xg2h5vv.jl:20\\\
    n  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\\
    n   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp0xg2h5vv.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0xg2h5vv.jl:18\\ntest set: Test Failed at /tmp/tmp0xg2h5vv.jl:22\\\
    n  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp0xg2h5vv.jl:22\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0xg2h5vv.jl:18\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxcla7igl.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxcla7igl.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxcla7igl.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxcla7igl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxcla7igl.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxcla7igl.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxcla7igl.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxcla7igl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxcla7igl.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxcla7igl.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxcla7igl.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxcla7igl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxcla7igl.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxcla7igl.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxcla7igl.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxcla7igl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxcla7igl.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxcla7igl.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxcla7igl.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxcla7igl.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpxcla7igl.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxcla7igl.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxcla7igl.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxcla7igl.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxcla7igl.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb0o5o2lu.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpb0o5o2lu.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0o5o2lu.jl:18\ntest set: Test Failed at /tmp/tmpb0o5o2lu.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpb0o5o2lu.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0o5o2lu.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb0o5o2lu.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxszjuv8q.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxszjuv8q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxszjuv8q.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxszjuv8q.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpxszjuv8q.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxszjuv8q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxszjuv8q.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxszjuv8q.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpxszjuv8q.jl:22\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxszjuv8q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxszjuv8q.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxszjuv8q.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpxszjuv8q.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxszjuv8q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxszjuv8q.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxszjuv8q.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpxszjuv8q.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxszjuv8q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxszjuv8q.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxszjuv8q.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpxszjuv8q.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmpxszjuv8q.jl:13\n\
    \   [2] top-level scope at /tmp/tmpxszjuv8q.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxszjuv8q.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxszjuv8q.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4_jsve2j.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp4_jsve2j.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4_jsve2j.jl:18\ntest set: Test Failed at /tmp/tmp4_jsve2j.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4_jsve2j.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4_jsve2j.jl:18\ntest set: Test Failed at /tmp/tmp4_jsve2j.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp4_jsve2j.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4_jsve2j.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4_jsve2j.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_pjg157k.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_pjg157k.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_pjg157k.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_pjg157k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_pjg157k.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_pjg157k.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_pjg157k.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_pjg157k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_pjg157k.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_pjg157k.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_pjg157k.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_pjg157k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_pjg157k.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_pjg157k.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_pjg157k.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_pjg157k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_pjg157k.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_pjg157k.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_pjg157k.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_pjg157k.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_pjg157k.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_pjg157k.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_pjg157k.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_pjg157k.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_pjg157k.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> sum(digits(x)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv3f2oo8v.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpv3f2oo8v.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv3f2oo8v.jl:18\ntest set: Test Failed at /tmp/tmpv3f2oo8v.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpv3f2oo8v.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv3f2oo8v.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv3f2oo8v.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplqhviu45.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmplqhviu45.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplqhviu45.jl:18\ntest set: Test Failed at /tmp/tmplqhviu45.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplqhviu45.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplqhviu45.jl:18\ntest set: Test Failed at /tmp/tmplqhviu45.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmplqhviu45.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplqhviu45.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplqhviu45.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpphd3ij4x.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpphd3ij4x.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpphd3ij4x.jl:18\ntest set: Test Failed at /tmp/tmpphd3ij4x.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpphd3ij4x.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpphd3ij4x.jl:18\ntest set: Test Failed at /tmp/tmpphd3ij4x.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpphd3ij4x.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpphd3ij4x.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpphd3ij4x.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by = x -> (sum(digits(x)), x))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0sw7xc1d.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp0sw7xc1d.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0sw7xc1d.jl:18\ntest set: Test Failed at /tmp/tmp0sw7xc1d.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0sw7xc1d.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0sw7xc1d.jl:18\ntest set: Test Failed at /tmp/tmp0sw7xc1d.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp0sw7xc1d.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0sw7xc1d.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0sw7xc1d.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: implement your solution here\n    return nums\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwax_pxa7.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [1, 11, -1, -11,\
    \ -12] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpwax_pxa7.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwax_pxa7.jl:19\ntest set: Test Failed at /tmp/tmpwax_pxa7.jl:21\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwax_pxa7.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwax_pxa7.jl:19\ntest set: Test Failed at /tmp/tmpwax_pxa7.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [1, -11, -32, 43, 54, -98, 2, -3] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpwax_pxa7.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwax_pxa7.jl:19\ntest set: Test Failed at /tmp/tmpwax_pxa7.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11,\
    \ 3, 4, 5, 6, 7, 8, 9]\n   Evaluated: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] == [1,\
    \ 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nStacktrace:\n [1] top-level scope at /tmp/tmpwax_pxa7.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwax_pxa7.jl:19\ntest set: Test Failed at /tmp/tmpwax_pxa7.jl:25\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [0, 6, 6, -76, -21, 23, 4] == [-76, -21, 0, 4, 23, 6, 6]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwax_pxa7.jl:25\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwax_pxa7.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwax_pxa7.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    sums = zeros(Int64,\
    \ length(nums))\n    for i in 1:length(nums)\n        sums[i] = sum(digits(nums[i]))\n\
    \    end\n    return nums[sortperm(sums)]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1,\
    \ -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53,\
    \ 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37,\
    \ 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp91mzydoc.jl:26\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmp91mzydoc.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp91mzydoc.jl:25\ntest set: Test Failed at /tmp/tmp91mzydoc.jl:29\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmp91mzydoc.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp91mzydoc.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp91mzydoc.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6salnnms.jl:20\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6salnnms.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6salnnms.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6salnnms.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp6salnnms.jl:21\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6salnnms.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6salnnms.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6salnnms.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp6salnnms.jl:22\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6salnnms.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6salnnms.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6salnnms.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp6salnnms.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6salnnms.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6salnnms.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6salnnms.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp6salnnms.jl:24\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6salnnms.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6salnnms.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6salnnms.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmp6salnnms.jl:25\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp6salnnms.jl:13\n\
    \   [2] top-level scope at /tmp/tmp6salnnms.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6salnnms.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6salnnms.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), findall(nums .== x)[1]))\nend\n\
    using Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423,\
    \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw5f4cdlq.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpw5f4cdlq.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw5f4cdlq.jl:18\ntest set: Test Failed at /tmp/tmpw5f4cdlq.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpw5f4cdlq.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw5f4cdlq.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw5f4cdlq.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: implement this function\n    return nums\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145,\
    \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
    \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgiai7bb1.jl:20\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [1, 11, -1, -11,\
    \ -12] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpgiai7bb1.jl:20\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgiai7bb1.jl:19\ntest set: Test Failed at /tmp/tmpgiai7bb1.jl:21\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgiai7bb1.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgiai7bb1.jl:19\ntest set: Test Failed at /tmp/tmpgiai7bb1.jl:23\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [1, -11, -32, 43, 54, -98, 2, -3] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpgiai7bb1.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgiai7bb1.jl:19\ntest set: Test Failed at /tmp/tmpgiai7bb1.jl:24\n\
    \  Expression: candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11,\
    \ 3, 4, 5, 6, 7, 8, 9]\n   Evaluated: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] == [1,\
    \ 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nStacktrace:\n [1] top-level scope at /tmp/tmpgiai7bb1.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgiai7bb1.jl:19\ntest set: Test Failed at /tmp/tmpgiai7bb1.jl:25\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [0, 6, 6, -76, -21, 23, 4] == [-76, -21, 0, 4, 23, 6, 6]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgiai7bb1.jl:25\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgiai7bb1.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgiai7bb1.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = order_by_points;\n\
    \t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3])\
    \ == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_uzvt6al.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_uzvt6al.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_uzvt6al.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_uzvt6al.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_uzvt6al.jl:20\n  Test threw exception\n  Expression: candidate([1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_uzvt6al.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_uzvt6al.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_uzvt6al.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_uzvt6al.jl:21\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_uzvt6al.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_uzvt6al.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_uzvt6al.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_uzvt6al.jl:22\n  Test threw exception\n  Expression: candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_uzvt6al.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_uzvt6al.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_uzvt6al.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_uzvt6al.jl:23\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_uzvt6al.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_uzvt6al.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_uzvt6al.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmp_uzvt6al.jl:24\n  Test threw exception\n  Expression: candidate([0,\
    \ 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] order_by_points(::Array{Int64,1}) at /tmp/tmp_uzvt6al.jl:13\n\
    \   [2] top-level scope at /tmp/tmp_uzvt6al.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_uzvt6al.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_uzvt6al.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return []\n    end\n    return sort(nums,\
    \ by=x->(x, sum(digits(x))))\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t\
    @test(candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprp17drmn.jl:22\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmprp17drmn.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprp17drmn.jl:21\ntest set: Test Failed at /tmp/tmprp17drmn.jl:23\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 37, 46, 53, 56, 145, 423, 423, 423, 463, 1234, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprp17drmn.jl:23\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprp17drmn.jl:21\ntest set: Test Failed at /tmp/tmprp17drmn.jl:25\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -11, -3, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmprp17drmn.jl:25\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprp17drmn.jl:21\ntest set: Test Failed at /tmp/tmprp17drmn.jl:26\n\
    \  Expression: candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11,\
    \ 3, 4, 5, 6, 7, 8, 9]\n   Evaluated: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] == [1,\
    \ 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\nStacktrace:\n [1] top-level scope at /tmp/tmprp17drmn.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprp17drmn.jl:21\ntest set: Test Failed at /tmp/tmprp17drmn.jl:27\n\
    \  Expression: candidate([0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6,\
    \ 6]\n   Evaluated: [-76, -21, 0, 4, 6, 6, 23] == [-76, -21, 0, 4, 23, 6, 6]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmprp17drmn.jl:27\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprp17drmn.jl:21\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprp17drmn.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(nums, by=x->(sum(digits(x)), x))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplvrw6g2b.jl:19\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmplvrw6g2b.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplvrw6g2b.jl:18\ntest set: Test Failed at /tmp/tmplvrw6g2b.jl:20\n\
    \  Expression: candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3,\
    \ 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n\
    \   Evaluated: [0, 2, 3, 6, 53, 423, 423, 423, 37, 46, 145, 1234, 56, 463, 3457]\
    \ == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplvrw6g2b.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplvrw6g2b.jl:18\ntest set: Test Failed at /tmp/tmplvrw6g2b.jl:22\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmplvrw6g2b.jl:22\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplvrw6g2b.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     3      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplvrw6g2b.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Write a function which sorts the given list of integers\n\
    \    in ascending order according to the sum of their digits.\n    Note: if there\
    \ are several items with similar sum of their digits,\n    order them based on\
    \ their index in original list.\n\n    For example:\n    >>> order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) ==\
    \ []\n    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64}\
    \ \n    if length(nums) == 0\n        return nums\n    end\n    nums_with_points\
    \ = []\n    for i in 1:length(nums)\n        push!(nums_with_points, (nums[i],\
    \ sum(digits(nums[i]))))\n    end\n    sort!(nums_with_points, by = x -> x[2])\n\
    \    return [x[1] for x in nums_with_points]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = order_by_points;\n\t@test(candidate([1, 11, -1, -11, -12]) == [-1,\
    \ -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463, 145, 2, 423, 423, 53,\
    \ 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37,\
    \ 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1,\
    \ 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10,\
    \ 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6, 6, -76, -21, 23, 4])\
    \ == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx1brurxw.jl:27\n  Expression: candidate([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n   Evaluated: [-12, -11, -1, 1,\
    \ 11] == [-1, -11, 1, -12, 11]\nStacktrace:\n [1] top-level scope at /tmp/tmpx1brurxw.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx1brurxw.jl:26\ntest set: Test Failed at /tmp/tmpx1brurxw.jl:30\n\
    \  Expression: candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54]\n   Evaluated: [-98, -32, -3, -11, 1, 2, 43, 54] == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54]\nStacktrace:\n [1] top-level scope at /tmp/tmpx1brurxw.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx1brurxw.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     2      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx1brurxw.jl:24\n"
  exit_code: 1
  status: SyntaxError
