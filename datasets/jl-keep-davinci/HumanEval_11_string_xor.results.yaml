name: HumanEval_11_string_xor
language: julia
results:
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    # convert strings to arrays of integers\n    a = [parse(Int,\
    \ i) for i in a]\n    b = [parse(Int, i) for i in b]\n    # perform XOR\n    c\
    \ = xor(a, b)\n    # convert back to string\n    c = [string(i) for i in c]\n\
    \    return join(c)\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\
    \t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"\
    1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpmenw1f4e.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate(\"111000\", \"101010\") == \"010010\"\\\
    n  MethodError: no method matching xor(::Array{Int64,1}, ::Array{Int64,1})\\n\
    \  Closest candidates are:\\n    xor(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\\n  Stacktrace:\\n   [1] string_xor(::String, ::String)\
    \ at /tmp/tmpmenw1f4e.jl:11\\n   [2] top-level scope at /tmp/tmpmenw1f4e.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpmenw1f4e.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpmenw1f4e.jl:22\\n  Test threw exception\\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\\n  MethodError: no method matching xor(::Array{Int64,1},\
    \ ::Array{Int64,1})\\n  Closest candidates are:\\n    xor(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at operators.jl:529\\n  Stacktrace:\\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpmenw1f4e.jl:11\\n   [2] top-level scope at /tmp/tmpmenw1f4e.jl:22\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpmenw1f4e.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpmenw1f4e.jl:23\\n  Test threw exception\\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\\n  MethodError: no method matching xor(::Array{Int64,1},\
    \ ::Array{Int64,1})\\n  Closest candidates are:\\n    xor(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at operators.jl:529\\n  Stacktrace:\\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpmenw1f4e.jl:11\\n   [2] top-level scope at /tmp/tmpmenw1f4e.jl:23\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpmenw1f4e.jl:20\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     3      3\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n   \
    \     if a[i] == b[i]\n            c = c * \"0\"\n        else\n            c\
    \ = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Lengths\
    \ of strings must be equal\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Lengths\
    \ of strings must be equal\")\n    end\n    c = String(length(a))\n    for i =\
    \ 1:length(a)\n        if a[i] == b[i]\n            c[i] = '0'\n        else\n\
    \            c[i] = '1'\n        end\n    end\n    return c\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpar3g3va8.jl:25\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching String(::Int64)\n  Closest candidates are:\n    String(!Matched::String)\
    \ at boot.jl:321\n    String(!Matched::Array{UInt8,1}) at strings/string.jl:39\n\
    \    String(!Matched::Base.CodeUnits{UInt8,String}) at strings/string.jl:77\n\
    \    ...\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpar3g3va8.jl:10\n\
    \   [2] top-level scope at /tmp/tmpar3g3va8.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpar3g3va8.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpar3g3va8.jl:26\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching String(::Int64)\n  Closest\
    \ candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpar3g3va8.jl:10\n   [2] top-level scope at /tmp/tmpar3g3va8.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpar3g3va8.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpar3g3va8.jl:27\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching String(::Int64)\n\
    \  Closest candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpar3g3va8.jl:10\n   [2] top-level scope at /tmp/tmpar3g3va8.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpar3g3va8.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpar3g3va8.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    c = String(length(a))\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            c[i] = '0'\n        else\n\
    \            c[i] = '1'\n        end\n    end\n    return c\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbctiyx8n.jl:25\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching String(::Int64)\n  Closest candidates are:\n    String(!Matched::String)\
    \ at boot.jl:321\n    String(!Matched::Array{UInt8,1}) at strings/string.jl:39\n\
    \    String(!Matched::Base.CodeUnits{UInt8,String}) at strings/string.jl:77\n\
    \    ...\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpbctiyx8n.jl:10\n\
    \   [2] top-level scope at /tmp/tmpbctiyx8n.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbctiyx8n.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpbctiyx8n.jl:26\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching String(::Int64)\n  Closest\
    \ candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpbctiyx8n.jl:10\n   [2] top-level scope at /tmp/tmpbctiyx8n.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbctiyx8n.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpbctiyx8n.jl:27\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching String(::Int64)\n\
    \  Closest candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpbctiyx8n.jl:10\n   [2] top-level scope at /tmp/tmpbctiyx8n.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbctiyx8n.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbctiyx8n.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Inputs must be of equal length.\"))\n    end\n    result = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            result *= \"0\"\n        else\n\
    \            result *= \"1\"\n        end\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\"\
    , \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    c = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = String(length(a))\n    for i in 1:length(a)\n \
    \       c[i] = xor(parse(Int, a[i]), parse(Int, b[i]))\n    end\n    return c\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpave_njm1.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching String(::Int64)\n  Closest candidates are:\n    String(!Matched::String)\
    \ at boot.jl:321\n    String(!Matched::Array{UInt8,1}) at strings/string.jl:39\n\
    \    String(!Matched::Base.CodeUnits{UInt8,String}) at strings/string.jl:77\n\
    \    ...\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpave_njm1.jl:7\n\
    \   [2] top-level scope at /tmp/tmpave_njm1.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpave_njm1.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpave_njm1.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching String(::Int64)\n  Closest\
    \ candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpave_njm1.jl:7\n   [2] top-level scope at /tmp/tmpave_njm1.jl:19\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpave_njm1.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpave_njm1.jl:20\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching String(::Int64)\n\
    \  Closest candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpave_njm1.jl:7\n   [2] top-level scope at /tmp/tmpave_njm1.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpave_njm1.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpave_njm1.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Length of strings must be equal.\"))\n    end\n    result = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            result *= \"0\"\n        else\n\
    \            result *= \"1\"\n        end\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\"\
    , \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"The two\
    \ strings must have the same length.\")\n    end\n    result = \"\"\n    for i\
    \ in 1:length(a)\n        if a[i] == b[i]\n            result *= \"0\"\n     \
    \   else\n            result *= \"1\"\n        end\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = String[]\n    for i in 1:length(a)\n        if\
    \ a[i] == b[i]\n            push!(c, '0')\n        else\n            push!(c,\
    \ '1')\n        end\n    end\n    return join(c)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjt42nzuh.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ Cannot `convert` an object of type Char to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\n  Stacktrace:\n   [1] push!(::Array{String,1},\
    \ ::Char) at ./array.jl:913\n   [2] string_xor(::String, ::String) at /tmp/tmpjt42nzuh.jl:10\n\
    \   [3] top-level scope at /tmp/tmpjt42nzuh.jl:22\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpjt42nzuh.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpjt42nzuh.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: Cannot `convert` an object of type Char to\
    \ an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] push!(::Array{String,1}, ::Char) at ./array.jl:913\n   [2] string_xor(::String,\
    \ ::String) at /tmp/tmpjt42nzuh.jl:10\n   [3] top-level scope at /tmp/tmpjt42nzuh.jl:23\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpjt42nzuh.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpjt42nzuh.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: Cannot `convert` an object of type\
    \ Char to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] push!(::Array{String,1}, ::Char) at ./array.jl:913\n   [2] string_xor(::String,\
    \ ::String) at /tmp/tmpjt42nzuh.jl:10\n   [3] top-level scope at /tmp/tmpjt42nzuh.jl:24\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpjt42nzuh.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjt42nzuh.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    xor_result = \"\"\n    for i in 1:length(a)\n     \
    \   xor_result = xor_result * string(int(a[i]) \u22BB int(b[i]))\n    end\n  \
    \  return xor_result\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\
    \t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"\
    1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgphxmkf9.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  UndefVarError:\
    \ int not defined\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpgphxmkf9.jl:9\n\
    \   [2] top-level scope at /tmp/tmpgphxmkf9.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgphxmkf9.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpgphxmkf9.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  UndefVarError: int not defined\n  Stacktrace:\n   [1]\
    \ string_xor(::String, ::String) at /tmp/tmpgphxmkf9.jl:9\n   [2] top-level scope\
    \ at /tmp/tmpgphxmkf9.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgphxmkf9.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmpgphxmkf9.jl:20\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmpgphxmkf9.jl:9\n   [2] top-level\
    \ scope at /tmp/tmpgphxmkf9.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgphxmkf9.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgphxmkf9.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Strings must be of equal length\"))\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c *= \"0\"\n        else\n            c\
    \ *= \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    a = parse(Int, a, base=2)\n    b = parse(Int, b, base=2)\n\
    \    return string(a \u22BB b, base=2)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpndohdrxd.jl:16\n  Expression: candidate(\"\
    111000\", \"101010\") == \"010010\"\n   Evaluated: \"10010\" == \"010010\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpndohdrxd.jl:16\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpndohdrxd.jl:15\ntest set: Test Failed at /tmp/tmpndohdrxd.jl:18\n\
    \  Expression: candidate(\"0101\", \"0000\") == \"0101\"\n   Evaluated: \"101\"\
    \ == \"0101\"\nStacktrace:\n [1] top-level scope at /tmp/tmpndohdrxd.jl:18\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpndohdrxd.jl:15\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     2      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpndohdrxd.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Strings must be of equal length\"))\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c *= \"0\"\n        else\n            c\
    \ *= \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Input strings must be of equal length\"))\n    end\n    c = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            c = c * \"0\"\n        else\n\
    \            c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Strings\
    \ must be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            push!(c, '0')\n        else\n            push!(c, '1')\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmqisf5r3.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching push!(::String, ::Char)\n  Closest candidates are:\n    push!(::Any,\
    \ ::Any, !Matched::Any) at abstractarray.jl:2158\n    push!(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at abstractarray.jl:2159\n    push!(!Matched::Array{Any,1},\
    \ ::Any) at array.jl:920\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpmqisf5r3.jl:10\n   [2] top-level scope at /tmp/tmpmqisf5r3.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmqisf5r3.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpmqisf5r3.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching push!(::String, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at abstractarray.jl:2158\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at abstractarray.jl:2159\n\
    \    push!(!Matched::Array{Any,1}, ::Any) at array.jl:920\n    ...\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmpmqisf5r3.jl:10\n   [2] top-level\
    \ scope at /tmp/tmpmqisf5r3.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmqisf5r3.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpmqisf5r3.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching push!(::String,\
    \ ::Char)\n  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at\
    \ abstractarray.jl:2158\n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at abstractarray.jl:2159\n    push!(!Matched::Array{Any,1}, ::Any) at array.jl:920\n\
    \    ...\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpmqisf5r3.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmqisf5r3.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmqisf5r3.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmqisf5r3.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = String()\n    for i in 1:length(a)\n        if\
    \ a[i] == b[i]\n            push!(c, '0')\n        else\n            push!(c,\
    \ '1')\n        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpn79kz0jg.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching String()\n  Closest candidates are:\n    String(!Matched::String)\
    \ at boot.jl:321\n    String(!Matched::Array{UInt8,1}) at strings/string.jl:39\n\
    \    String(!Matched::Base.CodeUnits{UInt8,String}) at strings/string.jl:77\n\
    \    ...\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpn79kz0jg.jl:7\n\
    \   [2] top-level scope at /tmp/tmpn79kz0jg.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn79kz0jg.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpn79kz0jg.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching String()\n  Closest candidates\
    \ are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpn79kz0jg.jl:7\n   [2] top-level scope at /tmp/tmpn79kz0jg.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn79kz0jg.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpn79kz0jg.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching String()\n  Closest\
    \ candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpn79kz0jg.jl:7\n   [2] top-level scope at /tmp/tmpn79kz0jg.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn79kz0jg.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn79kz0jg.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n   \
    \     if a[i] == b[i]\n            c = c * \"0\"\n        else\n            c\
    \ = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    return join([xor(parse(Int, a[i]), parse(Int, b[i]))\
    \ for i in 1:length(a)])\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\
    \t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"\
    1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    c = String(length(a))\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c[i] = '0'\n        else\n            c[i]\
    \ = '1'\n        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmd2wdjqn.jl:25\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching String(::Int64)\n  Closest candidates are:\n    String(!Matched::String)\
    \ at boot.jl:321\n    String(!Matched::Array{UInt8,1}) at strings/string.jl:39\n\
    \    String(!Matched::Base.CodeUnits{UInt8,String}) at strings/string.jl:77\n\
    \    ...\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpmd2wdjqn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmd2wdjqn.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmd2wdjqn.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpmd2wdjqn.jl:26\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching String(::Int64)\n  Closest\
    \ candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpmd2wdjqn.jl:10\n   [2] top-level scope at /tmp/tmpmd2wdjqn.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmd2wdjqn.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpmd2wdjqn.jl:27\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching String(::Int64)\n\
    \  Closest candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpmd2wdjqn.jl:10\n   [2] top-level scope at /tmp/tmpmd2wdjqn.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmd2wdjqn.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmd2wdjqn.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    \"\"\" Input are two strings a and b consisting only\
    \ of 1s and 0s.\n    Perform binary XOR on these inputs and return result also\
    \ as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    return\
    \ join([xor(a[i], b[i]) for i in 1:length(a)])\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpe6t5g1qc.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching xor(::Char, ::Char)\n  Closest candidates are:\n    xor(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  Stacktrace:\n\
    \   [1] (::var\"#3#4\"{String,String})(::Int64) at ./none:0\n   [2] iterate at\
    \ ./generator.jl:47 [inlined]\n   [3] collect at ./array.jl:665 [inlined]\n  \
    \ [4] string_xor(::String, ::String) at /tmp/tmpe6t5g1qc.jl:12\n   [5] top-level\
    \ scope at /tmp/tmpe6t5g1qc.jl:19\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpe6t5g1qc.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6t5g1qc.jl:20\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching xor(::Char, ::Char)\n\
    \  Closest candidates are:\n    xor(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] (::var\"#3#4\"{String,String})(::Int64)\
    \ at ./none:0\n   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect at\
    \ ./array.jl:665 [inlined]\n   [4] string_xor(::String, ::String) at /tmp/tmpe6t5g1qc.jl:12\n\
    \   [5] top-level scope at /tmp/tmpe6t5g1qc.jl:20\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpe6t5g1qc.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpe6t5g1qc.jl:21\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching xor(::Char, ::Char)\n\
    \  Closest candidates are:\n    xor(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] (::var\"#3#4\"{String,String})(::Int64)\
    \ at ./none:0\n   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect at\
    \ ./array.jl:665 [inlined]\n   [4] string_xor(::String, ::String) at /tmp/tmpe6t5g1qc.jl:12\n\
    \   [5] top-level scope at /tmp/tmpe6t5g1qc.jl:21\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpe6t5g1qc.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe6t5g1qc.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Input strings must be of equal length.\"))\n    end\n    result = \"\"\n    for\
    \ i in 1:length(a)\n        if a[i] == b[i]\n            result *= \"0\"\n   \
    \     else\n            result *= \"1\"\n        end\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    # Convert to bit arrays\n    a_bits = bitarray(a)\n\
    \    b_bits = bitarray(b)\n    # Perform XOR\n    c_bits = a_bits \u22BB b_bits\n\
    \    # Convert back to string\n    c = string(c_bits)\n    return c\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\"\
    , \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9k3abo67.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  UndefVarError:\
    \ bitarray not defined\n  Stacktrace:\n   [1] string_xor(::String, ::String) at\
    \ /tmp/tmp9k3abo67.jl:8\n   [2] top-level scope at /tmp/tmp9k3abo67.jl:21\n  \
    \ [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9k3abo67.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp9k3abo67.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  UndefVarError: bitarray not defined\n  Stacktrace:\n \
    \  [1] string_xor(::String, ::String) at /tmp/tmp9k3abo67.jl:8\n   [2] top-level\
    \ scope at /tmp/tmp9k3abo67.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9k3abo67.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp9k3abo67.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  UndefVarError: bitarray not defined\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmp9k3abo67.jl:8\n   [2] top-level\
    \ scope at /tmp/tmp9k3abo67.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9k3abo67.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9k3abo67.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        c = c *\
    \ string(int(a[i]) \u22BB int(b[i]))\n    end\n    return c\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphryrgfh7.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  UndefVarError:\
    \ int not defined\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmphryrgfh7.jl:9\n\
    \   [2] top-level scope at /tmp/tmphryrgfh7.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphryrgfh7.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmphryrgfh7.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  UndefVarError: int not defined\n  Stacktrace:\n   [1]\
    \ string_xor(::String, ::String) at /tmp/tmphryrgfh7.jl:9\n   [2] top-level scope\
    \ at /tmp/tmphryrgfh7.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphryrgfh7.jl:17\n  \ntest set: Error During\
    \ Test at /tmp/tmphryrgfh7.jl:20\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmphryrgfh7.jl:9\n   [2] top-level\
    \ scope at /tmp/tmphryrgfh7.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphryrgfh7.jl:17\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphryrgfh7.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    return join([xor(a[i], b[i]) for i in 1:length(a)])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0h8o2efb.jl:14\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching xor(::Char, ::Char)\n  Closest candidates are:\n    xor(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  Stacktrace:\n\
    \   [1] (::var\"#3#4\"{String,String})(::Int64) at ./none:0\n   [2] iterate at\
    \ ./generator.jl:47 [inlined]\n   [3] collect at ./array.jl:665 [inlined]\n  \
    \ [4] string_xor(::String, ::String) at /tmp/tmp0h8o2efb.jl:7\n   [5] top-level\
    \ scope at /tmp/tmp0h8o2efb.jl:14\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp0h8o2efb.jl:13\n  \ntest set: Error During\
    \ Test at /tmp/tmp0h8o2efb.jl:15\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching xor(::Char, ::Char)\n\
    \  Closest candidates are:\n    xor(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] (::var\"#3#4\"{String,String})(::Int64)\
    \ at ./none:0\n   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect at\
    \ ./array.jl:665 [inlined]\n   [4] string_xor(::String, ::String) at /tmp/tmp0h8o2efb.jl:7\n\
    \   [5] top-level scope at /tmp/tmp0h8o2efb.jl:15\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp0h8o2efb.jl:13\n  \ntest set: Error During\
    \ Test at /tmp/tmp0h8o2efb.jl:16\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching xor(::Char, ::Char)\n\
    \  Closest candidates are:\n    xor(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] (::var\"#3#4\"{String,String})(::Int64)\
    \ at ./none:0\n   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect at\
    \ ./array.jl:665 [inlined]\n   [4] string_xor(::String, ::String) at /tmp/tmp0h8o2efb.jl:7\n\
    \   [5] top-level scope at /tmp/tmp0h8o2efb.jl:16\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp0h8o2efb.jl:13\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0h8o2efb.jl:11\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Strings\
    \ must be of equal length\")\n    end\n    c = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Lengths\
    \ of inputs must be equal\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    return join([xor(parse(Int, a[i]), parse(Int, b[i]))\
    \ for i in 1:length(a)])\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\
    \t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"\
    1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            push!(c, '0')\n        else\n            push!(c, '1')\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzgps05h5.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching push!(::String, ::Char)\n  Closest candidates are:\n    push!(::Any,\
    \ ::Any, !Matched::Any) at abstractarray.jl:2158\n    push!(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at abstractarray.jl:2159\n    push!(!Matched::Array{Any,1},\
    \ ::Any) at array.jl:920\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmpzgps05h5.jl:10\n   [2] top-level scope at /tmp/tmpzgps05h5.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgps05h5.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgps05h5.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching push!(::String, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at abstractarray.jl:2158\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at abstractarray.jl:2159\n\
    \    push!(!Matched::Array{Any,1}, ::Any) at array.jl:920\n    ...\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmpzgps05h5.jl:10\n   [2] top-level\
    \ scope at /tmp/tmpzgps05h5.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgps05h5.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpzgps05h5.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching push!(::String,\
    \ ::Char)\n  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at\
    \ abstractarray.jl:2158\n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at abstractarray.jl:2159\n    push!(!Matched::Array{Any,1}, ::Any) at array.jl:920\n\
    \    ...\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpzgps05h5.jl:10\n\
    \   [2] top-level scope at /tmp/tmpzgps05h5.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzgps05h5.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzgps05h5.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            push!(c, '0')\n        else\n            push!(c, '1')\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0u0h787k.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching push!(::String, ::Char)\n  Closest candidates are:\n    push!(::Any,\
    \ ::Any, !Matched::Any) at abstractarray.jl:2158\n    push!(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at abstractarray.jl:2159\n    push!(!Matched::Array{Any,1},\
    \ ::Any) at array.jl:920\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmp0u0h787k.jl:10\n   [2] top-level scope at /tmp/tmp0u0h787k.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0u0h787k.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmp0u0h787k.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching push!(::String, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at abstractarray.jl:2158\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at abstractarray.jl:2159\n\
    \    push!(!Matched::Array{Any,1}, ::Any) at array.jl:920\n    ...\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmp0u0h787k.jl:10\n   [2] top-level\
    \ scope at /tmp/tmp0u0h787k.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0u0h787k.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmp0u0h787k.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching push!(::String,\
    \ ::Char)\n  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at\
    \ abstractarray.jl:2158\n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at abstractarray.jl:2159\n    push!(!Matched::Array{Any,1}, ::Any) at array.jl:920\n\
    \    ...\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmp0u0h787k.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0u0h787k.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0u0h787k.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0u0h787k.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    a and b must be of equal length\"))\n    end\n    result = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            result *= \"0\"\n        else\n\
    \            result *= \"1\"\n        end\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\"\
    , \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of the same length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    a and b must be of the same length\"))\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c *= \"0\"\n        else\n            c\
    \ *= \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length.\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i = 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    return join([xor(parse(Int, a[i]), parse(Int, b[i]))\
    \ for i in 1:length(a)])\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\
    \t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"\
    1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Strings\
    \ must be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        result = result * string(int(a[i]) \u22BB int(b[i]))\n    end\n    return\
    \ result\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8e8z62xm.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  UndefVarError:\
    \ int not defined\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmp8e8z62xm.jl:12\n\
    \   [2] top-level scope at /tmp/tmp8e8z62xm.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8e8z62xm.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp8e8z62xm.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  UndefVarError: int not defined\n  Stacktrace:\n   [1]\
    \ string_xor(::String, ::String) at /tmp/tmp8e8z62xm.jl:12\n   [2] top-level scope\
    \ at /tmp/tmp8e8z62xm.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8e8z62xm.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp8e8z62xm.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmp8e8z62xm.jl:12\n   [2] top-level\
    \ scope at /tmp/tmp8e8z62xm.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8e8z62xm.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8e8z62xm.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Strings must be of equal length\"))\n    end\n    result = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            result *= \"0\"\n        else\n\
    \            result *= \"1\"\n        end\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\"\
    , \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Input strings must be of equal length\"))\n    end\n    c = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            c = c * \"0\"\n        else\n\
    \            c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n   \
    \     if a[i] == b[i]\n            c = c * \"0\"\n        else\n            c\
    \ = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    # Convert to integer\n    a = parse(Int, a, base=2)\n\
    \    b = parse(Int, b, base=2)\n    # XOR\n    c = a \u22BB b\n    # Convert to\
    \ string\n    return string(c, base=2)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps2nkllk3.jl:20\n  Expression: candidate(\"\
    111000\", \"101010\") == \"010010\"\n   Evaluated: \"10010\" == \"010010\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps2nkllk3.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps2nkllk3.jl:19\ntest set: Test Failed at /tmp/tmps2nkllk3.jl:22\n\
    \  Expression: candidate(\"0101\", \"0000\") == \"0101\"\n   Evaluated: \"101\"\
    \ == \"0101\"\nStacktrace:\n [1] top-level scope at /tmp/tmps2nkllk3.jl:22\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps2nkllk3.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     2      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps2nkllk3.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    # convert to integer\n    a_int = parse(Int, a, base=2)\n\
    \    b_int = parse(Int, b, base=2)\n    # perform xor\n    xor_int = xor(a_int,\
    \ b_int)\n    # convert back to string\n    xor_string = string(xor_int, base=2)\n\
    \    return xor_string\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\
    \t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"\
    1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb04s7498.jl:21\n  Expression: candidate(\"\
    111000\", \"101010\") == \"010010\"\n   Evaluated: \"10010\" == \"010010\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb04s7498.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb04s7498.jl:20\ntest set: Test Failed at /tmp/tmpb04s7498.jl:23\n\
    \  Expression: candidate(\"0101\", \"0000\") == \"0101\"\n   Evaluated: \"101\"\
    \ == \"0101\"\nStacktrace:\n [1] top-level scope at /tmp/tmpb04s7498.jl:23\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb04s7498.jl:20\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     2      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb04s7498.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n   \
    \     if a[i] == b[i]\n            c = c * \"0\"\n        else\n            c\
    \ = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"inputs must\
    \ be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Inputs must be of equal length\"))\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c *= \"0\"\n        else\n            c\
    \ *= \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n   \
    \     if a[i] == b[i]\n            c = c * \"0\"\n        else\n            c\
    \ = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Length of strings must be equal.\"))\n    end\n    result = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            result *= \"0\"\n        else\n\
    \            result *= \"1\"\n        end\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\"\
    , \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n   \
    \     if a[i] == b[i]\n            c = c * \"0\"\n        else\n            c\
    \ = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Strings must be of equal length\"))\n    end\n    result = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    return join([(x == y ? \"0\" : \"1\") for (x, y) in\
    \ zip(a, b)])\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t\
    @test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\"\
    , \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Inputs must\
    \ be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    return join([xor(parse(Int, a[i]), parse(Int, b[i]))\
    \ for i in 1:length(a)])\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\
    \t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"\
    1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"lengths\
    \ of strings must be equal\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length.\")\n    end\n    c = String(length(a))\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            c[i] = '0'\n        else\n\
    \            c[i] = '1'\n        end\n    end\n    return c\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp76lk1s9e.jl:25\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching String(::Int64)\n  Closest candidates are:\n    String(!Matched::String)\
    \ at boot.jl:321\n    String(!Matched::Array{UInt8,1}) at strings/string.jl:39\n\
    \    String(!Matched::Base.CodeUnits{UInt8,String}) at strings/string.jl:77\n\
    \    ...\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmp76lk1s9e.jl:10\n\
    \   [2] top-level scope at /tmp/tmp76lk1s9e.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp76lk1s9e.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp76lk1s9e.jl:26\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching String(::Int64)\n  Closest\
    \ candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmp76lk1s9e.jl:10\n   [2] top-level scope at /tmp/tmp76lk1s9e.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp76lk1s9e.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp76lk1s9e.jl:27\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching String(::Int64)\n\
    \  Closest candidates are:\n    String(!Matched::String) at boot.jl:321\n    String(!Matched::Array{UInt8,1})\
    \ at strings/string.jl:39\n    String(!Matched::Base.CodeUnits{UInt8,String})\
    \ at strings/string.jl:77\n    ...\n  Stacktrace:\n   [1] string_xor(::String,\
    \ ::String) at /tmp/tmp76lk1s9e.jl:10\n   [2] top-level scope at /tmp/tmp76lk1s9e.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp76lk1s9e.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp76lk1s9e.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Inputs must be of equal length\"))\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    a and b must be the same length\"))\n    end\n    return join([a[i] == b[i] ?\
    \ \"0\" : \"1\" for i in 1:length(a)])\nend\nusing Test\n\n@testset begin\n\n\
    candidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Lengths\
    \ of strings must be equal\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length.\")\n    end\n    c = \"\"\n    for i = 1:length(a)\n\
    \        c = c * string(int(a[i]) \u22BB int(b[i]))\n    end\n    return c\nend\n\
    using Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpevbrg9yf.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  UndefVarError:\
    \ int not defined\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpevbrg9yf.jl:12\n\
    \   [2] top-level scope at /tmp/tmpevbrg9yf.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpevbrg9yf.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpevbrg9yf.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  UndefVarError: int not defined\n  Stacktrace:\n   [1]\
    \ string_xor(::String, ::String) at /tmp/tmpevbrg9yf.jl:12\n   [2] top-level scope\
    \ at /tmp/tmpevbrg9yf.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpevbrg9yf.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpevbrg9yf.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmpevbrg9yf.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpevbrg9yf.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpevbrg9yf.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpevbrg9yf.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    return join([xor(a[i], b[i]) for i in 1:length(a)])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjyfe4o8z.jl:14\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching xor(::Char, ::Char)\n  Closest candidates are:\n    xor(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  Stacktrace:\n\
    \   [1] (::var\"#3#4\"{String,String})(::Int64) at ./none:0\n   [2] iterate at\
    \ ./generator.jl:47 [inlined]\n   [3] collect at ./array.jl:665 [inlined]\n  \
    \ [4] string_xor(::String, ::String) at /tmp/tmpjyfe4o8z.jl:7\n   [5] top-level\
    \ scope at /tmp/tmpjyfe4o8z.jl:14\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpjyfe4o8z.jl:13\n  \ntest set: Error During\
    \ Test at /tmp/tmpjyfe4o8z.jl:15\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching xor(::Char, ::Char)\n\
    \  Closest candidates are:\n    xor(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] (::var\"#3#4\"{String,String})(::Int64)\
    \ at ./none:0\n   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect at\
    \ ./array.jl:665 [inlined]\n   [4] string_xor(::String, ::String) at /tmp/tmpjyfe4o8z.jl:7\n\
    \   [5] top-level scope at /tmp/tmpjyfe4o8z.jl:15\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpjyfe4o8z.jl:13\n  \ntest set: Error During\
    \ Test at /tmp/tmpjyfe4o8z.jl:16\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching xor(::Char, ::Char)\n\
    \  Closest candidates are:\n    xor(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] (::var\"#3#4\"{String,String})(::Int64)\
    \ at ./none:0\n   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect at\
    \ ./array.jl:665 [inlined]\n   [4] string_xor(::String, ::String) at /tmp/tmpjyfe4o8z.jl:7\n\
    \   [5] top-level scope at /tmp/tmpjyfe4o8z.jl:16\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpjyfe4o8z.jl:13\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjyfe4o8z.jl:11\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    a and b must be of equal length\"))\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c *= \"0\"\n        else\n            c\
    \ *= \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    c = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of the same length.\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Strings must be of equal length\"))\n    end\n    result = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            result *= \"0\"\n        else\n\
    \            result *= \"1\"\n        end\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\"\
    , \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    # Convert to integer\n    a_int = parse(Int, a, base=2)\n\
    \    b_int = parse(Int, b, base=2)\n    # XOR\n    c_int = bitxor(a_int, b_int)\n\
    \    # Convert back to string\n    c = string(c_int, base=2)\n    return c\nend\n\
    using Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjwashwyp.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  UndefVarError:\
    \ bitxor not defined\n  Stacktrace:\n   [1] string_xor(::String, ::String) at\
    \ /tmp/tmpjwashwyp.jl:11\n   [2] top-level scope at /tmp/tmpjwashwyp.jl:21\n \
    \  [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjwashwyp.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpjwashwyp.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  UndefVarError: bitxor not defined\n  Stacktrace:\n   [1]\
    \ string_xor(::String, ::String) at /tmp/tmpjwashwyp.jl:11\n   [2] top-level scope\
    \ at /tmp/tmpjwashwyp.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjwashwyp.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpjwashwyp.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  UndefVarError: bitxor not defined\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmpjwashwyp.jl:11\n   [2] top-level\
    \ scope at /tmp/tmpjwashwyp.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjwashwyp.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjwashwyp.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Inputs must be of equal length\"))\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c *= \"0\"\n        else\n            c\
    \ *= \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"\
    101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    result = \"\"\n    for i in 1:length(a)\n        if\
    \ a[i] == b[i]\n            result *= \"0\"\n        else\n            result\
    \ *= \"1\"\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        println(\"Error:\
    \ Strings must be of equal length\")\n        return \"\"\n    end\n    c = \"\
    \"\n    for i in 1:length(a)\n        if a[i] == b[i]\n            c = c * \"\
    0\"\n        else\n            c = c * \"1\"\n        end\n    end\n    return\
    \ c\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    Input strings must be of equal length\"))\n    end\n    c = \"\"\n    for i in\
    \ 1:length(a)\n        c = c * string(int(a[i]) \u22BB int(b[i]))\n    end\n \
    \   return c\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t\
    @test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\"\
    , \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz3fy294d.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  UndefVarError:\
    \ int not defined\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmpz3fy294d.jl:12\n\
    \   [2] top-level scope at /tmp/tmpz3fy294d.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz3fy294d.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpz3fy294d.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  UndefVarError: int not defined\n  Stacktrace:\n   [1]\
    \ string_xor(::String, ::String) at /tmp/tmpz3fy294d.jl:12\n   [2] top-level scope\
    \ at /tmp/tmpz3fy294d.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz3fy294d.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpz3fy294d.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] string_xor(::String, ::String) at /tmp/tmpz3fy294d.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpz3fy294d.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz3fy294d.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz3fy294d.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Length of\
    \ inputs must be equal\")\n    end\n    c = \"\"\n    for i in 1:length(a)\n \
    \       if a[i] == b[i]\n            c = c * \"0\"\n        else\n           \
    \ c = c * \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\")\
    \ == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"\
    0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    return join([xor(a[i], b[i]) for i in 1:length(a)])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
    111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\"\
    )\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpoh_2s6lm.jl:14\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching xor(::Char, ::Char)\n  Closest candidates are:\n    xor(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  Stacktrace:\n\
    \   [1] (::var\"#3#4\"{String,String})(::Int64) at ./none:0\n   [2] iterate at\
    \ ./generator.jl:47 [inlined]\n   [3] collect at ./array.jl:665 [inlined]\n  \
    \ [4] string_xor(::String, ::String) at /tmp/tmpoh_2s6lm.jl:7\n   [5] top-level\
    \ scope at /tmp/tmpoh_2s6lm.jl:14\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpoh_2s6lm.jl:13\n  \ntest set: Error During\
    \ Test at /tmp/tmpoh_2s6lm.jl:15\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching xor(::Char, ::Char)\n\
    \  Closest candidates are:\n    xor(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] (::var\"#3#4\"{String,String})(::Int64)\
    \ at ./none:0\n   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect at\
    \ ./array.jl:665 [inlined]\n   [4] string_xor(::String, ::String) at /tmp/tmpoh_2s6lm.jl:7\n\
    \   [5] top-level scope at /tmp/tmpoh_2s6lm.jl:15\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpoh_2s6lm.jl:13\n  \ntest set: Error During\
    \ Test at /tmp/tmpoh_2s6lm.jl:16\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching xor(::Char, ::Char)\n\
    \  Closest candidates are:\n    xor(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\n  Stacktrace:\n   [1] (::var\"#3#4\"{String,String})(::Int64)\
    \ at ./none:0\n   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect at\
    \ ./array.jl:665 [inlined]\n   [4] string_xor(::String, ::String) at /tmp/tmpoh_2s6lm.jl:7\n\
    \   [5] top-level scope at /tmp/tmpoh_2s6lm.jl:16\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpoh_2s6lm.jl:13\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoh_2s6lm.jl:11\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        throw(ArgumentError(\"\
    a and b must be of equal length\"))\n    end\n    c = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            c *= \"0\"\n        else\n            c\
    \ *= \"1\"\n        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\"\
    )\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = String(a)\n    for i in 1:length(a)\n        if\
    \ a[i] == b[i]\n            c[i] = '0'\n        else\n            c[i] = '1'\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmptms7s5q2.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"111000\", \"101010\") == \"010010\"\n  MethodError:\
    \ no method matching setindex!(::String, ::Char, ::Int64)\n  Stacktrace:\n   [1]\
    \ string_xor(::String, ::String) at /tmp/tmptms7s5q2.jl:10\n   [2] top-level scope\
    \ at /tmp/tmptms7s5q2.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptms7s5q2.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmptms7s5q2.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    1\", \"1\") == \"0\"\n  MethodError: no method matching setindex!(::String, ::Char,\
    \ ::Int64)\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmptms7s5q2.jl:10\n\
    \   [2] top-level scope at /tmp/tmptms7s5q2.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptms7s5q2.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmptms7s5q2.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    0101\", \"0000\") == \"0101\"\n  MethodError: no method matching setindex!(::String,\
    \ ::Char, ::Int64)\n  Stacktrace:\n   [1] string_xor(::String, ::String) at /tmp/tmptms7s5q2.jl:10\n\
    \   [2] top-level scope at /tmp/tmptms7s5q2.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptms7s5q2.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptms7s5q2.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    if length(a) != length(b)\n        error(\"Input strings\
    \ must be of equal length\")\n    end\n    output = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            output = string(output, \"0\")\n       \
    \ else\n            output = string(output, \"1\")\n        end\n    end\n   \
    \ return output\nend\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\
    \t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"\
    1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n \
    \   Perform binary XOR on these inputs and return result also as a string.\n \
    \   >>> string_xor('010', '110')\n    '100'\n    \"\"\"\nfunction string_xor(a::String,\
    \ b::String)::String \n    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t\
    @test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\"\
    ) == \"0101\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
