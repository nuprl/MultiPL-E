name: HumanEval_1_separate_paren_groups
language: julia
results:
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_w5_fn5p.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_w5_fn5p.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_w5_fn5p.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_w5_fn5p.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp_w5_fn5p.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_w5_fn5p.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_w5_fn5p.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_w5_fn5p.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp_w5_fn5p.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_w5_fn5p.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_w5_fn5p.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_w5_fn5p.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp_w5_fn5p.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_w5_fn5p.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_w5_fn5p.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_w5_fn5p.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_w5_fn5p.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpa5hb1g6e.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpa5hb1g6e.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa5hb1g6e.jl:16\\ntest set: Test Failed at /tmp/tmpa5hb1g6e.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpa5hb1g6e.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa5hb1g6e.jl:16\\ntest set: Test Failed at /tmp/tmpa5hb1g6e.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpa5hb1g6e.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa5hb1g6e.jl:16\\ntest set: Test Failed at /tmp/tmpa5hb1g6e.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpa5hb1g6e.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa5hb1g6e.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    # Hint: You may want to use the `split`\
    \ function\n    # Hint: You may want to use the `join` function\n    # Hint: You\
    \ may want to use the `strip` function\n    # Hint: You may want to use the `filter`\
    \ function\n    # Hint: You may want to use the `push!` function\n    # Hint:\
    \ You may want to use the `length` function\n    # Hint: You may want to use the\
    \ `pop!` function\n    # Hint: You may want to use the `==` function\n    # Hint:\
    \ You may want to use the `!=` function\n    # Hint: You may want to use the `in`\
    \ function\n    # Hint: You may want to use the `append!` function\n    # Hint:\
    \ You may want to use the `*` function\n    # Hint: You may want to use the `+`\
    \ function\n    # Hint: You may want to use the `-` function\n    # Hint: You\
    \ may want to use the `/` function\n    # Hint: You may want to use the `%` function\n\
    \    # Hint: You may want to use the `^` function\n    # Hint: You may want to\
    \ use the `<` function\n    # Hint: You may want to use the `>` function\n   \
    \ # Hint: You may want to use the `<=` function\n    # Hint: You may want to use\
    \ the `>=` function\n    # Hint: You may want to use the `!` function\n    # Hint:\
    \ You may want to use the `&&` function\n    # Hint: You may want to use the `||`\
    \ function\n    # Hint: You may want to use the `not` function\n    # Hint: You\
    \ may want to use the `and` function\n    # Hint: You may want to use the `or`\
    \ function\n    # Hint: You may want to use the `xor` function\n    # Hint: You\
    \ may want to use the `isempty` function\n    # Hint: You may want to use the\
    \ `issubset` function\n    # Hint: You may want to use the `\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_a4yeqog.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp_a4yeqog.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp_a4yeqog.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyek5i7f1.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyek5i7f1.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyek5i7f1.jl:16\ntest set: Test Failed at /tmp/tmpyek5i7f1.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpyek5i7f1.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyek5i7f1.jl:16\ntest set: Test Failed at /tmp/tmpyek5i7f1.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpyek5i7f1.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyek5i7f1.jl:16\ntest set: Test Failed at /tmp/tmpyek5i7f1.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpyek5i7f1.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyek5i7f1.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyek5i7f1.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = []\n    i = 1\n    while i <= length(paren_string)\n        if paren_string[i]\
    \ == '('\n            open_paren_count = 1\n            close_paren_count = 0\n\
    \            j = i + 1\n            while j <= length(paren_string)\n        \
    \        if paren_string[j] == '('\n                    open_paren_count += 1\n\
    \                elseif paren_string[j] == ')'\n                    close_paren_count\
    \ += 1\n                end\n                if open_paren_count == close_paren_count\n\
    \                    push!(paren_groups, paren_string[i:j])\n                \
    \    i = j\n                    break\n                end\n                j\
    \ += 1\n            end\n        end\n        i += 1\n    end\n    return paren_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr8ldgauq.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpr8ldgauq.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr8ldgauq.jl:16\ntest set: Test Failed at /tmp/tmpr8ldgauq.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpr8ldgauq.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr8ldgauq.jl:16\ntest set: Test Failed at /tmp/tmpr8ldgauq.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpr8ldgauq.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr8ldgauq.jl:16\ntest set: Test Failed at /tmp/tmpr8ldgauq.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpr8ldgauq.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr8ldgauq.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr8ldgauq.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = []\n    paren_group = \"\"\n    open_parens = 0\n    for c in paren_string\n\
    \        if c == '('\n            open_parens += 1\n        elseif c == ')'\n\
    \            open_parens -= 1\n        end\n        paren_group *= c\n       \
    \ if open_parens == 0\n            push!(paren_groups, paren_group)\n        \
    \    paren_group = \"\"\n        end\n    end\n    return paren_groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpscpsms9b.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpscpsms9b.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpscpsms9b.jl:16\ntest set: Test Failed at /tmp/tmpscpsms9b.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpscpsms9b.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpscpsms9b.jl:16\ntest set: Test Failed at /tmp/tmpscpsms9b.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpscpsms9b.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpscpsms9b.jl:16\ntest set: Test Failed at /tmp/tmpscpsms9b.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpscpsms9b.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpscpsms9b.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpscpsms9b.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3sv_9on1.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp3sv_9on1.jl:10\n\
    \   [2] top-level scope at /tmp/tmp3sv_9on1.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3sv_9on1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp3sv_9on1.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp3sv_9on1.jl:10\n\
    \   [2] top-level scope at /tmp/tmp3sv_9on1.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3sv_9on1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp3sv_9on1.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp3sv_9on1.jl:10\n\
    \   [2] top-level scope at /tmp/tmp3sv_9on1.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3sv_9on1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp3sv_9on1.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp3sv_9on1.jl:10\n\
    \   [2] top-level scope at /tmp/tmp3sv_9on1.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3sv_9on1.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3sv_9on1.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpr_l40w2h.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpr_l40w2h.jl:10\n\
    \   [2] top-level scope at /tmp/tmpr_l40w2h.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr_l40w2h.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpr_l40w2h.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpr_l40w2h.jl:10\n\
    \   [2] top-level scope at /tmp/tmpr_l40w2h.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr_l40w2h.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpr_l40w2h.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpr_l40w2h.jl:10\n\
    \   [2] top-level scope at /tmp/tmpr_l40w2h.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr_l40w2h.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpr_l40w2h.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpr_l40w2h.jl:10\n\
    \   [2] top-level scope at /tmp/tmpr_l40w2h.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr_l40w2h.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr_l40w2h.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi2_myv68.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpi2_myv68.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi2_myv68.jl:16\ntest set: Test Failed at /tmp/tmpi2_myv68.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpi2_myv68.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi2_myv68.jl:16\ntest set: Test Failed at /tmp/tmpi2_myv68.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpi2_myv68.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi2_myv68.jl:16\ntest set: Test Failed at /tmp/tmpi2_myv68.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpi2_myv68.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi2_myv68.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi2_myv68.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    # Hint: you may want to use the `split`\
    \ function\n    # Hint: you may want to use the `strip` function\n    # Hint:\
    \ you may want to use the `join` function\n    # Hint: you may want to use the\
    \ `isempty` function\n    # Hint: you may want to use the `push!` function\n \
    \   # Hint: you may want to use the `pop!` function\n    # Hint: you may want\
    \ to use the `append!` function\n    # Hint: you may want to use the `in` function\n\
    \    # Hint: you may want to use the `==` function\n    # Hint: you may want to\
    \ use the `!=` function\n    # Hint: you may want to use the `<` function\n  \
    \  # Hint: you may want to use the `>` function\n    # Hint: you may want to use\
    \ the `<=` function\n    # Hint: you may want to use the `>=` function\n    #\
    \ Hint: you may want to use the `&&` function\n    # Hint: you may want to use\
    \ the `||` function\n    # Hint: you may want to use the `!` function\n    # Hint:\
    \ you may want to use the `&` function\n    # Hint: you may want to use the `|`\
    \ function\n    # Hint: you may want to use the `^` function\n    # Hint: you\
    \ may want to use the `~` function\n    # Hint: you may want to use the `<<` function\n\
    \    # Hint: you may want to use the `>>` function\n    # Hint: you may want to\
    \ use the `>>>` function\n    # Hint: you may want to use the `+` function\n \
    \   # Hint: you may want to use the `-` function\n    # Hint: you may want to\
    \ use the `*` function\n    # Hint: you may want to use the `/` function\n   \
    \ # Hint: you may want to use the `//` function\n    # Hint: you may want to use\
    \ the `%` function\n    # Hint: you may want to use the `^` function\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphjcygmno.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmphjcygmno.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmphjcygmno.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjcanq5ry.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpjcanq5ry.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcanq5ry.jl:16\ntest set: Test Failed at /tmp/tmpjcanq5ry.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpjcanq5ry.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcanq5ry.jl:16\ntest set: Test Failed at /tmp/tmpjcanq5ry.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpjcanq5ry.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcanq5ry.jl:16\ntest set: Test Failed at /tmp/tmpjcanq5ry.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpjcanq5ry.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcanq5ry.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjcanq5ry.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw9gmxhfj.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw9gmxhfj.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw9gmxhfj.jl:16\ntest set: Test Failed at /tmp/tmpw9gmxhfj.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpw9gmxhfj.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw9gmxhfj.jl:16\ntest set: Test Failed at /tmp/tmpw9gmxhfj.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpw9gmxhfj.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw9gmxhfj.jl:16\ntest set: Test Failed at /tmp/tmpw9gmxhfj.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpw9gmxhfj.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw9gmxhfj.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw9gmxhfj.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl92ooyev.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpl92ooyev.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl92ooyev.jl:16\ntest set: Test Failed at /tmp/tmpl92ooyev.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpl92ooyev.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl92ooyev.jl:16\ntest set: Test Failed at /tmp/tmpl92ooyev.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpl92ooyev.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl92ooyev.jl:16\ntest set: Test Failed at /tmp/tmpl92ooyev.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpl92ooyev.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl92ooyev.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl92ooyev.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpr4t4x0sq.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpr4t4x0sq.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr4t4x0sq.jl:16\\ntest set: Test Failed at /tmp/tmpr4t4x0sq.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpr4t4x0sq.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr4t4x0sq.jl:16\\ntest set: Test Failed at /tmp/tmpr4t4x0sq.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpr4t4x0sq.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr4t4x0sq.jl:16\\ntest set: Test Failed at /tmp/tmpr4t4x0sq.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpr4t4x0sq.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr4t4x0sq.jl:16\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \")(\" => \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpan8b5jha.jl:20\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpan8b5jha.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpan8b5jha.jl:19\\ntest set: Test Failed at /tmp/tmpan8b5jha.jl:22\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ [\"(()\", \"(())\", \"((())))\"] == [\"(()(())((())))\"]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpan8b5jha.jl:22\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpan8b5jha.jl:19\\ntest set: Test Failed at /tmp/tmpan8b5jha.jl:23\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: [\"()\", \"(())\", \"(()\", \"())\"] == [\"()\", \"(())\", \"\
    (()())\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpan8b5jha.jl:23\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpan8b5jha.jl:19\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpihpjyxs5.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpihpjyxs5.jl:10\n\
    \   [2] top-level scope at /tmp/tmpihpjyxs5.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpihpjyxs5.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpihpjyxs5.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpihpjyxs5.jl:10\n\
    \   [2] top-level scope at /tmp/tmpihpjyxs5.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpihpjyxs5.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpihpjyxs5.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpihpjyxs5.jl:10\n\
    \   [2] top-level scope at /tmp/tmpihpjyxs5.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpihpjyxs5.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpihpjyxs5.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpihpjyxs5.jl:10\n\
    \   [2] top-level scope at /tmp/tmpihpjyxs5.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpihpjyxs5.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpihpjyxs5.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \")(\" => \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvk4s76fw.jl:20\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpvk4s76fw.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvk4s76fw.jl:19\ntest set: Test Failed at /tmp/tmpvk4s76fw.jl:22\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()\", \"(())\", \"((())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpvk4s76fw.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvk4s76fw.jl:19\ntest set: Test Failed at /tmp/tmpvk4s76fw.jl:23\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()\", \"())\"] == [\"()\", \"(())\", \"\
    (()())\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpvk4s76fw.jl:23\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvk4s76fw.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvk4s76fw.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbeibcixq.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpbeibcixq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpbeibcixq.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbeibcixq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpbeibcixq.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpbeibcixq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpbeibcixq.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbeibcixq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpbeibcixq.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpbeibcixq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpbeibcixq.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbeibcixq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpbeibcixq.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpbeibcixq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpbeibcixq.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbeibcixq.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbeibcixq.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = []\n    paren_stack = []\n    paren_group = \"\"\n    for char in paren_string\n\
    \        if char == '('\n            push!(paren_stack, char)\n        elseif\
    \ char == ')'\n            pop!(paren_stack)\n            paren_group *= char\n\
    \            if isempty(paren_stack)\n                push!(paren_groups, paren_group)\n\
    \                paren_group = \"\"\n            end\n        else\n         \
    \   paren_group *= char\n        end\n    end\n    return paren_groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf7_ynmms.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\")))\", \")))\", \")\", \")))))\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpf7_ynmms.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf7_ynmms.jl:33\ntest set: Test Failed at /tmp/tmpf7_ynmms.jl:35\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\")\", \"))\", \")))\", \"))))\"] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpf7_ynmms.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf7_ynmms.jl:33\ntest set: Test Failed at /tmp/tmpf7_ynmms.jl:36\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\")))))))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpf7_ynmms.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf7_ynmms.jl:33\ntest set: Test Failed at /tmp/tmpf7_ynmms.jl:37\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\")\", \"))\", \")))\"] == [\"()\", \"(())\", \"(()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpf7_ynmms.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf7_ynmms.jl:33\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf7_ynmms.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpf342zief.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpf342zief.jl:10\n\
    \   [2] top-level scope at /tmp/tmpf342zief.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf342zief.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpf342zief.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpf342zief.jl:10\n\
    \   [2] top-level scope at /tmp/tmpf342zief.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf342zief.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpf342zief.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpf342zief.jl:10\n\
    \   [2] top-level scope at /tmp/tmpf342zief.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf342zief.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpf342zief.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpf342zief.jl:10\n\
    \   [2] top-level scope at /tmp/tmpf342zief.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf342zief.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf342zief.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1l36_l_z.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1l36_l_z.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1l36_l_z.jl:16\ntest set: Test Failed at /tmp/tmp1l36_l_z.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp1l36_l_z.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1l36_l_z.jl:16\ntest set: Test Failed at /tmp/tmp1l36_l_z.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp1l36_l_z.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1l36_l_z.jl:16\ntest set: Test Failed at /tmp/tmp1l36_l_z.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp1l36_l_z.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1l36_l_z.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1l36_l_z.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmptvlf5avy.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmptvlf5avy.jl:10\n\
    \   [2] top-level scope at /tmp/tmptvlf5avy.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptvlf5avy.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmptvlf5avy.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmptvlf5avy.jl:10\n\
    \   [2] top-level scope at /tmp/tmptvlf5avy.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptvlf5avy.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmptvlf5avy.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmptvlf5avy.jl:10\n\
    \   [2] top-level scope at /tmp/tmptvlf5avy.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptvlf5avy.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmptvlf5avy.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmptvlf5avy.jl:10\n\
    \   [2] top-level scope at /tmp/tmptvlf5avy.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptvlf5avy.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptvlf5avy.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_ao8xs3_.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_ao8xs3_.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_ao8xs3_.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_ao8xs3_.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp_ao8xs3_.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_ao8xs3_.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_ao8xs3_.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_ao8xs3_.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp_ao8xs3_.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_ao8xs3_.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_ao8xs3_.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_ao8xs3_.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp_ao8xs3_.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_ao8xs3_.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_ao8xs3_.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_ao8xs3_.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_ao8xs3_.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpsetonpry.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpsetonpry.jl:10\\\
    n   [2] top-level scope at /tmp/tmpsetonpry.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsetonpry.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsetonpry.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpsetonpry.jl:10\\\
    n   [2] top-level scope at /tmp/tmpsetonpry.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsetonpry.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsetonpry.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpsetonpry.jl:10\\\
    n   [2] top-level scope at /tmp/tmpsetonpry.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsetonpry.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsetonpry.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpsetonpry.jl:10\\\
    n   [2] top-level scope at /tmp/tmpsetonpry.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsetonpry.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpr_3or3rw.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpr_3or3rw.jl:10\\\
    n   [2] top-level scope at /tmp/tmpr_3or3rw.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpr_3or3rw.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpr_3or3rw.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpr_3or3rw.jl:10\\\
    n   [2] top-level scope at /tmp/tmpr_3or3rw.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpr_3or3rw.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpr_3or3rw.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpr_3or3rw.jl:10\\\
    n   [2] top-level scope at /tmp/tmpr_3or3rw.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpr_3or3rw.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpr_3or3rw.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpr_3or3rw.jl:10\\\
    n   [2] top-level scope at /tmp/tmpr_3or3rw.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpr_3or3rw.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphp4m_cc_.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphp4m_cc_.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphp4m_cc_.jl:16\ntest set: Test Failed at /tmp/tmphp4m_cc_.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmphp4m_cc_.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphp4m_cc_.jl:16\ntest set: Test Failed at /tmp/tmphp4m_cc_.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmphp4m_cc_.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphp4m_cc_.jl:16\ntest set: Test Failed at /tmp/tmphp4m_cc_.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmphp4m_cc_.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphp4m_cc_.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphp4m_cc_.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp0j3yhw5b.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp0j3yhw5b.jl:10\\\
    n   [2] top-level scope at /tmp/tmp0j3yhw5b.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0j3yhw5b.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0j3yhw5b.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp0j3yhw5b.jl:10\\\
    n   [2] top-level scope at /tmp/tmp0j3yhw5b.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0j3yhw5b.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0j3yhw5b.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp0j3yhw5b.jl:10\\\
    n   [2] top-level scope at /tmp/tmp0j3yhw5b.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0j3yhw5b.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0j3yhw5b.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp0j3yhw5b.jl:10\\\
    n   [2] top-level scope at /tmp/tmp0j3yhw5b.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0j3yhw5b.jl:15\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfthcdtru.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpfthcdtru.jl:10\\\
    n   [2] top-level scope at /tmp/tmpfthcdtru.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfthcdtru.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfthcdtru.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpfthcdtru.jl:10\\\
    n   [2] top-level scope at /tmp/tmpfthcdtru.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfthcdtru.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfthcdtru.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpfthcdtru.jl:10\\\
    n   [2] top-level scope at /tmp/tmpfthcdtru.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfthcdtru.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfthcdtru.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpfthcdtru.jl:10\\\
    n   [2] top-level scope at /tmp/tmpfthcdtru.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfthcdtru.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvv_frss7.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpvv_frss7.jl:10\n\
    \   [2] top-level scope at /tmp/tmpvv_frss7.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvv_frss7.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpvv_frss7.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpvv_frss7.jl:10\n\
    \   [2] top-level scope at /tmp/tmpvv_frss7.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvv_frss7.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpvv_frss7.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpvv_frss7.jl:10\n\
    \   [2] top-level scope at /tmp/tmpvv_frss7.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvv_frss7.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpvv_frss7.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpvv_frss7.jl:10\n\
    \   [2] top-level scope at /tmp/tmpvv_frss7.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvv_frss7.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvv_frss7.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpndk2iho6.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpndk2iho6.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpndk2iho6.jl:16\ntest set: Test Failed at /tmp/tmpndk2iho6.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpndk2iho6.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpndk2iho6.jl:16\ntest set: Test Failed at /tmp/tmpndk2iho6.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpndk2iho6.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpndk2iho6.jl:16\ntest set: Test Failed at /tmp/tmpndk2iho6.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpndk2iho6.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpndk2iho6.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpndk2iho6.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa05ur3g4.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpa05ur3g4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpa05ur3g4.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa05ur3g4.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpa05ur3g4.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpa05ur3g4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpa05ur3g4.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa05ur3g4.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpa05ur3g4.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpa05ur3g4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpa05ur3g4.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa05ur3g4.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpa05ur3g4.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpa05ur3g4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpa05ur3g4.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa05ur3g4.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa05ur3g4.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_parens = 0\n    groups = []\n    current_group = \"\"\n    for c\
    \ in paren_string\n        if c == '('\n            open_parens += 1\n       \
    \     current_group *= c\n        elseif c == ')'\n            open_parens -=\
    \ 1\n            current_group *= c\n        end\n        if open_parens == 0\n\
    \            push!(groups, current_group)\n            current_group = \"\"\n\
    \        end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpaqzsqltx.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpaqzsqltx.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaqzsqltx.jl:31\ntest set: Test Failed at /tmp/tmpaqzsqltx.jl:33\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"\", \"(())\", \"\", \"((()))\"\
    , \"\", \"(((())))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpaqzsqltx.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaqzsqltx.jl:31\ntest set: Test Failed at /tmp/tmpaqzsqltx.jl:35\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"\", \"(())\", \"\", \"(()())\"] == [\"()\", \"(())\"\
    , \"(()())\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpaqzsqltx.jl:35\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaqzsqltx.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaqzsqltx.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1ifta3c3.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1ifta3c3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1ifta3c3.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ifta3c3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp1ifta3c3.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1ifta3c3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1ifta3c3.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ifta3c3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp1ifta3c3.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1ifta3c3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1ifta3c3.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ifta3c3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp1ifta3c3.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1ifta3c3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1ifta3c3.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1ifta3c3.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1ifta3c3.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp5x9dytz.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpp5x9dytz.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp5x9dytz.jl:16\ntest set: Test Failed at /tmp/tmpp5x9dytz.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpp5x9dytz.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp5x9dytz.jl:16\ntest set: Test Failed at /tmp/tmpp5x9dytz.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpp5x9dytz.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp5x9dytz.jl:16\ntest set: Test Failed at /tmp/tmpp5x9dytz.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpp5x9dytz.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp5x9dytz.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp5x9dytz.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwbmdah2s.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpwbmdah2s.jl:10\n\
    \   [2] top-level scope at /tmp/tmpwbmdah2s.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwbmdah2s.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbmdah2s.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpwbmdah2s.jl:10\n\
    \   [2] top-level scope at /tmp/tmpwbmdah2s.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwbmdah2s.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbmdah2s.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpwbmdah2s.jl:10\n\
    \   [2] top-level scope at /tmp/tmpwbmdah2s.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwbmdah2s.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpwbmdah2s.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpwbmdah2s.jl:10\n\
    \   [2] top-level scope at /tmp/tmpwbmdah2s.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwbmdah2s.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwbmdah2s.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpba_23yjl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpba_23yjl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpba_23yjl.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba_23yjl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpba_23yjl.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpba_23yjl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpba_23yjl.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba_23yjl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpba_23yjl.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpba_23yjl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpba_23yjl.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba_23yjl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpba_23yjl.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpba_23yjl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpba_23yjl.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba_23yjl.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpba_23yjl.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpapvs5hr7.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpapvs5hr7.jl:10\n\
    \   [2] top-level scope at /tmp/tmpapvs5hr7.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpapvs5hr7.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpapvs5hr7.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpapvs5hr7.jl:10\n\
    \   [2] top-level scope at /tmp/tmpapvs5hr7.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpapvs5hr7.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpapvs5hr7.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpapvs5hr7.jl:10\n\
    \   [2] top-level scope at /tmp/tmpapvs5hr7.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpapvs5hr7.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpapvs5hr7.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpapvs5hr7.jl:10\n\
    \   [2] top-level scope at /tmp/tmpapvs5hr7.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpapvs5hr7.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpapvs5hr7.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp6z6hylcz.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp6z6hylcz.jl:10\\\
    n   [2] top-level scope at /tmp/tmp6z6hylcz.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6z6hylcz.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6z6hylcz.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp6z6hylcz.jl:10\\\
    n   [2] top-level scope at /tmp/tmp6z6hylcz.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6z6hylcz.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6z6hylcz.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp6z6hylcz.jl:10\\\
    n   [2] top-level scope at /tmp/tmp6z6hylcz.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6z6hylcz.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6z6hylcz.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp6z6hylcz.jl:10\\\
    n   [2] top-level scope at /tmp/tmp6z6hylcz.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6z6hylcz.jl:15\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsfb7ljj4.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsfb7ljj4.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsfb7ljj4.jl:16\ntest set: Test Failed at /tmp/tmpsfb7ljj4.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpsfb7ljj4.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsfb7ljj4.jl:16\ntest set: Test Failed at /tmp/tmpsfb7ljj4.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpsfb7ljj4.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsfb7ljj4.jl:16\ntest set: Test Failed at /tmp/tmpsfb7ljj4.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpsfb7ljj4.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsfb7ljj4.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsfb7ljj4.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsiic865p.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsiic865p.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsiic865p.jl:16\ntest set: Test Failed at /tmp/tmpsiic865p.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpsiic865p.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsiic865p.jl:16\ntest set: Test Failed at /tmp/tmpsiic865p.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpsiic865p.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsiic865p.jl:16\ntest set: Test Failed at /tmp/tmpsiic865p.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpsiic865p.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsiic865p.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsiic865p.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpxdygfv7n.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxdygfv7n.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxdygfv7n.jl:16\\ntest set: Test Failed at /tmp/tmpxdygfv7n.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxdygfv7n.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxdygfv7n.jl:16\\ntest set: Test Failed at /tmp/tmpxdygfv7n.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxdygfv7n.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxdygfv7n.jl:16\\ntest set: Test Failed at /tmp/tmpxdygfv7n.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpxdygfv7n.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxdygfv7n.jl:16\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb1hptehk.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb1hptehk.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb1hptehk.jl:16\ntest set: Test Failed at /tmp/tmpb1hptehk.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpb1hptehk.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb1hptehk.jl:16\ntest set: Test Failed at /tmp/tmpb1hptehk.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpb1hptehk.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb1hptehk.jl:16\ntest set: Test Failed at /tmp/tmpb1hptehk.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpb1hptehk.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb1hptehk.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb1hptehk.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdg8vv_t8.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdg8vv_t8.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdg8vv_t8.jl:16\ntest set: Test Failed at /tmp/tmpdg8vv_t8.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpdg8vv_t8.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdg8vv_t8.jl:16\ntest set: Test Failed at /tmp/tmpdg8vv_t8.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpdg8vv_t8.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdg8vv_t8.jl:16\ntest set: Test Failed at /tmp/tmpdg8vv_t8.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpdg8vv_t8.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdg8vv_t8.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdg8vv_t8.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8cua9y8i.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp8cua9y8i.jl:10\\\
    n   [2] top-level scope at /tmp/tmp8cua9y8i.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8cua9y8i.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8cua9y8i.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp8cua9y8i.jl:10\\\
    n   [2] top-level scope at /tmp/tmp8cua9y8i.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8cua9y8i.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8cua9y8i.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp8cua9y8i.jl:10\\\
    n   [2] top-level scope at /tmp/tmp8cua9y8i.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8cua9y8i.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8cua9y8i.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp8cua9y8i.jl:10\\\
    n   [2] top-level scope at /tmp/tmp8cua9y8i.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8cua9y8i.jl:15\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpiiur9dlu.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpiiur9dlu.jl:10\n\
    \   [2] top-level scope at /tmp/tmpiiur9dlu.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiiur9dlu.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpiiur9dlu.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpiiur9dlu.jl:10\n\
    \   [2] top-level scope at /tmp/tmpiiur9dlu.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiiur9dlu.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpiiur9dlu.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpiiur9dlu.jl:10\n\
    \   [2] top-level scope at /tmp/tmpiiur9dlu.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiiur9dlu.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpiiur9dlu.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpiiur9dlu.jl:10\n\
    \   [2] top-level scope at /tmp/tmpiiur9dlu.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiiur9dlu.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiiur9dlu.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \")(\" => \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu5kzs_uz.jl:20\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpu5kzs_uz.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu5kzs_uz.jl:19\ntest set: Test Failed at /tmp/tmpu5kzs_uz.jl:22\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()\", \"(())\", \"((())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpu5kzs_uz.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu5kzs_uz.jl:19\ntest set: Test Failed at /tmp/tmpu5kzs_uz.jl:23\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()\", \"())\"] == [\"()\", \"(())\", \"\
    (()())\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpu5kzs_uz.jl:23\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu5kzs_uz.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu5kzs_uz.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpn6ljyfkf.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpn6ljyfkf.jl:10\n\
    \   [2] top-level scope at /tmp/tmpn6ljyfkf.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn6ljyfkf.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpn6ljyfkf.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpn6ljyfkf.jl:10\n\
    \   [2] top-level scope at /tmp/tmpn6ljyfkf.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn6ljyfkf.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpn6ljyfkf.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpn6ljyfkf.jl:10\n\
    \   [2] top-level scope at /tmp/tmpn6ljyfkf.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn6ljyfkf.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpn6ljyfkf.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpn6ljyfkf.jl:10\n\
    \   [2] top-level scope at /tmp/tmpn6ljyfkf.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn6ljyfkf.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn6ljyfkf.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = []\n    paren_group = \"\"\n    open_parens = 0\n    for c in paren_string\n\
    \        if c == '('\n            open_parens += 1\n        elseif c == ')'\n\
    \            open_parens -= 1\n        end\n        paren_group *= c\n       \
    \ if open_parens == 0\n            push!(paren_groups, paren_group)\n        \
    \    paren_group = \"\"\n        end\n    end\n    return paren_groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpoo8bz0gl.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpoo8bz0gl.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoo8bz0gl.jl:16\\ntest set: Test Failed at /tmp/tmpoo8bz0gl.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpoo8bz0gl.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoo8bz0gl.jl:16\\ntest set: Test Failed at /tmp/tmpoo8bz0gl.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpoo8bz0gl.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoo8bz0gl.jl:16\\ntest set: Test Failed at /tmp/tmpoo8bz0gl.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpoo8bz0gl.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoo8bz0gl.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmptmzptfs4.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmptmzptfs4.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptmzptfs4.jl:16\\ntest set: Test Failed at /tmp/tmptmzptfs4.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmptmzptfs4.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptmzptfs4.jl:16\\ntest set: Test Failed at /tmp/tmptmzptfs4.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmptmzptfs4.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptmzptfs4.jl:16\\ntest set: Test Failed at /tmp/tmptmzptfs4.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmptmzptfs4.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptmzptfs4.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8mllsv5r.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp8mllsv5r.jl:10\n\
    \   [2] top-level scope at /tmp/tmp8mllsv5r.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8mllsv5r.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp8mllsv5r.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp8mllsv5r.jl:10\n\
    \   [2] top-level scope at /tmp/tmp8mllsv5r.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8mllsv5r.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp8mllsv5r.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp8mllsv5r.jl:10\n\
    \   [2] top-level scope at /tmp/tmp8mllsv5r.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8mllsv5r.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp8mllsv5r.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp8mllsv5r.jl:10\n\
    \   [2] top-level scope at /tmp/tmp8mllsv5r.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8mllsv5r.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8mllsv5r.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkoa56jbg.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkoa56jbg.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkoa56jbg.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkoa56jbg.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpkoa56jbg.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkoa56jbg.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkoa56jbg.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkoa56jbg.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpkoa56jbg.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkoa56jbg.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkoa56jbg.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkoa56jbg.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpkoa56jbg.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkoa56jbg.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkoa56jbg.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkoa56jbg.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkoa56jbg.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8zutp67u.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8zutp67u.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zutp67u.jl:16\ntest set: Test Failed at /tmp/tmp8zutp67u.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp8zutp67u.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zutp67u.jl:16\ntest set: Test Failed at /tmp/tmp8zutp67u.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp8zutp67u.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zutp67u.jl:16\ntest set: Test Failed at /tmp/tmp8zutp67u.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp8zutp67u.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zutp67u.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8zutp67u.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: write code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpr9n6lvfe.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpr9n6lvfe.jl:10\n\
    \   [2] top-level scope at /tmp/tmpr9n6lvfe.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr9n6lvfe.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpr9n6lvfe.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpr9n6lvfe.jl:10\n\
    \   [2] top-level scope at /tmp/tmpr9n6lvfe.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr9n6lvfe.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpr9n6lvfe.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpr9n6lvfe.jl:10\n\
    \   [2] top-level scope at /tmp/tmpr9n6lvfe.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr9n6lvfe.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpr9n6lvfe.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpr9n6lvfe.jl:10\n\
    \   [2] top-level scope at /tmp/tmpr9n6lvfe.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr9n6lvfe.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr9n6lvfe.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8b_x7gs7.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp8b_x7gs7.jl:10\n\
    \   [2] top-level scope at /tmp/tmp8b_x7gs7.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b_x7gs7.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp8b_x7gs7.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp8b_x7gs7.jl:10\n\
    \   [2] top-level scope at /tmp/tmp8b_x7gs7.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b_x7gs7.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp8b_x7gs7.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp8b_x7gs7.jl:10\n\
    \   [2] top-level scope at /tmp/tmp8b_x7gs7.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b_x7gs7.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp8b_x7gs7.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp8b_x7gs7.jl:10\n\
    \   [2] top-level scope at /tmp/tmp8b_x7gs7.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8b_x7gs7.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8b_x7gs7.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp54y5z5nj.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp54y5z5nj.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp54y5z5nj.jl:16\ntest set: Test Failed at /tmp/tmp54y5z5nj.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp54y5z5nj.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp54y5z5nj.jl:16\ntest set: Test Failed at /tmp/tmp54y5z5nj.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp54y5z5nj.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp54y5z5nj.jl:16\ntest set: Test Failed at /tmp/tmp54y5z5nj.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp54y5z5nj.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp54y5z5nj.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp54y5z5nj.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbzok48nu.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpbzok48nu.jl:10\n\
    \   [2] top-level scope at /tmp/tmpbzok48nu.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbzok48nu.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpbzok48nu.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpbzok48nu.jl:10\n\
    \   [2] top-level scope at /tmp/tmpbzok48nu.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbzok48nu.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpbzok48nu.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpbzok48nu.jl:10\n\
    \   [2] top-level scope at /tmp/tmpbzok48nu.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbzok48nu.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpbzok48nu.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpbzok48nu.jl:10\n\
    \   [2] top-level scope at /tmp/tmpbzok48nu.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbzok48nu.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbzok48nu.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return Vector{String}()\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6mk6j7km.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6mk6j7km.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6mk6j7km.jl:16\ntest set: Test Failed at /tmp/tmp6mk6j7km.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp6mk6j7km.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6mk6j7km.jl:16\ntest set: Test Failed at /tmp/tmp6mk6j7km.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp6mk6j7km.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6mk6j7km.jl:16\ntest set: Test Failed at /tmp/tmp6mk6j7km.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp6mk6j7km.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6mk6j7km.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6mk6j7km.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1w5_3x8t.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1w5_3x8t.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1w5_3x8t.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1w5_3x8t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp1w5_3x8t.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1w5_3x8t.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1w5_3x8t.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1w5_3x8t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp1w5_3x8t.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1w5_3x8t.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1w5_3x8t.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1w5_3x8t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp1w5_3x8t.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1w5_3x8t.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1w5_3x8t.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1w5_3x8t.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1w5_3x8t.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprd1vq_r3.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmprd1vq_r3.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprd1vq_r3.jl:16\ntest set: Test Failed at /tmp/tmprd1vq_r3.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmprd1vq_r3.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprd1vq_r3.jl:16\ntest set: Test Failed at /tmp/tmprd1vq_r3.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmprd1vq_r3.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprd1vq_r3.jl:16\ntest set: Test Failed at /tmp/tmprd1vq_r3.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmprd1vq_r3.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprd1vq_r3.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprd1vq_r3.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqtdjffl3.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqtdjffl3.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqtdjffl3.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqtdjffl3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpqtdjffl3.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqtdjffl3.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqtdjffl3.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqtdjffl3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpqtdjffl3.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqtdjffl3.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqtdjffl3.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqtdjffl3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpqtdjffl3.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqtdjffl3.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqtdjffl3.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqtdjffl3.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqtdjffl3.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph4_ivez4.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmph4_ivez4.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph4_ivez4.jl:16\ntest set: Test Failed at /tmp/tmph4_ivez4.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmph4_ivez4.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph4_ivez4.jl:16\ntest set: Test Failed at /tmp/tmph4_ivez4.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmph4_ivez4.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph4_ivez4.jl:16\ntest set: Test Failed at /tmp/tmph4_ivez4.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmph4_ivez4.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph4_ivez4.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph4_ivez4.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpj09tsk57.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj09tsk57.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj09tsk57.jl:16\\ntest set: Test Failed at /tmp/tmpj09tsk57.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj09tsk57.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj09tsk57.jl:16\\ntest set: Test Failed at /tmp/tmpj09tsk57.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj09tsk57.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj09tsk57.jl:16\\ntest set: Test Failed at /tmp/tmpj09tsk57.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpj09tsk57.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj09tsk57.jl:16\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd000bhe0.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpd000bhe0.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd000bhe0.jl:16\ntest set: Test Failed at /tmp/tmpd000bhe0.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpd000bhe0.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd000bhe0.jl:16\ntest set: Test Failed at /tmp/tmpd000bhe0.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpd000bhe0.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd000bhe0.jl:16\ntest set: Test Failed at /tmp/tmpd000bhe0.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpd000bhe0.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd000bhe0.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd000bhe0.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpoy28d3lh.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpoy28d3lh.jl:10\n\
    \   [2] top-level scope at /tmp/tmpoy28d3lh.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoy28d3lh.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpoy28d3lh.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpoy28d3lh.jl:10\n\
    \   [2] top-level scope at /tmp/tmpoy28d3lh.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoy28d3lh.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpoy28d3lh.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpoy28d3lh.jl:10\n\
    \   [2] top-level scope at /tmp/tmpoy28d3lh.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoy28d3lh.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpoy28d3lh.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpoy28d3lh.jl:10\n\
    \   [2] top-level scope at /tmp/tmpoy28d3lh.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoy28d3lh.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoy28d3lh.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzz2u2ulm.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpzz2u2ulm.jl:10\n\
    \   [2] top-level scope at /tmp/tmpzz2u2ulm.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz2u2ulm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz2u2ulm.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpzz2u2ulm.jl:10\n\
    \   [2] top-level scope at /tmp/tmpzz2u2ulm.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz2u2ulm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz2u2ulm.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpzz2u2ulm.jl:10\n\
    \   [2] top-level scope at /tmp/tmpzz2u2ulm.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz2u2ulm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpzz2u2ulm.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpzz2u2ulm.jl:10\n\
    \   [2] top-level scope at /tmp/tmpzz2u2ulm.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzz2u2ulm.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzz2u2ulm.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpq4gcl144.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq4gcl144.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq4gcl144.jl:16\\ntest set: Test Failed at /tmp/tmpq4gcl144.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq4gcl144.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq4gcl144.jl:16\\ntest set: Test Failed at /tmp/tmpq4gcl144.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq4gcl144.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq4gcl144.jl:16\\ntest set: Test Failed at /tmp/tmpq4gcl144.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpq4gcl144.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq4gcl144.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpm4is99rd.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpm4is99rd.jl:10\n\
    \   [2] top-level scope at /tmp/tmpm4is99rd.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4is99rd.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4is99rd.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpm4is99rd.jl:10\n\
    \   [2] top-level scope at /tmp/tmpm4is99rd.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4is99rd.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4is99rd.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpm4is99rd.jl:10\n\
    \   [2] top-level scope at /tmp/tmpm4is99rd.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4is99rd.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpm4is99rd.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpm4is99rd.jl:10\n\
    \   [2] top-level scope at /tmp/tmpm4is99rd.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm4is99rd.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm4is99rd.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmprxiqvaoa.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmprxiqvaoa.jl:10\\\
    n   [2] top-level scope at /tmp/tmprxiqvaoa.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprxiqvaoa.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprxiqvaoa.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmprxiqvaoa.jl:10\\\
    n   [2] top-level scope at /tmp/tmprxiqvaoa.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprxiqvaoa.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprxiqvaoa.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmprxiqvaoa.jl:10\\\
    n   [2] top-level scope at /tmp/tmprxiqvaoa.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprxiqvaoa.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprxiqvaoa.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmprxiqvaoa.jl:10\\\
    n   [2] top-level scope at /tmp/tmprxiqvaoa.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprxiqvaoa.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvkngilb4.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpvkngilb4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpvkngilb4.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvkngilb4.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpvkngilb4.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpvkngilb4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpvkngilb4.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvkngilb4.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpvkngilb4.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpvkngilb4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpvkngilb4.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvkngilb4.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpvkngilb4.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpvkngilb4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpvkngilb4.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpvkngilb4.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvkngilb4.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpklnyod5h.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpklnyod5h.jl:10\\\
    n   [2] top-level scope at /tmp/tmpklnyod5h.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpklnyod5h.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpklnyod5h.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpklnyod5h.jl:10\\\
    n   [2] top-level scope at /tmp/tmpklnyod5h.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpklnyod5h.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpklnyod5h.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpklnyod5h.jl:10\\\
    n   [2] top-level scope at /tmp/tmpklnyod5h.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpklnyod5h.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpklnyod5h.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpklnyod5h.jl:10\\\
    n   [2] top-level scope at /tmp/tmpklnyod5h.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpklnyod5h.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmplppussnr.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmplppussnr.jl:10\n\
    \   [2] top-level scope at /tmp/tmplppussnr.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplppussnr.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmplppussnr.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmplppussnr.jl:10\n\
    \   [2] top-level scope at /tmp/tmplppussnr.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplppussnr.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmplppussnr.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmplppussnr.jl:10\n\
    \   [2] top-level scope at /tmp/tmplppussnr.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplppussnr.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmplppussnr.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmplppussnr.jl:10\n\
    \   [2] top-level scope at /tmp/tmplppussnr.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplppussnr.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplppussnr.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp9l773i1_.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9l773i1_.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9l773i1_.jl:16\\ntest set: Test Failed at /tmp/tmp9l773i1_.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9l773i1_.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9l773i1_.jl:16\\ntest set: Test Failed at /tmp/tmp9l773i1_.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9l773i1_.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9l773i1_.jl:16\\ntest set: Test Failed at /tmp/tmp9l773i1_.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp9l773i1_.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9l773i1_.jl:16\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj72a7alo.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpj72a7alo.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj72a7alo.jl:16\ntest set: Test Failed at /tmp/tmpj72a7alo.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpj72a7alo.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj72a7alo.jl:16\ntest set: Test Failed at /tmp/tmpj72a7alo.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpj72a7alo.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj72a7alo.jl:16\ntest set: Test Failed at /tmp/tmpj72a7alo.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpj72a7alo.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj72a7alo.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj72a7alo.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpckrnokps.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpckrnokps.jl:10\n\
    \   [2] top-level scope at /tmp/tmpckrnokps.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpckrnokps.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpckrnokps.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpckrnokps.jl:10\n\
    \   [2] top-level scope at /tmp/tmpckrnokps.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpckrnokps.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpckrnokps.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpckrnokps.jl:10\n\
    \   [2] top-level scope at /tmp/tmpckrnokps.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpckrnokps.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpckrnokps.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpckrnokps.jl:10\n\
    \   [2] top-level scope at /tmp/tmpckrnokps.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpckrnokps.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpckrnokps.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpalzlv650.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpalzlv650.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpalzlv650.jl:16\\ntest set: Test Failed at /tmp/tmpalzlv650.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpalzlv650.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpalzlv650.jl:16\\ntest set: Test Failed at /tmp/tmpalzlv650.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpalzlv650.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpalzlv650.jl:16\\ntest set: Test Failed at /tmp/tmpalzlv650.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpalzlv650.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpalzlv650.jl:16\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoevoofyw.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpoevoofyw.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoevoofyw.jl:16\ntest set: Test Failed at /tmp/tmpoevoofyw.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpoevoofyw.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoevoofyw.jl:16\ntest set: Test Failed at /tmp/tmpoevoofyw.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpoevoofyw.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoevoofyw.jl:16\ntest set: Test Failed at /tmp/tmpoevoofyw.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpoevoofyw.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoevoofyw.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoevoofyw.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgfpsnv26.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpgfpsnv26.jl:10\n\
    \   [2] top-level scope at /tmp/tmpgfpsnv26.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgfpsnv26.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpgfpsnv26.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpgfpsnv26.jl:10\n\
    \   [2] top-level scope at /tmp/tmpgfpsnv26.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgfpsnv26.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpgfpsnv26.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpgfpsnv26.jl:10\n\
    \   [2] top-level scope at /tmp/tmpgfpsnv26.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgfpsnv26.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpgfpsnv26.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpgfpsnv26.jl:10\n\
    \   [2] top-level scope at /tmp/tmpgfpsnv26.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgfpsnv26.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgfpsnv26.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7z1nuabm.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp7z1nuabm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp7z1nuabm.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7z1nuabm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp7z1nuabm.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp7z1nuabm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp7z1nuabm.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7z1nuabm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp7z1nuabm.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp7z1nuabm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp7z1nuabm.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7z1nuabm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp7z1nuabm.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp7z1nuabm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp7z1nuabm.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7z1nuabm.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7z1nuabm.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp10ua8zzf.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp10ua8zzf.jl:10\n\
    \   [2] top-level scope at /tmp/tmp10ua8zzf.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp10ua8zzf.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp10ua8zzf.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp10ua8zzf.jl:10\n\
    \   [2] top-level scope at /tmp/tmp10ua8zzf.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp10ua8zzf.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp10ua8zzf.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp10ua8zzf.jl:10\n\
    \   [2] top-level scope at /tmp/tmp10ua8zzf.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp10ua8zzf.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp10ua8zzf.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp10ua8zzf.jl:10\n\
    \   [2] top-level scope at /tmp/tmp10ua8zzf.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp10ua8zzf.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp10ua8zzf.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx9u3cv1g.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpx9u3cv1g.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9u3cv1g.jl:16\ntest set: Test Failed at /tmp/tmpx9u3cv1g.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpx9u3cv1g.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9u3cv1g.jl:16\ntest set: Test Failed at /tmp/tmpx9u3cv1g.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpx9u3cv1g.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9u3cv1g.jl:16\ntest set: Test Failed at /tmp/tmpx9u3cv1g.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpx9u3cv1g.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9u3cv1g.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx9u3cv1g.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpng37bdl7.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpng37bdl7.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpng37bdl7.jl:16\ntest set: Test Failed at /tmp/tmpng37bdl7.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpng37bdl7.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpng37bdl7.jl:16\ntest set: Test Failed at /tmp/tmpng37bdl7.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpng37bdl7.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpng37bdl7.jl:16\ntest set: Test Failed at /tmp/tmpng37bdl7.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpng37bdl7.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpng37bdl7.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpng37bdl7.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpypglj3bx.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpypglj3bx.jl:10\n\
    \   [2] top-level scope at /tmp/tmpypglj3bx.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpypglj3bx.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpypglj3bx.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpypglj3bx.jl:10\n\
    \   [2] top-level scope at /tmp/tmpypglj3bx.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpypglj3bx.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpypglj3bx.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpypglj3bx.jl:10\n\
    \   [2] top-level scope at /tmp/tmpypglj3bx.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpypglj3bx.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpypglj3bx.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpypglj3bx.jl:10\n\
    \   [2] top-level scope at /tmp/tmpypglj3bx.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpypglj3bx.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpypglj3bx.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2qi8z9xd.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp2qi8z9xd.jl:10\n\
    \   [2] top-level scope at /tmp/tmp2qi8z9xd.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2qi8z9xd.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp2qi8z9xd.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp2qi8z9xd.jl:10\n\
    \   [2] top-level scope at /tmp/tmp2qi8z9xd.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2qi8z9xd.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp2qi8z9xd.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp2qi8z9xd.jl:10\n\
    \   [2] top-level scope at /tmp/tmp2qi8z9xd.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2qi8z9xd.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp2qi8z9xd.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp2qi8z9xd.jl:10\n\
    \   [2] top-level scope at /tmp/tmp2qi8z9xd.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2qi8z9xd.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2qi8z9xd.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpgt37ve0o.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgt37ve0o.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgt37ve0o.jl:16\\ntest set: Test Failed at /tmp/tmpgt37ve0o.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgt37ve0o.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgt37ve0o.jl:16\\ntest set: Test Failed at /tmp/tmpgt37ve0o.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgt37ve0o.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgt37ve0o.jl:16\\ntest set: Test Failed at /tmp/tmpgt37ve0o.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpgt37ve0o.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgt37ve0o.jl:16\\nTest Summary: | Fail  '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpugphind4.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpugphind4.jl:10\\\
    n   [2] top-level scope at /tmp/tmpugphind4.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpugphind4.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpugphind4.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpugphind4.jl:10\\\
    n   [2] top-level scope at /tmp/tmpugphind4.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpugphind4.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpugphind4.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpugphind4.jl:10\\\
    n   [2] top-level scope at /tmp/tmpugphind4.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpugphind4.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpugphind4.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpugphind4.jl:10\\\
    n   [2] top-level scope at /tmp/tmpugphind4.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpugphind4.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmplcuikyvw.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmplcuikyvw.jl:10\\\
    n   [2] top-level scope at /tmp/tmplcuikyvw.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplcuikyvw.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplcuikyvw.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmplcuikyvw.jl:10\\\
    n   [2] top-level scope at /tmp/tmplcuikyvw.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplcuikyvw.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplcuikyvw.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmplcuikyvw.jl:10\\\
    n   [2] top-level scope at /tmp/tmplcuikyvw.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplcuikyvw.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplcuikyvw.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmplcuikyvw.jl:10\\\
    n   [2] top-level scope at /tmp/tmplcuikyvw.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplcuikyvw.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphnh0xceq.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphnh0xceq.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphnh0xceq.jl:16\ntest set: Test Failed at /tmp/tmphnh0xceq.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmphnh0xceq.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphnh0xceq.jl:16\ntest set: Test Failed at /tmp/tmphnh0xceq.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmphnh0xceq.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphnh0xceq.jl:16\ntest set: Test Failed at /tmp/tmphnh0xceq.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmphnh0xceq.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphnh0xceq.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphnh0xceq.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprw6tkoi2.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmprw6tkoi2.jl:10\n\
    \   [2] top-level scope at /tmp/tmprw6tkoi2.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprw6tkoi2.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmprw6tkoi2.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmprw6tkoi2.jl:10\n\
    \   [2] top-level scope at /tmp/tmprw6tkoi2.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprw6tkoi2.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmprw6tkoi2.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmprw6tkoi2.jl:10\n\
    \   [2] top-level scope at /tmp/tmprw6tkoi2.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprw6tkoi2.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmprw6tkoi2.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmprw6tkoi2.jl:10\n\
    \   [2] top-level scope at /tmp/tmprw6tkoi2.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprw6tkoi2.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprw6tkoi2.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpc0cqp78a.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpc0cqp78a.jl:10\n\
    \   [2] top-level scope at /tmp/tmpc0cqp78a.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc0cqp78a.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpc0cqp78a.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpc0cqp78a.jl:10\n\
    \   [2] top-level scope at /tmp/tmpc0cqp78a.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc0cqp78a.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpc0cqp78a.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpc0cqp78a.jl:10\n\
    \   [2] top-level scope at /tmp/tmpc0cqp78a.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc0cqp78a.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpc0cqp78a.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpc0cqp78a.jl:10\n\
    \   [2] top-level scope at /tmp/tmpc0cqp78a.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpc0cqp78a.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc0cqp78a.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpcgs0hek4.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpcgs0hek4.jl:10\\\
    n   [2] top-level scope at /tmp/tmpcgs0hek4.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpcgs0hek4.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpcgs0hek4.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpcgs0hek4.jl:10\\\
    n   [2] top-level scope at /tmp/tmpcgs0hek4.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpcgs0hek4.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpcgs0hek4.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpcgs0hek4.jl:10\\\
    n   [2] top-level scope at /tmp/tmpcgs0hek4.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpcgs0hek4.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpcgs0hek4.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpcgs0hek4.jl:10\\\
    n   [2] top-level scope at /tmp/tmpcgs0hek4.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpcgs0hek4.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6tbr60am.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6tbr60am.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6tbr60am.jl:16\ntest set: Test Failed at /tmp/tmp6tbr60am.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp6tbr60am.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6tbr60am.jl:16\ntest set: Test Failed at /tmp/tmp6tbr60am.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp6tbr60am.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6tbr60am.jl:16\ntest set: Test Failed at /tmp/tmp6tbr60am.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp6tbr60am.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6tbr60am.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6tbr60am.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3sdzngc1.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp3sdzngc1.jl:10\n\
    \   [2] top-level scope at /tmp/tmp3sdzngc1.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3sdzngc1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp3sdzngc1.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp3sdzngc1.jl:10\n\
    \   [2] top-level scope at /tmp/tmp3sdzngc1.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3sdzngc1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp3sdzngc1.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp3sdzngc1.jl:10\n\
    \   [2] top-level scope at /tmp/tmp3sdzngc1.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3sdzngc1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp3sdzngc1.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp3sdzngc1.jl:10\n\
    \   [2] top-level scope at /tmp/tmp3sdzngc1.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3sdzngc1.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3sdzngc1.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp49k88k1e.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp49k88k1e.jl:10\n\
    \   [2] top-level scope at /tmp/tmp49k88k1e.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp49k88k1e.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp49k88k1e.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp49k88k1e.jl:10\n\
    \   [2] top-level scope at /tmp/tmp49k88k1e.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp49k88k1e.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp49k88k1e.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp49k88k1e.jl:10\n\
    \   [2] top-level scope at /tmp/tmp49k88k1e.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp49k88k1e.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp49k88k1e.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp49k88k1e.jl:10\n\
    \   [2] top-level scope at /tmp/tmp49k88k1e.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp49k88k1e.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp49k88k1e.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkeery2cx.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkeery2cx.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkeery2cx.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkeery2cx.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpkeery2cx.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkeery2cx.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkeery2cx.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkeery2cx.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpkeery2cx.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkeery2cx.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkeery2cx.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkeery2cx.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpkeery2cx.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkeery2cx.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkeery2cx.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkeery2cx.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkeery2cx.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpba38so04.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpba38so04.jl:10\n\
    \   [2] top-level scope at /tmp/tmpba38so04.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba38so04.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpba38so04.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpba38so04.jl:10\n\
    \   [2] top-level scope at /tmp/tmpba38so04.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba38so04.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpba38so04.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpba38so04.jl:10\n\
    \   [2] top-level scope at /tmp/tmpba38so04.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba38so04.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpba38so04.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpba38so04.jl:10\n\
    \   [2] top-level scope at /tmp/tmpba38so04.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpba38so04.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpba38so04.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqeispl86.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpqeispl86.jl:10\\\
    n   [2] top-level scope at /tmp/tmpqeispl86.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqeispl86.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqeispl86.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpqeispl86.jl:10\\\
    n   [2] top-level scope at /tmp/tmpqeispl86.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqeispl86.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqeispl86.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpqeispl86.jl:10\\\
    n   [2] top-level scope at /tmp/tmpqeispl86.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqeispl86.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqeispl86.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpqeispl86.jl:10\\\
    n   [2] top-level scope at /tmp/tmpqeispl86.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqeispl86.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpqeispl86.jl:13\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0q69_v4j.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0q69_v4j.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0q69_v4j.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0q69_v4j.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp0q69_v4j.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0q69_v4j.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0q69_v4j.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0q69_v4j.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp0q69_v4j.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0q69_v4j.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0q69_v4j.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0q69_v4j.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp0q69_v4j.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0q69_v4j.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0q69_v4j.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0q69_v4j.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0q69_v4j.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk4qxhiqw.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpk4qxhiqw.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4qxhiqw.jl:16\ntest set: Test Failed at /tmp/tmpk4qxhiqw.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpk4qxhiqw.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4qxhiqw.jl:16\ntest set: Test Failed at /tmp/tmpk4qxhiqw.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpk4qxhiqw.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4qxhiqw.jl:16\ntest set: Test Failed at /tmp/tmpk4qxhiqw.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpk4qxhiqw.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk4qxhiqw.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk4qxhiqw.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpw2gzalc1.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpw2gzalc1.jl:10\n\
    \   [2] top-level scope at /tmp/tmpw2gzalc1.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw2gzalc1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpw2gzalc1.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpw2gzalc1.jl:10\n\
    \   [2] top-level scope at /tmp/tmpw2gzalc1.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw2gzalc1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpw2gzalc1.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpw2gzalc1.jl:10\n\
    \   [2] top-level scope at /tmp/tmpw2gzalc1.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw2gzalc1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpw2gzalc1.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpw2gzalc1.jl:10\n\
    \   [2] top-level scope at /tmp/tmpw2gzalc1.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw2gzalc1.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw2gzalc1.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8gbiga0q.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8gbiga0q.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8gbiga0q.jl:16\ntest set: Test Failed at /tmp/tmp8gbiga0q.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp8gbiga0q.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8gbiga0q.jl:16\ntest set: Test Failed at /tmp/tmp8gbiga0q.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp8gbiga0q.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8gbiga0q.jl:16\ntest set: Test Failed at /tmp/tmp8gbiga0q.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp8gbiga0q.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8gbiga0q.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8gbiga0q.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpihad_4gs.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpihad_4gs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpihad_4gs.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpihad_4gs.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpihad_4gs.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpihad_4gs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpihad_4gs.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpihad_4gs.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpihad_4gs.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpihad_4gs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpihad_4gs.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpihad_4gs.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpihad_4gs.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpihad_4gs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpihad_4gs.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpihad_4gs.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpihad_4gs.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9v7s8gxt.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp9v7s8gxt.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9v7s8gxt.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9v7s8gxt.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp9v7s8gxt.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp9v7s8gxt.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9v7s8gxt.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9v7s8gxt.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp9v7s8gxt.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp9v7s8gxt.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9v7s8gxt.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9v7s8gxt.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp9v7s8gxt.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp9v7s8gxt.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9v7s8gxt.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9v7s8gxt.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9v7s8gxt.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj4ehl4ch.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpj4ehl4ch.jl:10\n\
    \   [2] top-level scope at /tmp/tmpj4ehl4ch.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4ehl4ch.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4ehl4ch.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpj4ehl4ch.jl:10\n\
    \   [2] top-level scope at /tmp/tmpj4ehl4ch.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4ehl4ch.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4ehl4ch.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpj4ehl4ch.jl:10\n\
    \   [2] top-level scope at /tmp/tmpj4ehl4ch.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4ehl4ch.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4ehl4ch.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpj4ehl4ch.jl:10\n\
    \   [2] top-level scope at /tmp/tmpj4ehl4ch.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4ehl4ch.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj4ehl4ch.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm2sp_ugo.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpm2sp_ugo.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm2sp_ugo.jl:16\ntest set: Test Failed at /tmp/tmpm2sp_ugo.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpm2sp_ugo.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm2sp_ugo.jl:16\ntest set: Test Failed at /tmp/tmpm2sp_ugo.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpm2sp_ugo.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm2sp_ugo.jl:16\ntest set: Test Failed at /tmp/tmpm2sp_ugo.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpm2sp_ugo.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm2sp_ugo.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm2sp_ugo.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv7kt8g5i.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpv7kt8g5i.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7kt8g5i.jl:16\ntest set: Test Failed at /tmp/tmpv7kt8g5i.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpv7kt8g5i.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7kt8g5i.jl:16\ntest set: Test Failed at /tmp/tmpv7kt8g5i.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpv7kt8g5i.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7kt8g5i.jl:16\ntest set: Test Failed at /tmp/tmpv7kt8g5i.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpv7kt8g5i.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv7kt8g5i.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv7kt8g5i.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw85otxdg.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw85otxdg.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw85otxdg.jl:16\ntest set: Test Failed at /tmp/tmpw85otxdg.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpw85otxdg.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw85otxdg.jl:16\ntest set: Test Failed at /tmp/tmpw85otxdg.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpw85otxdg.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw85otxdg.jl:16\ntest set: Test Failed at /tmp/tmpw85otxdg.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpw85otxdg.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw85otxdg.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw85otxdg.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpoyheyqm_.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpoyheyqm_.jl:10\\\
    n   [2] top-level scope at /tmp/tmpoyheyqm_.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpoyheyqm_.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpoyheyqm_.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpoyheyqm_.jl:10\\\
    n   [2] top-level scope at /tmp/tmpoyheyqm_.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpoyheyqm_.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpoyheyqm_.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpoyheyqm_.jl:10\\\
    n   [2] top-level scope at /tmp/tmpoyheyqm_.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpoyheyqm_.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpoyheyqm_.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpoyheyqm_.jl:10\\\
    n   [2] top-level scope at /tmp/tmpoyheyqm_.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpoyheyqm_.jl:15\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4v3eqacq.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4v3eqacq.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4v3eqacq.jl:16\ntest set: Test Failed at /tmp/tmp4v3eqacq.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp4v3eqacq.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4v3eqacq.jl:16\ntest set: Test Failed at /tmp/tmp4v3eqacq.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp4v3eqacq.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4v3eqacq.jl:16\ntest set: Test Failed at /tmp/tmp4v3eqacq.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp4v3eqacq.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4v3eqacq.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4v3eqacq.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: write your code here\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5itm2pg3.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5itm2pg3.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5itm2pg3.jl:16\ntest set: Test Failed at /tmp/tmp5itm2pg3.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp5itm2pg3.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5itm2pg3.jl:16\ntest set: Test Failed at /tmp/tmp5itm2pg3.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp5itm2pg3.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5itm2pg3.jl:16\ntest set: Test Failed at /tmp/tmp5itm2pg3.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp5itm2pg3.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5itm2pg3.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5itm2pg3.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9e_qtl69.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp9e_qtl69.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9e_qtl69.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9e_qtl69.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp9e_qtl69.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp9e_qtl69.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9e_qtl69.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9e_qtl69.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp9e_qtl69.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp9e_qtl69.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9e_qtl69.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9e_qtl69.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp9e_qtl69.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp9e_qtl69.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9e_qtl69.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9e_qtl69.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9e_qtl69.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpfybh1nt3.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfybh1nt3.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfybh1nt3.jl:16\\ntest set: Test Failed at /tmp/tmpfybh1nt3.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfybh1nt3.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfybh1nt3.jl:16\\ntest set: Test Failed at /tmp/tmpfybh1nt3.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfybh1nt3.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfybh1nt3.jl:16\\ntest set: Test Failed at /tmp/tmpfybh1nt3.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpfybh1nt3.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfybh1nt3.jl:16\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \")(\" => \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp8ul9_ke.jl:20\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpp8ul9_ke.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp8ul9_ke.jl:19\ntest set: Test Failed at /tmp/tmpp8ul9_ke.jl:22\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()\", \"(())\", \"((())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpp8ul9_ke.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp8ul9_ke.jl:19\ntest set: Test Failed at /tmp/tmpp8ul9_ke.jl:23\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()\", \"())\"] == [\"()\", \"(())\", \"\
    (()())\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpp8ul9_ke.jl:23\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp8ul9_ke.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp8ul9_ke.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxp2rneiz.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxp2rneiz.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxp2rneiz.jl:16\ntest set: Test Failed at /tmp/tmpxp2rneiz.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpxp2rneiz.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxp2rneiz.jl:16\ntest set: Test Failed at /tmp/tmpxp2rneiz.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpxp2rneiz.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxp2rneiz.jl:16\ntest set: Test Failed at /tmp/tmpxp2rneiz.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpxp2rneiz.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxp2rneiz.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxp2rneiz.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp42v7o_c6.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp42v7o_c6.jl:10\n\
    \   [2] top-level scope at /tmp/tmp42v7o_c6.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp42v7o_c6.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp42v7o_c6.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp42v7o_c6.jl:10\n\
    \   [2] top-level scope at /tmp/tmp42v7o_c6.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp42v7o_c6.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp42v7o_c6.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp42v7o_c6.jl:10\n\
    \   [2] top-level scope at /tmp/tmp42v7o_c6.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp42v7o_c6.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp42v7o_c6.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp42v7o_c6.jl:10\n\
    \   [2] top-level scope at /tmp/tmp42v7o_c6.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp42v7o_c6.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp42v7o_c6.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp9s3hw9n2.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9s3hw9n2.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9s3hw9n2.jl:16\\ntest set: Test Failed at /tmp/tmp9s3hw9n2.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9s3hw9n2.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9s3hw9n2.jl:16\\ntest set: Test Failed at /tmp/tmp9s3hw9n2.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9s3hw9n2.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9s3hw9n2.jl:16\\ntest set: Test Failed at /tmp/tmp9s3hw9n2.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp9s3hw9n2.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9s3hw9n2.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsbraqhdl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpsbraqhdl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpsbraqhdl.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsbraqhdl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpsbraqhdl.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpsbraqhdl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpsbraqhdl.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsbraqhdl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpsbraqhdl.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpsbraqhdl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpsbraqhdl.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsbraqhdl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpsbraqhdl.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpsbraqhdl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpsbraqhdl.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsbraqhdl.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsbraqhdl.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfzyfn9hs.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfzyfn9hs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfzyfn9hs.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfzyfn9hs.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfzyfn9hs.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfzyfn9hs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfzyfn9hs.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfzyfn9hs.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfzyfn9hs.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfzyfn9hs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfzyfn9hs.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfzyfn9hs.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfzyfn9hs.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfzyfn9hs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfzyfn9hs.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfzyfn9hs.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfzyfn9hs.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6oj7ox4d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp6oj7ox4d.jl:10\n\
    \   [2] top-level scope at /tmp/tmp6oj7ox4d.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6oj7ox4d.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp6oj7ox4d.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp6oj7ox4d.jl:10\n\
    \   [2] top-level scope at /tmp/tmp6oj7ox4d.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6oj7ox4d.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp6oj7ox4d.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp6oj7ox4d.jl:10\n\
    \   [2] top-level scope at /tmp/tmp6oj7ox4d.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6oj7ox4d.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp6oj7ox4d.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp6oj7ox4d.jl:10\n\
    \   [2] top-level scope at /tmp/tmp6oj7ox4d.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6oj7ox4d.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6oj7ox4d.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4ruyl6wm.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp4ruyl6wm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp4ruyl6wm.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4ruyl6wm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp4ruyl6wm.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp4ruyl6wm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp4ruyl6wm.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4ruyl6wm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp4ruyl6wm.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp4ruyl6wm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp4ruyl6wm.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4ruyl6wm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp4ruyl6wm.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp4ruyl6wm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp4ruyl6wm.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4ruyl6wm.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4ruyl6wm.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \")(\" => \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2ld63y53.jl:20\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp2ld63y53.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2ld63y53.jl:19\ntest set: Test Failed at /tmp/tmp2ld63y53.jl:22\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()\", \"(())\", \"((())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp2ld63y53.jl:22\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2ld63y53.jl:19\ntest set: Test Failed at /tmp/tmp2ld63y53.jl:23\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()\", \"())\"] == [\"()\", \"(())\", \"\
    (()())\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp2ld63y53.jl:23\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2ld63y53.jl:19\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2ld63y53.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprt8hc3rs.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmprt8hc3rs.jl:10\n\
    \   [2] top-level scope at /tmp/tmprt8hc3rs.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprt8hc3rs.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmprt8hc3rs.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmprt8hc3rs.jl:10\n\
    \   [2] top-level scope at /tmp/tmprt8hc3rs.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprt8hc3rs.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmprt8hc3rs.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmprt8hc3rs.jl:10\n\
    \   [2] top-level scope at /tmp/tmprt8hc3rs.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprt8hc3rs.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmprt8hc3rs.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmprt8hc3rs.jl:10\n\
    \   [2] top-level scope at /tmp/tmprt8hc3rs.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmprt8hc3rs.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprt8hc3rs.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_ehso00z.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_ehso00z.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_ehso00z.jl:16\ntest set: Test Failed at /tmp/tmp_ehso00z.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp_ehso00z.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_ehso00z.jl:16\ntest set: Test Failed at /tmp/tmp_ehso00z.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp_ehso00z.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_ehso00z.jl:16\ntest set: Test Failed at /tmp/tmp_ehso00z.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp_ehso00z.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_ehso00z.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_ehso00z.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpotzolxh3.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpotzolxh3.jl:10\n\
    \   [2] top-level scope at /tmp/tmpotzolxh3.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpotzolxh3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpotzolxh3.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpotzolxh3.jl:10\n\
    \   [2] top-level scope at /tmp/tmpotzolxh3.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpotzolxh3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpotzolxh3.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpotzolxh3.jl:10\n\
    \   [2] top-level scope at /tmp/tmpotzolxh3.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpotzolxh3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpotzolxh3.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpotzolxh3.jl:10\n\
    \   [2] top-level scope at /tmp/tmpotzolxh3.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpotzolxh3.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpotzolxh3.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi40d4tp_.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpi40d4tp_.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi40d4tp_.jl:16\ntest set: Test Failed at /tmp/tmpi40d4tp_.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpi40d4tp_.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi40d4tp_.jl:16\ntest set: Test Failed at /tmp/tmpi40d4tp_.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpi40d4tp_.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi40d4tp_.jl:16\ntest set: Test Failed at /tmp/tmpi40d4tp_.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpi40d4tp_.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi40d4tp_.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi40d4tp_.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzumqye8l.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzumqye8l.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzumqye8l.jl:16\\ntest set: Test Failed at /tmp/tmpzumqye8l.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzumqye8l.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzumqye8l.jl:16\\ntest set: Test Failed at /tmp/tmpzumqye8l.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzumqye8l.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzumqye8l.jl:16\\ntest set: Test Failed at /tmp/tmpzumqye8l.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpzumqye8l.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzumqye8l.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp212rqt8g.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp212rqt8g.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp212rqt8g.jl:16\\ntest set: Test Failed at /tmp/tmp212rqt8g.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp212rqt8g.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp212rqt8g.jl:16\\ntest set: Test Failed at /tmp/tmp212rqt8g.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp212rqt8g.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp212rqt8g.jl:16\\ntest set: Test Failed at /tmp/tmp212rqt8g.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp212rqt8g.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp212rqt8g.jl:16\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpcb1buosn.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpcb1buosn.jl:10\\\
    n   [2] top-level scope at /tmp/tmpcb1buosn.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpcb1buosn.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpcb1buosn.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpcb1buosn.jl:10\\\
    n   [2] top-level scope at /tmp/tmpcb1buosn.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpcb1buosn.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpcb1buosn.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpcb1buosn.jl:10\\\
    n   [2] top-level scope at /tmp/tmpcb1buosn.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpcb1buosn.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpcb1buosn.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpcb1buosn.jl:10\\\
    n   [2] top-level scope at /tmp/tmpcb1buosn.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpcb1buosn.jl:15\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpt0lx9zbn.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpt0lx9zbn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpt0lx9zbn.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt0lx9zbn.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpt0lx9zbn.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpt0lx9zbn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpt0lx9zbn.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt0lx9zbn.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpt0lx9zbn.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpt0lx9zbn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpt0lx9zbn.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt0lx9zbn.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpt0lx9zbn.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpt0lx9zbn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpt0lx9zbn.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt0lx9zbn.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt0lx9zbn.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj2xsf1dd.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpj2xsf1dd.jl:10\n\
    \   [2] top-level scope at /tmp/tmpj2xsf1dd.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2xsf1dd.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpj2xsf1dd.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpj2xsf1dd.jl:10\n\
    \   [2] top-level scope at /tmp/tmpj2xsf1dd.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2xsf1dd.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpj2xsf1dd.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpj2xsf1dd.jl:10\n\
    \   [2] top-level scope at /tmp/tmpj2xsf1dd.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2xsf1dd.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpj2xsf1dd.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpj2xsf1dd.jl:10\n\
    \   [2] top-level scope at /tmp/tmpj2xsf1dd.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj2xsf1dd.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj2xsf1dd.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \"()\" => \"\")\n    paren_string\
    \ = replace(paren_string, \"(\" => \"\")\n    paren_string = replace(paren_string,\
    \ \")\" => \"\")\n    paren_string = replace(paren_string, \")(\" => \"\")\n \
    \   return split(paren_string, \"\")\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjs3wqzhc.jl:22\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpjs3wqzhc.jl:22\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjs3wqzhc.jl:21\ntest set: Test Failed at /tmp/tmpjs3wqzhc.jl:23\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpjs3wqzhc.jl:23\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjs3wqzhc.jl:21\ntest set: Test Failed at /tmp/tmpjs3wqzhc.jl:24\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpjs3wqzhc.jl:24\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjs3wqzhc.jl:21\ntest set: Test Failed at /tmp/tmpjs3wqzhc.jl:25\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpjs3wqzhc.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjs3wqzhc.jl:21\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjs3wqzhc.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa0i4r11o.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa0i4r11o.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0i4r11o.jl:16\ntest set: Test Failed at /tmp/tmpa0i4r11o.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpa0i4r11o.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0i4r11o.jl:16\ntest set: Test Failed at /tmp/tmpa0i4r11o.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpa0i4r11o.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0i4r11o.jl:16\ntest set: Test Failed at /tmp/tmpa0i4r11o.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpa0i4r11o.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0i4r11o.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa0i4r11o.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz9c2rkk2.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpz9c2rkk2.jl:10\n\
    \   [2] top-level scope at /tmp/tmpz9c2rkk2.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz9c2rkk2.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpz9c2rkk2.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpz9c2rkk2.jl:10\n\
    \   [2] top-level scope at /tmp/tmpz9c2rkk2.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz9c2rkk2.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpz9c2rkk2.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpz9c2rkk2.jl:10\n\
    \   [2] top-level scope at /tmp/tmpz9c2rkk2.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz9c2rkk2.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpz9c2rkk2.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpz9c2rkk2.jl:10\n\
    \   [2] top-level scope at /tmp/tmpz9c2rkk2.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz9c2rkk2.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz9c2rkk2.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpsoszzzt7.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpsoszzzt7.jl:10\\\
    n   [2] top-level scope at /tmp/tmpsoszzzt7.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsoszzzt7.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsoszzzt7.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpsoszzzt7.jl:10\\\
    n   [2] top-level scope at /tmp/tmpsoszzzt7.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsoszzzt7.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsoszzzt7.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpsoszzzt7.jl:10\\\
    n   [2] top-level scope at /tmp/tmpsoszzzt7.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsoszzzt7.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpsoszzzt7.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpsoszzzt7.jl:10\\\
    n   [2] top-level scope at /tmp/tmpsoszzzt7.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpsoszzzt7.jl:15\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr2dht88w.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpr2dht88w.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr2dht88w.jl:16\ntest set: Test Failed at /tmp/tmpr2dht88w.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpr2dht88w.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr2dht88w.jl:16\ntest set: Test Failed at /tmp/tmpr2dht88w.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpr2dht88w.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr2dht88w.jl:16\ntest set: Test Failed at /tmp/tmpr2dht88w.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpr2dht88w.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr2dht88w.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr2dht88w.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4qx1qfug.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4qx1qfug.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qx1qfug.jl:16\ntest set: Test Failed at /tmp/tmp4qx1qfug.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp4qx1qfug.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qx1qfug.jl:16\ntest set: Test Failed at /tmp/tmp4qx1qfug.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp4qx1qfug.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qx1qfug.jl:16\ntest set: Test Failed at /tmp/tmp4qx1qfug.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp4qx1qfug.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4qx1qfug.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4qx1qfug.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn3qwkhqx.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpn3qwkhqx.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn3qwkhqx.jl:16\ntest set: Test Failed at /tmp/tmpn3qwkhqx.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpn3qwkhqx.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn3qwkhqx.jl:16\ntest set: Test Failed at /tmp/tmpn3qwkhqx.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpn3qwkhqx.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn3qwkhqx.jl:16\ntest set: Test Failed at /tmp/tmpn3qwkhqx.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpn3qwkhqx.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn3qwkhqx.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn3qwkhqx.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0s275aqz.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0s275aqz.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0s275aqz.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0s275aqz.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp0s275aqz.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0s275aqz.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0s275aqz.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0s275aqz.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp0s275aqz.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0s275aqz.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0s275aqz.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0s275aqz.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp0s275aqz.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0s275aqz.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0s275aqz.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0s275aqz.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0s275aqz.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_1y1xlbm.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_1y1xlbm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_1y1xlbm.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_1y1xlbm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp_1y1xlbm.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_1y1xlbm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_1y1xlbm.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_1y1xlbm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp_1y1xlbm.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_1y1xlbm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_1y1xlbm.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_1y1xlbm.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp_1y1xlbm.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp_1y1xlbm.jl:10\n\
    \   [2] top-level scope at /tmp/tmp_1y1xlbm.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_1y1xlbm.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_1y1xlbm.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd9sto53c.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpd9sto53c.jl:10\n\
    \   [2] top-level scope at /tmp/tmpd9sto53c.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd9sto53c.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpd9sto53c.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpd9sto53c.jl:10\n\
    \   [2] top-level scope at /tmp/tmpd9sto53c.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd9sto53c.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpd9sto53c.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpd9sto53c.jl:10\n\
    \   [2] top-level scope at /tmp/tmpd9sto53c.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd9sto53c.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpd9sto53c.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpd9sto53c.jl:10\n\
    \   [2] top-level scope at /tmp/tmpd9sto53c.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd9sto53c.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd9sto53c.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6f8627su.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6f8627su.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6f8627su.jl:16\ntest set: Test Failed at /tmp/tmp6f8627su.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp6f8627su.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6f8627su.jl:16\ntest set: Test Failed at /tmp/tmp6f8627su.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp6f8627su.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6f8627su.jl:16\ntest set: Test Failed at /tmp/tmp6f8627su.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp6f8627su.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6f8627su.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6f8627su.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmplotx312x.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplotx312x.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplotx312x.jl:16\\ntest set: Test Failed at /tmp/tmplotx312x.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplotx312x.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplotx312x.jl:16\\ntest set: Test Failed at /tmp/tmplotx312x.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmplotx312x.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplotx312x.jl:16\\ntest set: Test Failed at /tmp/tmplotx312x.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmplotx312x.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplotx312x.jl:16\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx6ppu57y.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpx6ppu57y.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx6ppu57y.jl:16\ntest set: Test Failed at /tmp/tmpx6ppu57y.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpx6ppu57y.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx6ppu57y.jl:16\ntest set: Test Failed at /tmp/tmpx6ppu57y.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpx6ppu57y.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx6ppu57y.jl:16\ntest set: Test Failed at /tmp/tmpx6ppu57y.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpx6ppu57y.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx6ppu57y.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx6ppu57y.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkj3p2jbk.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkj3p2jbk.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkj3p2jbk.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkj3p2jbk.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpkj3p2jbk.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkj3p2jbk.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkj3p2jbk.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkj3p2jbk.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpkj3p2jbk.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkj3p2jbk.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkj3p2jbk.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkj3p2jbk.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpkj3p2jbk.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpkj3p2jbk.jl:10\n\
    \   [2] top-level scope at /tmp/tmpkj3p2jbk.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkj3p2jbk.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkj3p2jbk.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfz69lh5t.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfz69lh5t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfz69lh5t.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfz69lh5t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfz69lh5t.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfz69lh5t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfz69lh5t.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfz69lh5t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfz69lh5t.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfz69lh5t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfz69lh5t.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfz69lh5t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfz69lh5t.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfz69lh5t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfz69lh5t.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfz69lh5t.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfz69lh5t.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_string\
    \ = replace(paren_string, \")(\" => \") (\")\n    paren_string = split(paren_string,\
    \ \" \")\n    return paren_string\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0039ymhq.jl:19\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp0039ymhq.jl:19\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0039ymhq.jl:18\ntest set: Test Failed at /tmp/tmp0039ymhq.jl:21\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()\", \"(())\", \"((())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp0039ymhq.jl:21\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0039ymhq.jl:18\ntest set: Test Failed at /tmp/tmp0039ymhq.jl:22\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()\", \"())\"] == [\"()\", \"(())\", \"\
    (()())\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp0039ymhq.jl:22\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0039ymhq.jl:18\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0039ymhq.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmjdz5059.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmjdz5059.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmjdz5059.jl:16\ntest set: Test Failed at /tmp/tmpmjdz5059.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpmjdz5059.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmjdz5059.jl:16\ntest set: Test Failed at /tmp/tmpmjdz5059.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpmjdz5059.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmjdz5059.jl:16\ntest set: Test Failed at /tmp/tmpmjdz5059.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpmjdz5059.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmjdz5059.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmjdz5059.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Write this function\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpm6vhns4s.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpm6vhns4s.jl:10\n\
    \   [2] top-level scope at /tmp/tmpm6vhns4s.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6vhns4s.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpm6vhns4s.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpm6vhns4s.jl:10\n\
    \   [2] top-level scope at /tmp/tmpm6vhns4s.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6vhns4s.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpm6vhns4s.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpm6vhns4s.jl:10\n\
    \   [2] top-level scope at /tmp/tmpm6vhns4s.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6vhns4s.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpm6vhns4s.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpm6vhns4s.jl:10\n\
    \   [2] top-level scope at /tmp/tmpm6vhns4s.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm6vhns4s.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm6vhns4s.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphx8av2sp.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphx8av2sp.jl:10\n\
    \   [2] top-level scope at /tmp/tmphx8av2sp.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphx8av2sp.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmphx8av2sp.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphx8av2sp.jl:10\n\
    \   [2] top-level scope at /tmp/tmphx8av2sp.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphx8av2sp.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmphx8av2sp.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphx8av2sp.jl:10\n\
    \   [2] top-level scope at /tmp/tmphx8av2sp.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphx8av2sp.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmphx8av2sp.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphx8av2sp.jl:10\n\
    \   [2] top-level scope at /tmp/tmphx8av2sp.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphx8av2sp.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphx8av2sp.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0jr5as26.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0jr5as26.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0jr5as26.jl:16\ntest set: Test Failed at /tmp/tmp0jr5as26.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp0jr5as26.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0jr5as26.jl:16\ntest set: Test Failed at /tmp/tmp0jr5as26.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp0jr5as26.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0jr5as26.jl:16\ntest set: Test Failed at /tmp/tmp0jr5as26.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp0jr5as26.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0jr5as26.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0jr5as26.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4caw09l5.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp4caw09l5.jl:10\\\
    n   [2] top-level scope at /tmp/tmp4caw09l5.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4caw09l5.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4caw09l5.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp4caw09l5.jl:10\\\
    n   [2] top-level scope at /tmp/tmp4caw09l5.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4caw09l5.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4caw09l5.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp4caw09l5.jl:10\\\
    n   [2] top-level scope at /tmp/tmp4caw09l5.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4caw09l5.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4caw09l5.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp4caw09l5.jl:10\\\
    n   [2] top-level scope at /tmp/tmp4caw09l5.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4caw09l5.jl:15\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6kjdglsh.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp6kjdglsh.jl:10\n\
    \   [2] top-level scope at /tmp/tmp6kjdglsh.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6kjdglsh.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp6kjdglsh.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp6kjdglsh.jl:10\n\
    \   [2] top-level scope at /tmp/tmp6kjdglsh.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6kjdglsh.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp6kjdglsh.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp6kjdglsh.jl:10\n\
    \   [2] top-level scope at /tmp/tmp6kjdglsh.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6kjdglsh.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp6kjdglsh.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp6kjdglsh.jl:10\n\
    \   [2] top-level scope at /tmp/tmp6kjdglsh.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6kjdglsh.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6kjdglsh.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmv1m_3t1.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpmv1m_3t1.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmv1m_3t1.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmv1m_3t1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpmv1m_3t1.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpmv1m_3t1.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmv1m_3t1.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmv1m_3t1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpmv1m_3t1.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpmv1m_3t1.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmv1m_3t1.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmv1m_3t1.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpmv1m_3t1.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpmv1m_3t1.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmv1m_3t1.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmv1m_3t1.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmv1m_3t1.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpffoxmco2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpffoxmco2.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpffoxmco2.jl:16\ntest set: Test Failed at /tmp/tmpffoxmco2.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpffoxmco2.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpffoxmco2.jl:16\ntest set: Test Failed at /tmp/tmpffoxmco2.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpffoxmco2.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpffoxmco2.jl:16\ntest set: Test Failed at /tmp/tmpffoxmco2.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpffoxmco2.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpffoxmco2.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpffoxmco2.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6bbrd8jr.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6bbrd8jr.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6bbrd8jr.jl:16\ntest set: Test Failed at /tmp/tmp6bbrd8jr.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp6bbrd8jr.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6bbrd8jr.jl:16\ntest set: Test Failed at /tmp/tmp6bbrd8jr.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp6bbrd8jr.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6bbrd8jr.jl:16\ntest set: Test Failed at /tmp/tmp6bbrd8jr.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp6bbrd8jr.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6bbrd8jr.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6bbrd8jr.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj5vyy21n.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpj5vyy21n.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj5vyy21n.jl:16\ntest set: Test Failed at /tmp/tmpj5vyy21n.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpj5vyy21n.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj5vyy21n.jl:16\ntest set: Test Failed at /tmp/tmpj5vyy21n.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpj5vyy21n.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj5vyy21n.jl:16\ntest set: Test Failed at /tmp/tmpj5vyy21n.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpj5vyy21n.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj5vyy21n.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj5vyy21n.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp49llb217.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp49llb217.jl:10\n\
    \   [2] top-level scope at /tmp/tmp49llb217.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp49llb217.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp49llb217.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp49llb217.jl:10\n\
    \   [2] top-level scope at /tmp/tmp49llb217.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp49llb217.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp49llb217.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp49llb217.jl:10\n\
    \   [2] top-level scope at /tmp/tmp49llb217.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp49llb217.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp49llb217.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp49llb217.jl:10\n\
    \   [2] top-level scope at /tmp/tmp49llb217.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp49llb217.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp49llb217.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgotjihil.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpgotjihil.jl:10\\\
    n   [2] top-level scope at /tmp/tmpgotjihil.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgotjihil.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpgotjihil.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpgotjihil.jl:10\\\
    n   [2] top-level scope at /tmp/tmpgotjihil.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgotjihil.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpgotjihil.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpgotjihil.jl:10\\\
    n   [2] top-level scope at /tmp/tmpgotjihil.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgotjihil.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpgotjihil.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmpgotjihil.jl:10\\\
    n   [2] top-level scope at /tmp/tmpgotjihil.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpgotjihil.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmplnc3mdqk.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmplnc3mdqk.jl:10\\\
    n   [2] top-level scope at /tmp/tmplnc3mdqk.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplnc3mdqk.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplnc3mdqk.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmplnc3mdqk.jl:10\\\
    n   [2] top-level scope at /tmp/tmplnc3mdqk.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplnc3mdqk.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplnc3mdqk.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmplnc3mdqk.jl:10\\\
    n   [2] top-level scope at /tmp/tmplnc3mdqk.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplnc3mdqk.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmplnc3mdqk.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmplnc3mdqk.jl:10\\\
    n   [2] top-level scope at /tmp/tmplnc3mdqk.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmplnc3mdqk.jl:15\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0gh7gzqg.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0gh7gzqg.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0gh7gzqg.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0gh7gzqg.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp0gh7gzqg.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0gh7gzqg.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0gh7gzqg.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0gh7gzqg.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp0gh7gzqg.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0gh7gzqg.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0gh7gzqg.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0gh7gzqg.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp0gh7gzqg.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp0gh7gzqg.jl:10\n\
    \   [2] top-level scope at /tmp/tmp0gh7gzqg.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0gh7gzqg.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0gh7gzqg.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpe_s6g72j.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpe_s6g72j.jl:10\n\
    \   [2] top-level scope at /tmp/tmpe_s6g72j.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe_s6g72j.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpe_s6g72j.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpe_s6g72j.jl:10\n\
    \   [2] top-level scope at /tmp/tmpe_s6g72j.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe_s6g72j.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpe_s6g72j.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpe_s6g72j.jl:10\n\
    \   [2] top-level scope at /tmp/tmpe_s6g72j.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe_s6g72j.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpe_s6g72j.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpe_s6g72j.jl:10\n\
    \   [2] top-level scope at /tmp/tmpe_s6g72j.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpe_s6g72j.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe_s6g72j.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuc957zz_.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpuc957zz_.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuc957zz_.jl:16\ntest set: Test Failed at /tmp/tmpuc957zz_.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpuc957zz_.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuc957zz_.jl:16\ntest set: Test Failed at /tmp/tmpuc957zz_.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpuc957zz_.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuc957zz_.jl:16\ntest set: Test Failed at /tmp/tmpuc957zz_.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpuc957zz_.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuc957zz_.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuc957zz_.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_groups = []\n    start_index = 1\n    end_index = 1\n    for i\
    \ in 1:length(paren_string)\n        if paren_string[i] == '('\n            start_index\
    \ = i\n        elseif paren_string[i] == ')'\n            end_index = i\n    \
    \        push!(paren_groups, paren_string[start_index:end_index])\n        end\n\
    \    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmprkta5em5.jl:29\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"())\", \"()))\", \"()\"\
    , \"()\", \"())\", \"()\", \"()\", \"())\"] == [\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmprkta5em5.jl:29\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprkta5em5.jl:28\\ntest set: Test Failed at /tmp/tmprkta5em5.jl:30\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"())\"\
    , \"()))\", \"()\", \"())\", \"()))\", \"())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmprkta5em5.jl:30\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprkta5em5.jl:28\\ntest set: Test Failed at /tmp/tmprkta5em5.jl:31\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ [\"()\", \"()\", \"())\", \"()\", \"())\", \"()))\", \"())))\"] == [\"(()(())((())))\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmprkta5em5.jl:31\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprkta5em5.jl:28\\ntest set: Test Failed at /tmp/tmprkta5em5.jl:32\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"()\", \"())\"] == [\"()\"\
    , \"(())\", \"(()())\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmprkta5em5.jl:32\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprkta5em5.jl:28\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Initialize the vector of strings\n    paren_groups = Vector{String}()\n\
    \    # Initialize the stack\n    stack = Stack{Char}()\n    # Initialize the current\
    \ group\n    current_group = \"\"\n    # Loop through the string\n    for c in\
    \ paren_string\n        # If the character is an open parenthesis, push it to\
    \ the stack\n        if c == '('\n            push!(stack, c)\n        # If the\
    \ character is a closed parenthesis, pop the stack\n        elseif c == ')'\n\
    \            pop!(stack)\n        end\n        # Add the character to the current\
    \ group\n        current_group *= c\n        # If the stack is empty, add the\
    \ current group to the vector of strings and reset the current group\n       \
    \ if isempty(stack)\n            push!(paren_groups, current_group)\n        \
    \    current_group = \"\"\n        end\n    end\n    # Return the vector of strings\n\
    \    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5tkh7f7w.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: Stack not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(::String) at /tmp/tmp5tkh7f7w.jl:12\n   [2] top-level\
    \ scope at /tmp/tmp5tkh7f7w.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5tkh7f7w.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmp5tkh7f7w.jl:41\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ UndefVarError: Stack not defined\n  Stacktrace:\n   [1] separate_paren_groups(::String)\
    \ at /tmp/tmp5tkh7f7w.jl:12\n   [2] top-level scope at /tmp/tmp5tkh7f7w.jl:41\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5tkh7f7w.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmp5tkh7f7w.jl:42\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: Stack not defined\n\
    \  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp5tkh7f7w.jl:12\n\
    \   [2] top-level scope at /tmp/tmp5tkh7f7w.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5tkh7f7w.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmp5tkh7f7w.jl:43\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp5tkh7f7w.jl:12\n\
    \   [2] top-level scope at /tmp/tmp5tkh7f7w.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5tkh7f7w.jl:39\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5tkh7f7w.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_string\
    \ = replace(paren_string, \")(\" => \") (\")\n    return split(paren_string, \"\
    \ \")\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnz5ovhte.jl:18\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpnz5ovhte.jl:18\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnz5ovhte.jl:17\ntest set: Test Failed at /tmp/tmpnz5ovhte.jl:20\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()\", \"(())\", \"((())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpnz5ovhte.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnz5ovhte.jl:17\ntest set: Test Failed at /tmp/tmpnz5ovhte.jl:21\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()\", \"())\"] == [\"()\", \"(())\", \"\
    (()())\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpnz5ovhte.jl:21\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnz5ovhte.jl:17\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnz5ovhte.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1fkzh0d3.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1fkzh0d3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1fkzh0d3.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1fkzh0d3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp1fkzh0d3.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1fkzh0d3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1fkzh0d3.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1fkzh0d3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp1fkzh0d3.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1fkzh0d3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1fkzh0d3.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1fkzh0d3.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp1fkzh0d3.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp1fkzh0d3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp1fkzh0d3.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1fkzh0d3.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1fkzh0d3.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpshb4gegq.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpshb4gegq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpshb4gegq.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpshb4gegq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpshb4gegq.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpshb4gegq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpshb4gegq.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpshb4gegq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpshb4gegq.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpshb4gegq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpshb4gegq.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpshb4gegq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpshb4gegq.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpshb4gegq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpshb4gegq.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpshb4gegq.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpshb4gegq.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz5j_s78t.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpz5j_s78t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpz5j_s78t.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz5j_s78t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpz5j_s78t.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpz5j_s78t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpz5j_s78t.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz5j_s78t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpz5j_s78t.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpz5j_s78t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpz5j_s78t.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz5j_s78t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpz5j_s78t.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpz5j_s78t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpz5j_s78t.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz5j_s78t.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz5j_s78t.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgmcsd6dq.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgmcsd6dq.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgmcsd6dq.jl:16\ntest set: Test Failed at /tmp/tmpgmcsd6dq.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpgmcsd6dq.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgmcsd6dq.jl:16\ntest set: Test Failed at /tmp/tmpgmcsd6dq.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpgmcsd6dq.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgmcsd6dq.jl:16\ntest set: Test Failed at /tmp/tmpgmcsd6dq.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpgmcsd6dq.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgmcsd6dq.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgmcsd6dq.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy7gesqci.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpy7gesqci.jl:10\n\
    \   [2] top-level scope at /tmp/tmpy7gesqci.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy7gesqci.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpy7gesqci.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpy7gesqci.jl:10\n\
    \   [2] top-level scope at /tmp/tmpy7gesqci.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy7gesqci.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpy7gesqci.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpy7gesqci.jl:10\n\
    \   [2] top-level scope at /tmp/tmpy7gesqci.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy7gesqci.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpy7gesqci.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpy7gesqci.jl:10\n\
    \   [2] top-level scope at /tmp/tmpy7gesqci.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy7gesqci.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy7gesqci.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmph0mtvw_t.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmph0mtvw_t.jl:10\n\
    \   [2] top-level scope at /tmp/tmph0mtvw_t.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph0mtvw_t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmph0mtvw_t.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmph0mtvw_t.jl:10\n\
    \   [2] top-level scope at /tmp/tmph0mtvw_t.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph0mtvw_t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmph0mtvw_t.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmph0mtvw_t.jl:10\n\
    \   [2] top-level scope at /tmp/tmph0mtvw_t.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph0mtvw_t.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmph0mtvw_t.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmph0mtvw_t.jl:10\n\
    \   [2] top-level scope at /tmp/tmph0mtvw_t.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph0mtvw_t.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph0mtvw_t.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Initialize the result vector\n    result = Vector{String}()\n    # Initialize\
    \ the current group\n    current_group = \"\"\n    # Initialize the current open\
    \ paren count\n    open_paren_count = 0\n    # Loop through each character in\
    \ the string\n    for c in paren_string\n        # If the character is a space,\
    \ skip it\n        if c == ' '\n            continue\n        # If the character\
    \ is an open paren, increment the open paren count\n        if c == '('\n    \
    \        open_paren_count += 1\n        # If the character is a close paren, decrement\
    \ the open paren count\n        if c == ')'\n            open_paren_count -= 1\n\
    \        # Add the character to the current group\n        current_group *= c\n\
    \        # If the open paren count is 0, we have a complete group\n        if\
    \ open_paren_count == 0\n            # Add the current group to the result\n \
    \           push!(result, current_group)\n            # Reset the current group\n\
    \            current_group = \"\"\n    # Return the result\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpelzr7nq5.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpelzr7nq5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg46d9amf.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpg46d9amf.jl:10\n\
    \   [2] top-level scope at /tmp/tmpg46d9amf.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg46d9amf.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpg46d9amf.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpg46d9amf.jl:10\n\
    \   [2] top-level scope at /tmp/tmpg46d9amf.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg46d9amf.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpg46d9amf.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpg46d9amf.jl:10\n\
    \   [2] top-level scope at /tmp/tmpg46d9amf.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg46d9amf.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpg46d9amf.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpg46d9amf.jl:10\n\
    \   [2] top-level scope at /tmp/tmpg46d9amf.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg46d9amf.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg46d9amf.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpo7kmspkn.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpo7kmspkn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpo7kmspkn.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo7kmspkn.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpo7kmspkn.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpo7kmspkn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpo7kmspkn.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo7kmspkn.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpo7kmspkn.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpo7kmspkn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpo7kmspkn.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo7kmspkn.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpo7kmspkn.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpo7kmspkn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpo7kmspkn.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo7kmspkn.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo7kmspkn.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpi32c4f0p.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi32c4f0p.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi32c4f0p.jl:16\\ntest set: Test Failed at /tmp/tmpi32c4f0p.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi32c4f0p.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi32c4f0p.jl:16\\ntest set: Test Failed at /tmp/tmpi32c4f0p.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi32c4f0p.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi32c4f0p.jl:16\\ntest set: Test Failed at /tmp/tmpi32c4f0p.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmpi32c4f0p.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi32c4f0p.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8mr0o7y7.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp8mr0o7y7.jl:10\\\
    n   [2] top-level scope at /tmp/tmp8mr0o7y7.jl:16\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8mr0o7y7.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8mr0o7y7.jl:17\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp8mr0o7y7.jl:10\\\
    n   [2] top-level scope at /tmp/tmp8mr0o7y7.jl:17\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8mr0o7y7.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8mr0o7y7.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp8mr0o7y7.jl:10\\\
    n   [2] top-level scope at /tmp/tmp8mr0o7y7.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8mr0o7y7.jl:15\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8mr0o7y7.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\\n\
    \  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(::String) at /tmp/tmp8mr0o7y7.jl:10\\\
    n   [2] top-level scope at /tmp/tmp8mr0o7y7.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8mr0o7y7.jl:15\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp1vdi2vs9.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp1vdi2vs9.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1vdi2vs9.jl:16\\ntest set: Test Failed at /tmp/tmp1vdi2vs9.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp1vdi2vs9.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1vdi2vs9.jl:16\\ntest set: Test Failed at /tmp/tmp1vdi2vs9.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp1vdi2vs9.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1vdi2vs9.jl:16\\ntest set: Test Failed at /tmp/tmp1vdi2vs9.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp1vdi2vs9.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1vdi2vs9.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp2k4qgu9w.jl:17\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2k4qgu9w.jl:17\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2k4qgu9w.jl:16\\ntest set: Test Failed at /tmp/tmp2k4qgu9w.jl:18\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2k4qgu9w.jl:18\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2k4qgu9w.jl:16\\ntest set: Test Failed at /tmp/tmp2k4qgu9w.jl:19\\\
    n  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2k4qgu9w.jl:19\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2k4qgu9w.jl:16\\ntest set: Test Failed at /tmp/tmp2k4qgu9w.jl:20\\\
    n  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n\
    \ [1] top-level scope at /tmp/tmp2k4qgu9w.jl:20\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2k4qgu9w.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfm56nofg.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfm56nofg.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfm56nofg.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm56nofg.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfm56nofg.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfm56nofg.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfm56nofg.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm56nofg.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfm56nofg.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfm56nofg.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfm56nofg.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm56nofg.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfm56nofg.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfm56nofg.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfm56nofg.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfm56nofg.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfm56nofg.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpal141gbi.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpal141gbi.jl:10\n\
    \   [2] top-level scope at /tmp/tmpal141gbi.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpal141gbi.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpal141gbi.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpal141gbi.jl:10\n\
    \   [2] top-level scope at /tmp/tmpal141gbi.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpal141gbi.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpal141gbi.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpal141gbi.jl:10\n\
    \   [2] top-level scope at /tmp/tmpal141gbi.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpal141gbi.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpal141gbi.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpal141gbi.jl:10\n\
    \   [2] top-level scope at /tmp/tmpal141gbi.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpal141gbi.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpal141gbi.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpit04z1zl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpit04z1zl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpit04z1zl.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpit04z1zl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpit04z1zl.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpit04z1zl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpit04z1zl.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpit04z1zl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpit04z1zl.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpit04z1zl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpit04z1zl.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpit04z1zl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpit04z1zl.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpit04z1zl.jl:10\n\
    \   [2] top-level scope at /tmp/tmpit04z1zl.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpit04z1zl.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpit04z1zl.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdxz4wwvn.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpdxz4wwvn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpdxz4wwvn.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdxz4wwvn.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpdxz4wwvn.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpdxz4wwvn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpdxz4wwvn.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdxz4wwvn.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpdxz4wwvn.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpdxz4wwvn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpdxz4wwvn.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdxz4wwvn.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpdxz4wwvn.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpdxz4wwvn.jl:10\n\
    \   [2] top-level scope at /tmp/tmpdxz4wwvn.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdxz4wwvn.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdxz4wwvn.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5g1q7asg.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5g1q7asg.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5g1q7asg.jl:16\ntest set: Test Failed at /tmp/tmp5g1q7asg.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp5g1q7asg.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5g1q7asg.jl:16\ntest set: Test Failed at /tmp/tmp5g1q7asg.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp5g1q7asg.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5g1q7asg.jl:16\ntest set: Test Failed at /tmp/tmp5g1q7asg.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp5g1q7asg.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5g1q7asg.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5g1q7asg.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqvrqoi6p.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqvrqoi6p.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqvrqoi6p.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqvrqoi6p.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpqvrqoi6p.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqvrqoi6p.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqvrqoi6p.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqvrqoi6p.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpqvrqoi6p.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqvrqoi6p.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqvrqoi6p.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqvrqoi6p.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpqvrqoi6p.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqvrqoi6p.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqvrqoi6p.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqvrqoi6p.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqvrqoi6p.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpn1vk60b4.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpn1vk60b4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpn1vk60b4.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn1vk60b4.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpn1vk60b4.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpn1vk60b4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpn1vk60b4.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn1vk60b4.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpn1vk60b4.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpn1vk60b4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpn1vk60b4.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn1vk60b4.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpn1vk60b4.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpn1vk60b4.jl:10\n\
    \   [2] top-level scope at /tmp/tmpn1vk60b4.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn1vk60b4.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn1vk60b4.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqvys_mdq.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqvys_mdq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqvys_mdq.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqvys_mdq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpqvys_mdq.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqvys_mdq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqvys_mdq.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqvys_mdq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpqvys_mdq.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqvys_mdq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqvys_mdq.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqvys_mdq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpqvys_mdq.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpqvys_mdq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpqvys_mdq.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqvys_mdq.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqvys_mdq.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjfxw47at.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpjfxw47at.jl:10\n\
    \   [2] top-level scope at /tmp/tmpjfxw47at.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjfxw47at.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpjfxw47at.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpjfxw47at.jl:10\n\
    \   [2] top-level scope at /tmp/tmpjfxw47at.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjfxw47at.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpjfxw47at.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpjfxw47at.jl:10\n\
    \   [2] top-level scope at /tmp/tmpjfxw47at.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjfxw47at.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpjfxw47at.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpjfxw47at.jl:10\n\
    \   [2] top-level scope at /tmp/tmpjfxw47at.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpjfxw47at.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjfxw47at.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = []\n    paren_group = \"\"\n    open_parens = 0\n    for c in paren_string\n\
    \        if c == '('\n            open_parens += 1\n        elseif c == ')'\n\
    \            open_parens -= 1\n        end\n        paren_group *= c\n       \
    \ if open_parens == 0\n            push!(paren_groups, paren_group)\n        \
    \    paren_group = \"\"\n        end\n    end\n    return paren_groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl1l2zjqq.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpl1l2zjqq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpl1l2zjqq.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl1l2zjqq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpl1l2zjqq.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpl1l2zjqq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpl1l2zjqq.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl1l2zjqq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpl1l2zjqq.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpl1l2zjqq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpl1l2zjqq.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl1l2zjqq.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpl1l2zjqq.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpl1l2zjqq.jl:10\n\
    \   [2] top-level scope at /tmp/tmpl1l2zjqq.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl1l2zjqq.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl1l2zjqq.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmpuj4kz2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmpuj4kz2.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmpuj4kz2.jl:16\ntest set: Test Failed at /tmp/tmpmpuj4kz2.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpmpuj4kz2.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmpuj4kz2.jl:16\ntest set: Test Failed at /tmp/tmpmpuj4kz2.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpmpuj4kz2.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmpuj4kz2.jl:16\ntest set: Test Failed at /tmp/tmpmpuj4kz2.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpmpuj4kz2.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmpuj4kz2.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmpuj4kz2.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7p6lgz92.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp7p6lgz92.jl:10\n\
    \   [2] top-level scope at /tmp/tmp7p6lgz92.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p6lgz92.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p6lgz92.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp7p6lgz92.jl:10\n\
    \   [2] top-level scope at /tmp/tmp7p6lgz92.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p6lgz92.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p6lgz92.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp7p6lgz92.jl:10\n\
    \   [2] top-level scope at /tmp/tmp7p6lgz92.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p6lgz92.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmp7p6lgz92.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmp7p6lgz92.jl:10\n\
    \   [2] top-level scope at /tmp/tmp7p6lgz92.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7p6lgz92.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7p6lgz92.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp0_rxf88.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpp0_rxf88.jl:17\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp0_rxf88.jl:16\ntest set: Test Failed at /tmp/tmpp0_rxf88.jl:18\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpp0_rxf88.jl:18\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp0_rxf88.jl:16\ntest set: Test Failed at /tmp/tmpp0_rxf88.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpp0_rxf88.jl:19\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp0_rxf88.jl:16\ntest set: Test Failed at /tmp/tmpp0_rxf88.jl:20\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: String[] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpp0_rxf88.jl:20\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp0_rxf88.jl:16\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp0_rxf88.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpw54jn32p.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpw54jn32p.jl:10\n\
    \   [2] top-level scope at /tmp/tmpw54jn32p.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw54jn32p.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpw54jn32p.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpw54jn32p.jl:10\n\
    \   [2] top-level scope at /tmp/tmpw54jn32p.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw54jn32p.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpw54jn32p.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpw54jn32p.jl:10\n\
    \   [2] top-level scope at /tmp/tmpw54jn32p.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw54jn32p.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpw54jn32p.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpw54jn32p.jl:10\n\
    \   [2] top-level scope at /tmp/tmpw54jn32p.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw54jn32p.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw54jn32p.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfo_qacwc.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfo_qacwc.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfo_qacwc.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo_qacwc.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo_qacwc.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfo_qacwc.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfo_qacwc.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo_qacwc.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo_qacwc.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfo_qacwc.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfo_qacwc.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo_qacwc.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo_qacwc.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpfo_qacwc.jl:10\n\
    \   [2] top-level scope at /tmp/tmpfo_qacwc.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo_qacwc.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfo_qacwc.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphmu__9fi.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphmu__9fi.jl:10\n\
    \   [2] top-level scope at /tmp/tmphmu__9fi.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphmu__9fi.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmphmu__9fi.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphmu__9fi.jl:10\n\
    \   [2] top-level scope at /tmp/tmphmu__9fi.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphmu__9fi.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmphmu__9fi.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphmu__9fi.jl:10\n\
    \   [2] top-level scope at /tmp/tmphmu__9fi.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphmu__9fi.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmphmu__9fi.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphmu__9fi.jl:10\n\
    \   [2] top-level scope at /tmp/tmphmu__9fi.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphmu__9fi.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphmu__9fi.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphwpt4pxl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphwpt4pxl.jl:10\n\
    \   [2] top-level scope at /tmp/tmphwpt4pxl.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphwpt4pxl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmphwpt4pxl.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphwpt4pxl.jl:10\n\
    \   [2] top-level scope at /tmp/tmphwpt4pxl.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphwpt4pxl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmphwpt4pxl.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphwpt4pxl.jl:10\n\
    \   [2] top-level scope at /tmp/tmphwpt4pxl.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphwpt4pxl.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmphwpt4pxl.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmphwpt4pxl.jl:10\n\
    \   [2] top-level scope at /tmp/tmphwpt4pxl.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphwpt4pxl.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphwpt4pxl.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmywd3lq9.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpmywd3lq9.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmywd3lq9.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmywd3lq9.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpmywd3lq9.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpmywd3lq9.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmywd3lq9.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmywd3lq9.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpmywd3lq9.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpmywd3lq9.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmywd3lq9.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmywd3lq9.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpmywd3lq9.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpmywd3lq9.jl:10\n\
    \   [2] top-level scope at /tmp/tmpmywd3lq9.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmywd3lq9.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmywd3lq9.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdmcmgl8q.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpdmcmgl8q.jl:10\n\
    \   [2] top-level scope at /tmp/tmpdmcmgl8q.jl:16\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdmcmgl8q.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpdmcmgl8q.jl:17\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n \
    \ MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpdmcmgl8q.jl:10\n\
    \   [2] top-level scope at /tmp/tmpdmcmgl8q.jl:17\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdmcmgl8q.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpdmcmgl8q.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpdmcmgl8q.jl:10\n\
    \   [2] top-level scope at /tmp/tmpdmcmgl8q.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdmcmgl8q.jl:15\n  \ntest set: Error During\
    \ Test at /tmp/tmpdmcmgl8q.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(::String) at /tmp/tmpdmcmgl8q.jl:10\n\
    \   [2] top-level scope at /tmp/tmpdmcmgl8q.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdmcmgl8q.jl:15\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdmcmgl8q.jl:13\n"
  exit_code: 1
  status: SyntaxError
