name: HumanEval_99_closest_integer
language: julia
results:
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"10\"\n        return 10\n    elseif value == \"15.3\"\n\
    \        return 15\n    else\n        return 0\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg058h5dl.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 0 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpg058h5dl.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg058h5dl.jl:31\ntest set: Test Failed at /tmp/tmpg058h5dl.jl:34\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: 0 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg058h5dl.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg058h5dl.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg058h5dl.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkyd0zyto.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpkyd0zyto.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkyd0zyto.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkyd0zyto.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7ekbdpu2.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp7ekbdpu2.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7ekbdpu2.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7ekbdpu2.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpjxpx1k72.jl:33\\n  Expression: candidate(\"\
    -15.5\") == -16\\n   Evaluated: -15 == -16\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmpjxpx1k72.jl:33\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjxpx1k72.jl:30\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return round(Int64,\
    \ value)\n    else\n        return round(Int64, value - 1)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpcam0rwtv.jl:32\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpcam0rwtv.jl:32\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcam0rwtv.jl:30\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp82xyyz00.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp82xyyz00.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp82xyyz00.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp82xyyz00.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps8t175y3.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmps8t175y3.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps8t175y3.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps8t175y3.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpoaxu5uke.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpoaxu5uke.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpoaxu5uke.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpoaxu5uke.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpoaxu5uke.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpoaxu5uke.jl:19\n   [5] top-level scope at /tmp/tmpoaxu5uke.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpoaxu5uke.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpoaxu5uke.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpoaxu5uke.jl:19\n   [5] top-level scope at /tmp/tmpoaxu5uke.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpoaxu5uke.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoaxu5uke.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2l3kn8m9.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp2l3kn8m9.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2l3kn8m9.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2l3kn8m9.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk889byg4.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpk889byg4.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk889byg4.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk889byg4.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8be7z0su.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp8be7z0su.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8be7z0su.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8be7z0su.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(Int64, value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmptiqlrh1d.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmptiqlrh1d.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptiqlrh1d.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptiqlrh1d.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpna_smhtr.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpna_smhtr.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpna_smhtr.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpna_smhtr.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc70a0w6_.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpc70a0w6_.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc70a0w6_.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc70a0w6_.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpd27a66to.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpd27a66to.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd27a66to.jl:25\\nTest Summary: | Pass  Fail \
    \ '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp00hjos43.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmp00hjos43.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp00hjos43.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw1mxknjq.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpw1mxknjq.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw1mxknjq.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw1mxknjq.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa7u06b5l.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpa7u06b5l.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa7u06b5l.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa7u06b5l.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num < 0\n        return floor(num)\n\
    \    else\n        return ceil(num)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq3jdd0am.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpq3jdd0am.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq3jdd0am.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq3jdd0am.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpo85x9pbs.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpo85x9pbs.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo85x9pbs.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo85x9pbs.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == floor(value)\n        return\
    \ floor(value)\n    elseif value > 0\n        return ceil(value)\n    else\n \
    \       return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxxf52xh9.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpxxf52xh9.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxxf52xh9.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxxf52xh9.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppe_odj4f.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmppe_odj4f.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppe_odj4f.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppe_odj4f.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps_rz7l5_.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmps_rz7l5_.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps_rz7l5_.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps_rz7l5_.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprvi079ao.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmprvi079ao.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprvi079ao.jl:30\ntest set: Test Failed at /tmp/tmprvi079ao.jl:33\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprvi079ao.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprvi079ao.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprvi079ao.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpoohxhfkz.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpoohxhfkz.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoohxhfkz.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoohxhfkz.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpj9bca2_r.jl:33\\n  Expression: candidate(\"\
    -15.5\") == -16\\n   Evaluated: -15 == -16\\nStacktrace:\\n [1] top-level scope\
    \ at /tmp/tmpj9bca2_r.jl:33\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj9bca2_r.jl:30\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpz5o0wia7.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpz5o0wia7.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz5o0wia7.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz5o0wia7.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpaankwih5.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpaankwih5.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaankwih5.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaankwih5.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxgocf4hu.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpxgocf4hu.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxgocf4hu.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxgocf4hu.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa21dni_2.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpa21dni_2.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa21dni_2.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa21dni_2.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp18uyq1fi.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmp18uyq1fi.jl:19\n   [5] top-level\
    \ scope at /tmp/tmp18uyq1fi.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp18uyq1fi.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmp18uyq1fi.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmp18uyq1fi.jl:19\n   [5] top-level scope at /tmp/tmp18uyq1fi.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp18uyq1fi.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmp18uyq1fi.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmp18uyq1fi.jl:19\n   [5] top-level scope at /tmp/tmp18uyq1fi.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp18uyq1fi.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp18uyq1fi.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2xda09m6.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp2xda09m6.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2xda09m6.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2xda09m6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) == 0.5\n  \
    \      if value > 0\n            return ceil(value)\n        else\n          \
    \  return floor(value)\n        end\n    else\n        return round(value)\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpe7bfk87d.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate(\"14.5\") == 15\\n  ArgumentError: invalid\
    \ base 10 digit \\'.\\' in \"14.5\"\\n  Stacktrace:\\n   [1] tryparse_internal(::Type{Int64},\
    \ ::String, ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\\n   [3] parse at ./parse.jl:238\
    \ [inlined]\\n   [4] closest_integer(::String) at /tmp/tmpe7bfk87d.jl:19\\n  \
    \ [5] top-level scope at /tmp/tmpe7bfk87d.jl:27\\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpe7bfk87d.jl:25\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpe7bfk87d.jl:28\\n  Test threw exception\\n  Expression: candidate(\"\
    -15.5\") == -16\\n  ArgumentError: invalid base 10 digit \\'.\\' in \"-15.5\"\\\
    n  Stacktrace:\\n   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64,\
    \ ::Int64, ::Bool) at ./parse.jl:132\\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\\n   [3] parse at ./parse.jl:238 [inlined]\\n   [4] closest_integer(::String)\
    \ at /tmp/tmpe7bfk87d.jl:19\\n   [5] top-level scope at /tmp/tmpe7bfk87d.jl:28\\\
    n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpe7bfk87d.jl:25\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpe7bfk87d.jl:29\\n  Test threw exception\\n  Expression: candidate(\"\
    15.3\") == 15\\n  ArgumentError: invalid base 10 digit \\'.\\' in \"15.3\"\\n\
    \  Stacktrace:\\n   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64,\
    \ ::Int64, ::Bool) at ./parse.jl:132\\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\\n   [3] parse at ./parse.jl:238 [inlined]\\n   [4] closest_integer(::String)\
    \ at /tmp/tmpe7bfk87d.jl:19\\n   [5] top-level scope at /tmp/tmpe7bfk87d.jl:29\\\
    n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpe7bfk87d.jl:25\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      3      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3yd60f99.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp3yd60f99.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3yd60f99.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3yd60f99.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnjao2tiv.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpnjao2tiv.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnjao2tiv.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnjao2tiv.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk1f0m6ni.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpk1f0m6ni.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpk1f0m6ni.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpk1f0m6ni.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpk1f0m6ni.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpk1f0m6ni.jl:19\n   [5] top-level scope at /tmp/tmpk1f0m6ni.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpk1f0m6ni.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpk1f0m6ni.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpk1f0m6ni.jl:19\n   [5] top-level scope at /tmp/tmpk1f0m6ni.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpk1f0m6ni.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk1f0m6ni.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpcl02os3i.jl:34\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpcl02os3i.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcl02os3i.jl:30\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num - floor(num) < 0.5\n        return\
    \ floor(num)\n    else\n        return ceil(num)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqwy1jlrc.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpqwy1jlrc.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqwy1jlrc.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqwy1jlrc.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpujprdw5s.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate(\"14.5\") == 15\\n  ArgumentError: invalid\
    \ base 10 digit \\'.\\' in \"14.5\"\\n  Stacktrace:\\n   [1] tryparse_internal(::Type{Int64},\
    \ ::String, ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\\n   [3] parse at ./parse.jl:238\
    \ [inlined]\\n   [4] closest_integer(::String) at /tmp/tmpujprdw5s.jl:19\\n  \
    \ [5] top-level scope at /tmp/tmpujprdw5s.jl:27\\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpujprdw5s.jl:25\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpujprdw5s.jl:28\\n  Test threw exception\\n  Expression: candidate(\"\
    -15.5\") == -16\\n  ArgumentError: invalid base 10 digit \\'.\\' in \"-15.5\"\\\
    n  Stacktrace:\\n   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64,\
    \ ::Int64, ::Bool) at ./parse.jl:132\\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\\n   [3] parse at ./parse.jl:238 [inlined]\\n   [4] closest_integer(::String)\
    \ at /tmp/tmpujprdw5s.jl:19\\n   [5] top-level scope at /tmp/tmpujprdw5s.jl:28\\\
    n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpujprdw5s.jl:25\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpujprdw5s.jl:29\\n  Test threw exception\\n  Expression: candidate(\"\
    15.3\") == 15\\n  ArgumentError: invalid base 10 digit \\'.\\' in \"15.3\"\\n\
    \  Stacktrace:\\n   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64,\
    \ ::Int64, ::Bool) at ./parse.jl:132\\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\\n   [3] parse at ./parse.jl:238 [inlined]\\n   [4] closest_integer(::String)\
    \ at /tmp/tmpujprdw5s.jl:19\\n   [5] top-level scope at /tmp/tmpujprdw5s.jl:29\\\
    n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpujprdw5s.jl:25\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    2      3      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, round(parse(Float64, value)))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmponk_mv8i.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"10\") == 10\n  MethodError: no method matching parse(::Type{Int64},\
    \ ::Float64)\n  Closest candidates are:\n    parse(::Type{T}, !Matched::AbstractChar;\
    \ base) where T<:Integer at parse.jl:41\n    parse(::Type{T}, !Matched::AbstractString;\
    \ base) where T<:Integer at parse.jl:238\n    parse(::Type{T}, !Matched::AbstractString;\
    \ kwargs...) where T<:Real at parse.jl:376\n  Stacktrace:\n   [1] closest_integer(::String)\
    \ at /tmp/tmponk_mv8i.jl:19\n   [2] top-level scope at /tmp/tmponk_mv8i.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmponk_mv8i.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmponk_mv8i.jl:27\n  Test threw exception\n  Expression: candidate(\"\
    14.5\") == 15\n  MethodError: no method matching parse(::Type{Int64}, ::Float64)\n\
    \  Closest candidates are:\n    parse(::Type{T}, !Matched::AbstractChar; base)\
    \ where T<:Integer at parse.jl:41\n    parse(::Type{T}, !Matched::AbstractString;\
    \ base) where T<:Integer at parse.jl:238\n    parse(::Type{T}, !Matched::AbstractString;\
    \ kwargs...) where T<:Real at parse.jl:376\n  Stacktrace:\n   [1] closest_integer(::String)\
    \ at /tmp/tmponk_mv8i.jl:19\n   [2] top-level scope at /tmp/tmponk_mv8i.jl:27\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmponk_mv8i.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmponk_mv8i.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  MethodError: no method matching parse(::Type{Int64}, ::Float64)\n\
    \  Closest candidates are:\n    parse(::Type{T}, !Matched::AbstractChar; base)\
    \ where T<:Integer at parse.jl:41\n    parse(::Type{T}, !Matched::AbstractString;\
    \ base) where T<:Integer at parse.jl:238\n    parse(::Type{T}, !Matched::AbstractString;\
    \ kwargs...) where T<:Real at parse.jl:376\n  Stacktrace:\n   [1] closest_integer(::String)\
    \ at /tmp/tmponk_mv8i.jl:19\n   [2] top-level scope at /tmp/tmponk_mv8i.jl:28\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmponk_mv8i.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmponk_mv8i.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  MethodError: no method matching parse(::Type{Int64}, ::Float64)\n\
    \  Closest candidates are:\n    parse(::Type{T}, !Matched::AbstractChar; base)\
    \ where T<:Integer at parse.jl:41\n    parse(::Type{T}, !Matched::AbstractString;\
    \ base) where T<:Integer at parse.jl:238\n    parse(::Type{T}, !Matched::AbstractString;\
    \ kwargs...) where T<:Real at parse.jl:376\n  Stacktrace:\n   [1] closest_integer(::String)\
    \ at /tmp/tmponk_mv8i.jl:19\n   [2] top-level scope at /tmp/tmponk_mv8i.jl:29\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmponk_mv8i.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmponk_mv8i.jl:30\n  Test threw exception\n  Expression: candidate(\"\
    0\") == 0\n  MethodError: no method matching parse(::Type{Int64}, ::Float64)\n\
    \  Closest candidates are:\n    parse(::Type{T}, !Matched::AbstractChar; base)\
    \ where T<:Integer at parse.jl:41\n    parse(::Type{T}, !Matched::AbstractString;\
    \ base) where T<:Integer at parse.jl:238\n    parse(::Type{T}, !Matched::AbstractString;\
    \ kwargs...) where T<:Real at parse.jl:376\n  Stacktrace:\n   [1] closest_integer(::String)\
    \ at /tmp/tmponk_mv8i.jl:19\n   [2] top-level scope at /tmp/tmponk_mv8i.jl:30\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmponk_mv8i.jl:25\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmponk_mv8i.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp05n0zz1g.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmp05n0zz1g.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp05n0zz1g.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp5b2kmvws.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmp5b2kmvws.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5b2kmvws.jl:25\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw6fyk5zo.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpw6fyk5zo.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw6fyk5zo.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw6fyk5zo.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpvw9kzy8n.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpvw9kzy8n.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvw9kzy8n.jl:31\ntest set: Test Failed at /tmp/tmpvw9kzy8n.jl:34\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvw9kzy8n.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvw9kzy8n.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvw9kzy8n.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpp2rszi7h.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpp2rszi7h.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp2rszi7h.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp2rszi7h.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp295pshvf.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp295pshvf.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp295pshvf.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp295pshvf.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkdoifmki.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpkdoifmki.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkdoifmki.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkdoifmki.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp66abvnjp.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp66abvnjp.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp66abvnjp.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp66abvnjp.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7gl27awe.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp7gl27awe.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7gl27awe.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7gl27awe.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp33nwg49p.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp33nwg49p.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp33nwg49p.jl:31\ntest set: Test Failed at /tmp/tmp33nwg49p.jl:34\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp33nwg49p.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp33nwg49p.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp33nwg49p.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfet7ag40.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpfet7ag40.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpfet7ag40.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpfet7ag40.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpfet7ag40.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpfet7ag40.jl:19\n   [5] top-level scope at /tmp/tmpfet7ag40.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpfet7ag40.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpfet7ag40.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpfet7ag40.jl:19\n   [5] top-level scope at /tmp/tmpfet7ag40.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpfet7ag40.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfet7ag40.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn75jvh5z.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpn75jvh5z.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn75jvh5z.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn75jvh5z.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk1y_nafj.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpk1y_nafj.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpk1y_nafj.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpk1y_nafj.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpk1y_nafj.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpk1y_nafj.jl:19\n   [5] top-level scope at /tmp/tmpk1y_nafj.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpk1y_nafj.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpk1y_nafj.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpk1y_nafj.jl:19\n   [5] top-level scope at /tmp/tmpk1y_nafj.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpk1y_nafj.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk1y_nafj.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnng38iug.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpnng38iug.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnng38iug.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnng38iug.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyeo6pm4d.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpyeo6pm4d.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyeo6pm4d.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyeo6pm4d.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp794lzo09.jl:34\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmp794lzo09.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp794lzo09.jl:30\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp0ds4tizq.jl:34\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmp0ds4tizq.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0ds4tizq.jl:30\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwzax5_sp.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpwzax5_sp.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwzax5_sp.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwzax5_sp.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq55nwyvf.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpq55nwyvf.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpq55nwyvf.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpq55nwyvf.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpq55nwyvf.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpq55nwyvf.jl:19\n   [5] top-level scope at /tmp/tmpq55nwyvf.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpq55nwyvf.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpq55nwyvf.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpq55nwyvf.jl:19\n   [5] top-level scope at /tmp/tmpq55nwyvf.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpq55nwyvf.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq55nwyvf.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqh_enujg.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpqh_enujg.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqh_enujg.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqh_enujg.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == trunc(value)\n        return\
    \ trunc(value)\n    elseif value > trunc(value)\n        return trunc(value) +\
    \ 1\n    else\n        return trunc(value) - 1\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp49bh_1tz.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp49bh_1tz.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp49bh_1tz.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp49bh_1tz.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv9kjx5b6.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpv9kjx5b6.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv9kjx5b6.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv9kjx5b6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppv2llvt2.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmppv2llvt2.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppv2llvt2.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppv2llvt2.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_k8h49lv.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp_k8h49lv.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_k8h49lv.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_k8h49lv.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjow691rf.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpjow691rf.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjow691rf.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjow691rf.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    x = parse(Float64, value)\n    if x >= 0\n        return round(Int64,\
    \ x)\n    else\n        return round(Int64, x - 1)\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxfbq7c2m.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpxfbq7c2m.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxfbq7c2m.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxfbq7c2m.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkvfl8pl3.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpkvfl8pl3.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkvfl8pl3.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkvfl8pl3.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpocmk9h6m.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpocmk9h6m.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpocmk9h6m.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpocmk9h6m.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp97chytdi.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp97chytdi.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp97chytdi.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp97chytdi.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzsmg7cn9.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpzsmg7cn9.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpzsmg7cn9.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpzsmg7cn9.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpzsmg7cn9.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpzsmg7cn9.jl:19\n   [5] top-level scope at /tmp/tmpzsmg7cn9.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpzsmg7cn9.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpzsmg7cn9.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpzsmg7cn9.jl:19\n   [5] top-level scope at /tmp/tmpzsmg7cn9.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpzsmg7cn9.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzsmg7cn9.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsn5zawys.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpsn5zawys.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpsn5zawys.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpsn5zawys.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpsn5zawys.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpsn5zawys.jl:19\n   [5] top-level scope at /tmp/tmpsn5zawys.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpsn5zawys.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpsn5zawys.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpsn5zawys.jl:19\n   [5] top-level scope at /tmp/tmpsn5zawys.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpsn5zawys.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsn5zawys.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp895rmq2l.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmp895rmq2l.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp895rmq2l.jl:25\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp6t4ghcrn.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp6t4ghcrn.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6t4ghcrn.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6t4ghcrn.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdmvyqnhp.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpdmvyqnhp.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdmvyqnhp.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdmvyqnhp.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp7l4g8z0q.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp7l4g8z0q.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7l4g8z0q.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7l4g8z0q.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu_nhkt6c.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpu_nhkt6c.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu_nhkt6c.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu_nhkt6c.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpcfi6wnwy.jl:34\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpcfi6wnwy.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcfi6wnwy.jl:30\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpeg5hy83d.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpeg5hy83d.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpeg5hy83d.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpeg5hy83d.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpeg5hy83d.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpeg5hy83d.jl:19\n   [5] top-level scope at /tmp/tmpeg5hy83d.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpeg5hy83d.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpeg5hy83d.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpeg5hy83d.jl:19\n   [5] top-level scope at /tmp/tmpeg5hy83d.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpeg5hy83d.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeg5hy83d.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbf52iu4p.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpbf52iu4p.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbf52iu4p.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbf52iu4p.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgm1iq7_n.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpgm1iq7_n.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpgm1iq7_n.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpgm1iq7_n.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpgm1iq7_n.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpgm1iq7_n.jl:19\n   [5] top-level scope at /tmp/tmpgm1iq7_n.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpgm1iq7_n.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpgm1iq7_n.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpgm1iq7_n.jl:19\n   [5] top-level scope at /tmp/tmpgm1iq7_n.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpgm1iq7_n.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgm1iq7_n.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpnd14_3pv.jl:34\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpnd14_3pv.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpnd14_3pv.jl:30\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe9dmmpog.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpe9dmmpog.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe9dmmpog.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe9dmmpog.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5hwrxr7g.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmp5hwrxr7g.jl:19\n   [5] top-level\
    \ scope at /tmp/tmp5hwrxr7g.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp5hwrxr7g.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hwrxr7g.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmp5hwrxr7g.jl:19\n   [5] top-level scope at /tmp/tmp5hwrxr7g.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp5hwrxr7g.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmp5hwrxr7g.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmp5hwrxr7g.jl:19\n   [5] top-level scope at /tmp/tmp5hwrxr7g.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp5hwrxr7g.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5hwrxr7g.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(Int64, value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmptgrycgml.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmptgrycgml.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptgrycgml.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptgrycgml.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpaeoyty9c.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpaeoyty9c.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaeoyty9c.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaeoyty9c.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg8kwr1qf.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpg8kwr1qf.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpg8kwr1qf.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg8kwr1qf.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj08ehgok.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpj08ehgok.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpj08ehgok.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpj08ehgok.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpj08ehgok.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpj08ehgok.jl:19\n   [5] top-level scope at /tmp/tmpj08ehgok.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpj08ehgok.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpj08ehgok.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpj08ehgok.jl:19\n   [5] top-level scope at /tmp/tmpj08ehgok.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpj08ehgok.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj08ehgok.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) >= 0.5\n  \
    \      return ceil(value)\n    else\n        return floor(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpgfkz9xzm.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpgfkz9xzm.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgfkz9xzm.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgfkz9xzm.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp148msq8u.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp148msq8u.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp148msq8u.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp148msq8u.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    n = parse(Float64, value)\n    if n < 0\n        return ceil(n)\n    else\n\
    \        return floor(n)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi_9qq6q4.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpi_9qq6q4.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi_9qq6q4.jl:30\ntest set: Test Failed at /tmp/tmpi_9qq6q4.jl:33\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi_9qq6q4.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi_9qq6q4.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi_9qq6q4.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpkwfgq__g.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpkwfgq__g.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkwfgq__g.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkwfgq__g.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp8baijfmd.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp8baijfmd.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8baijfmd.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8baijfmd.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp7hja93h6.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp7hja93h6.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7hja93h6.jl:31\ntest set: Test Failed at /tmp/tmp7hja93h6.jl:34\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7hja93h6.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7hja93h6.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7hja93h6.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5gao3h65.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp5gao3h65.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5gao3h65.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5gao3h65.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpg_h8dd0i.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpg_h8dd0i.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg_h8dd0i.jl:25\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbhiivyhy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpbhiivyhy.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbhiivyhy.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbhiivyhy.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxgi3c6tk.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpxgi3c6tk.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxgi3c6tk.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxgi3c6tk.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpoxqfcxwy.jl:36\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpoxqfcxwy.jl:36\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpoxqfcxwy.jl:32\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpoxqfcxwy.jl:30\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpwil1a8nt.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpwil1a8nt.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwil1a8nt.jl:25\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4fwrc10e.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp4fwrc10e.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4fwrc10e.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4fwrc10e.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpykwuume7.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpykwuume7.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpykwuume7.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpykwuume7.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4ygxhjpk.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp4ygxhjpk.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ygxhjpk.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4ygxhjpk.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpclouimjp.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpclouimjp.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpclouimjp.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpclouimjp.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_kr4uq95.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp_kr4uq95.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_kr4uq95.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_kr4uq95.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpo93_0mv9.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpo93_0mv9.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo93_0mv9.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo93_0mv9.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx_azzbh2.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpx_azzbh2.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx_azzbh2.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx_azzbh2.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4pdedslb.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp4pdedslb.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4pdedslb.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4pdedslb.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd9k8f3is.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpd9k8f3is.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd9k8f3is.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd9k8f3is.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwtfngjsm.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpwtfngjsm.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpwtfngjsm.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpwtfngjsm.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpwtfngjsm.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpwtfngjsm.jl:19\n   [5] top-level scope at /tmp/tmpwtfngjsm.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpwtfngjsm.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpwtfngjsm.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpwtfngjsm.jl:19\n   [5] top-level scope at /tmp/tmpwtfngjsm.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpwtfngjsm.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwtfngjsm.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpnhqe0v7i.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpnhqe0v7i.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnhqe0v7i.jl:31\ntest set: Test Failed at /tmp/tmpnhqe0v7i.jl:34\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnhqe0v7i.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnhqe0v7i.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnhqe0v7i.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnf49wo53.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpnf49wo53.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnf49wo53.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnf49wo53.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpg34lnbjx.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate(\"14.5\") == 15\\n  ArgumentError: invalid\
    \ base 10 digit \\'.\\' in \"14.5\"\\n  Stacktrace:\\n   [1] tryparse_internal(::Type{Int64},\
    \ ::String, ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\\n   [3] parse at ./parse.jl:238\
    \ [inlined]\\n   [4] closest_integer(::String) at /tmp/tmpg34lnbjx.jl:19\\n  \
    \ [5] top-level scope at /tmp/tmpg34lnbjx.jl:27\\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpg34lnbjx.jl:25\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpg34lnbjx.jl:28\\n  Test threw exception\\n  Expression: candidate(\"\
    -15.5\") == -16\\n  ArgumentError: invalid base 10 digit \\'.\\' in \"-15.5\"\\\
    n  Stacktrace:\\n   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64,\
    \ ::Int64, ::Bool) at ./parse.jl:132\\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\\n   [3] parse at ./parse.jl:238 [inlined]\\n   [4] closest_integer(::String)\
    \ at /tmp/tmpg34lnbjx.jl:19\\n   [5] top-level scope at /tmp/tmpg34lnbjx.jl:28\\\
    n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpg34lnbjx.jl:25\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpg34lnbjx.jl:29\\n  Test threw exception\\n  Expression: candidate(\"\
    15.3\") == 15\\n  ArgumentError: invalid base 10 digit \\'.\\' in \"15.3\"\\n\
    \  Stacktrace:\\n   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64,\
    \ ::Int64, ::Bool) at ./parse.jl:132\\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\\n   [3] parse at ./parse.jl:238 [inlined]\\n   [4] closest_integer(::String)\
    \ at /tmp/tmpg34lnbjx.jl:19\\n   [5] top-level scope at /tmp/tmpg34lnbjx.jl:29\\\
    n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [7] top-level scope at /tmp/tmpg34lnbjx.jl:25\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == round(value)\n        return\
    \ round(value)\n    elseif value > 0\n        return ceil(value)\n    else\n \
    \       return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptxm46zmc.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmptxm46zmc.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptxm46zmc.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptxm46zmc.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp990w4t_j.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp990w4t_j.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp990w4t_j.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp990w4t_j.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe_5glml6.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpe_5glml6.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe_5glml6.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe_5glml6.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbapgfi4b.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpbapgfi4b.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbapgfi4b.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbapgfi4b.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdyxx07uu.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpdyxx07uu.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdyxx07uu.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdyxx07uu.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa7s92xpa.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpa7s92xpa.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa7s92xpa.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa7s92xpa.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpno5t6hek.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpno5t6hek.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpno5t6hek.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpno5t6hek.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphgzd7ktf.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmphgzd7ktf.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphgzd7ktf.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphgzd7ktf.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpywh71oi1.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpywh71oi1.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpywh71oi1.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpywh71oi1.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7zlfrsrx.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp7zlfrsrx.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7zlfrsrx.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7zlfrsrx.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqey7b4d8.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpqey7b4d8.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpqey7b4d8.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpqey7b4d8.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpqey7b4d8.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpqey7b4d8.jl:19\n   [5] top-level scope at /tmp/tmpqey7b4d8.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpqey7b4d8.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpqey7b4d8.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpqey7b4d8.jl:19\n   [5] top-level scope at /tmp/tmpqey7b4d8.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpqey7b4d8.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqey7b4d8.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(value)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpvr4_1obk.jl:28\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpvr4_1obk.jl:28\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvr4_1obk.jl:26\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpzpelol_p.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpzpelol_p.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzpelol_p.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzpelol_p.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb85gl8vz.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpb85gl8vz.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb85gl8vz.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb85gl8vz.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - trunc(value) >= 0.5\n  \
    \      return ceil(value)\n    else\n        return trunc(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmplplu3gkt.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmplplu3gkt.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplplu3gkt.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplplu3gkt.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6bh9nqoi.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp6bh9nqoi.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6bh9nqoi.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6bh9nqoi.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpnusxkj2w.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpnusxkj2w.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnusxkj2w.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnusxkj2w.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphplotnvm.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmphplotnvm.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphplotnvm.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphplotnvm.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr_1rcn4b.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpr_1rcn4b.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr_1rcn4b.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr_1rcn4b.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpux8q6y8x.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpux8q6y8x.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpux8q6y8x.jl:31\ntest set: Test Failed at /tmp/tmpux8q6y8x.jl:34\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpux8q6y8x.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpux8q6y8x.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpux8q6y8x.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvtd8shde.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpvtd8shde.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvtd8shde.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvtd8shde.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5r2v33dx.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp5r2v33dx.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5r2v33dx.jl:30\ntest set: Test Failed at /tmp/tmp5r2v33dx.jl:33\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5r2v33dx.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5r2v33dx.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5r2v33dx.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_jleza6v.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp_jleza6v.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_jleza6v.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_jleza6v.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzv1d_h4c.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpzv1d_h4c.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzv1d_h4c.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpom2rd0mk.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpom2rd0mk.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpom2rd0mk.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpom2rd0mk.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpplxypcl0.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpplxypcl0.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpplxypcl0.jl:25\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpce_lwyki.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpce_lwyki.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpce_lwyki.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpce_lwyki.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpabcmy9pf.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpabcmy9pf.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpabcmy9pf.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpabcmy9pf.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6bohrtdj.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp6bohrtdj.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6bohrtdj.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6bohrtdj.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnv4be1s9.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpnv4be1s9.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnv4be1s9.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnv4be1s9.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfgjjf7x5.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpfgjjf7x5.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfgjjf7x5.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfgjjf7x5.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num < 0\n        return floor(num)\n\
    \    else\n        return ceil(num)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmplsiof112.jl:34\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmplsiof112.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmplsiof112.jl:30\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(Int64, value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmprgr3cfed.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmprgr3cfed.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprgr3cfed.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprgr3cfed.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp56q42chu.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp56q42chu.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56q42chu.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp56q42chu.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphy_c8og6.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmphy_c8og6.jl:19\n   [5] top-level\
    \ scope at /tmp/tmphy_c8og6.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmphy_c8og6.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmphy_c8og6.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmphy_c8og6.jl:19\n   [5] top-level scope at /tmp/tmphy_c8og6.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmphy_c8og6.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmphy_c8og6.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmphy_c8og6.jl:19\n   [5] top-level scope at /tmp/tmphy_c8og6.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmphy_c8og6.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphy_c8og6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == trunc(value)\n        return\
    \ trunc(value)\n    elseif value > trunc(value)\n        return trunc(value) +\
    \ 1\n    else\n        return trunc(value) - 1\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpd6a94s9s.jl:36\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpd6a94s9s.jl:36\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd6a94s9s.jl:32\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8s9153me.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp8s9153me.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8s9153me.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8s9153me.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpc1l9_loy.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpc1l9_loy.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc1l9_loy.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc1l9_loy.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"10\"\n        return 10\n    elseif value == \"15.3\"\n\
    \        return 15\n    else\n        return 0\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpabxu30oa.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 0 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpabxu30oa.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpabxu30oa.jl:31\ntest set: Test Failed at /tmp/tmpabxu30oa.jl:34\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: 0 == -16\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpabxu30oa.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpabxu30oa.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpabxu30oa.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprzqs85hi.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmprzqs85hi.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprzqs85hi.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprzqs85hi.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4rmgawry.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp4rmgawry.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4rmgawry.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4rmgawry.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpskdll4_d.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpskdll4_d.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpskdll4_d.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpskdll4_d.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpskdll4_d.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpskdll4_d.jl:19\n   [5] top-level scope at /tmp/tmpskdll4_d.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpskdll4_d.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpskdll4_d.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpskdll4_d.jl:19\n   [5] top-level scope at /tmp/tmpskdll4_d.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpskdll4_d.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpskdll4_d.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiwgdonxl.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpiwgdonxl.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiwgdonxl.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiwgdonxl.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpx87oz92s.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpx87oz92s.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpx87oz92s.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgesjmi47.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpgesjmi47.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgesjmi47.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgesjmi47.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkm0wmmvq.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpkm0wmmvq.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkm0wmmvq.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkm0wmmvq.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnwd6xcy3.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpnwd6xcy3.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpnwd6xcy3.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpnwd6xcy3.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpnwd6xcy3.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpnwd6xcy3.jl:19\n   [5] top-level scope at /tmp/tmpnwd6xcy3.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpnwd6xcy3.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpnwd6xcy3.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpnwd6xcy3.jl:19\n   [5] top-level scope at /tmp/tmpnwd6xcy3.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpnwd6xcy3.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnwd6xcy3.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp67ffgk90.jl:27\\n  Expression: candidate(\"\
    14.5\") == 15\\n   Evaluated: 14 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmp67ffgk90.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp67ffgk90.jl:25\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzal9_f3u.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpzal9_f3u.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpzal9_f3u.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpzal9_f3u.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpzal9_f3u.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpzal9_f3u.jl:19\n   [5] top-level scope at /tmp/tmpzal9_f3u.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpzal9_f3u.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpzal9_f3u.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpzal9_f3u.jl:19\n   [5] top-level scope at /tmp/tmpzal9_f3u.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpzal9_f3u.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzal9_f3u.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpb0vjgx0l.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpb0vjgx0l.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpb0vjgx0l.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpb0vjgx0l.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpb0vjgx0l.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpb0vjgx0l.jl:19\n   [5] top-level scope at /tmp/tmpb0vjgx0l.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpb0vjgx0l.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpb0vjgx0l.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpb0vjgx0l.jl:19\n   [5] top-level scope at /tmp/tmpb0vjgx0l.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpb0vjgx0l.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb0vjgx0l.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == round(value)\n        return\
    \ round(value)\n    elseif value > 0\n        return round(value) + 1\n    else\n\
    \        return round(value) - 1\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcbvaj8tz.jl:35\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -17 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpcbvaj8tz.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcbvaj8tz.jl:32\ntest set: Test Failed at /tmp/tmpcbvaj8tz.jl:36\n\
    \  Expression: candidate(\"15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcbvaj8tz.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcbvaj8tz.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcbvaj8tz.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjti63dug.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpjti63dug.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpjti63dug.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpjti63dug.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpjti63dug.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpjti63dug.jl:19\n   [5] top-level scope at /tmp/tmpjti63dug.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpjti63dug.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpjti63dug.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpjti63dug.jl:19\n   [5] top-level scope at /tmp/tmpjti63dug.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpjti63dug.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjti63dug.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpct1n78pa.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpct1n78pa.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpct1n78pa.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpct1n78pa.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # convert the string to a float\n    value = parse(Float64, value)\n \
    \   # round the float to the nearest integer\n    return round(value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpskga1eji.jl:30\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpskga1eji.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpskga1eji.jl:28\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpskga1eji.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz62g5qss.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpz62g5qss.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz62g5qss.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz62g5qss.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvx3a_0vq.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpvx3a_0vq.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpvx3a_0vq.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpvx3a_0vq.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpvx3a_0vq.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpvx3a_0vq.jl:19\n   [5] top-level scope at /tmp/tmpvx3a_0vq.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpvx3a_0vq.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpvx3a_0vq.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpvx3a_0vq.jl:19\n   [5] top-level scope at /tmp/tmpvx3a_0vq.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpvx3a_0vq.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvx3a_0vq.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num - floor(num) == 0.5\n        return\
    \ round(num)\n    else\n        return round(Int64, num)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpo_n4_vgp.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpo_n4_vgp.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo_n4_vgp.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo_n4_vgp.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpypy6jrdz.jl:34\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmpypy6jrdz.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpypy6jrdz.jl:30\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwsfe5xcp.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpwsfe5xcp.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwsfe5xcp.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwsfe5xcp.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprcwr2y92.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmprcwr2y92.jl:19\n   [5] top-level\
    \ scope at /tmp/tmprcwr2y92.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmprcwr2y92.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmprcwr2y92.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmprcwr2y92.jl:19\n   [5] top-level scope at /tmp/tmprcwr2y92.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmprcwr2y92.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmprcwr2y92.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmprcwr2y92.jl:19\n   [5] top-level scope at /tmp/tmprcwr2y92.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmprcwr2y92.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprcwr2y92.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw_63p96_.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpw_63p96_.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw_63p96_.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw_63p96_.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplfrmv1ov.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmplfrmv1ov.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplfrmv1ov.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplfrmv1ov.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmprcs6e4l2.jl:34\\n  Expression: candidate(\"\
    15.3\") == 15\\n   Evaluated: 16 == 15\\nStacktrace:\\n [1] top-level scope at\
    \ /tmp/tmprcs6e4l2.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmprcs6e4l2.jl:30\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwppsqji3.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpwppsqji3.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwppsqji3.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwppsqji3.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpndrtp0cs.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpndrtp0cs.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpndrtp0cs.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpndrtp0cs.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6ub6_c3s.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp6ub6_c3s.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ub6_c3s.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ub6_c3s.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp445g5lvn.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp445g5lvn.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp445g5lvn.jl:26\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp445g5lvn.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptlro3add.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmptlro3add.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptlro3add.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptlro3add.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return round(Int64,\
    \ value)\n    else\n        return round(Int64, value - 1)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpsrcu5243.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpsrcu5243.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsrcu5243.jl:30\ntest set: Test Failed at /tmp/tmpsrcu5243.jl:35\n\
    \  Expression: candidate(\"0\") == 0\n   Evaluated: -1 == 0\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpsrcu5243.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsrcu5243.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsrcu5243.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    value = round(value)\n    return value\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp6ap1bmjb.jl:29\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp6ap1bmjb.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ap1bmjb.jl:27\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ap1bmjb.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == round(value)\n        return\
    \ round(value)\n    elseif value > 0\n        return round(value) + 1\n    else\n\
    \        return round(value) - 1\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpaeru86y2.jl:35\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -17 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpaeru86y2.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaeru86y2.jl:32\ntest set: Test Failed at /tmp/tmpaeru86y2.jl:36\n\
    \  Expression: candidate(\"15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpaeru86y2.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaeru86y2.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaeru86y2.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxc4nus97.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpxc4nus97.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxc4nus97.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxc4nus97.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiscqy3yg.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpiscqy3yg.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiscqy3yg.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiscqy3yg.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt70iu5um.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpt70iu5um.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt70iu5um.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt70iu5um.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu8rum5vw.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpu8rum5vw.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu8rum5vw.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu8rum5vw.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # convert the string to a float\n    value = parse(Float64, value)\n \
    \   # round the float to the nearest integer\n    value = round(value)\n    #\
    \ convert the float to an integer\n    value = Int64(value)\n    # return the\
    \ integer\n    return value\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfza8uo0h.jl:34\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpfza8uo0h.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfza8uo0h.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfza8uo0h.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpogmc0lje.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpogmc0lje.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpogmc0lje.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpogmc0lje.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpl82rhpph.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpl82rhpph.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl82rhpph.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl82rhpph.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp552x_v1b.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp552x_v1b.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp552x_v1b.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp552x_v1b.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp04wfwgc5.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp04wfwgc5.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp04wfwgc5.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp04wfwgc5.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq6xjbxv9.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmpq6xjbxv9.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq6xjbxv9.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq6xjbxv9.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfht06fcm.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmpfht06fcm.jl:19\n   [5] top-level\
    \ scope at /tmp/tmpfht06fcm.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpfht06fcm.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpfht06fcm.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpfht06fcm.jl:19\n   [5] top-level scope at /tmp/tmpfht06fcm.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpfht06fcm.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmpfht06fcm.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmpfht06fcm.jl:19\n   [5] top-level scope at /tmp/tmpfht06fcm.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpfht06fcm.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfht06fcm.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpxfu_b7rd.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmpxfu_b7rd.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxfu_b7rd.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxfu_b7rd.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp4hw0tupm.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp4hw0tupm.jl:33\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hw0tupm.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4hw0tupm.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp44x9m6s3.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] top-level scope at /tmp/tmp44x9m6s3.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp44x9m6s3.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp44x9m6s3.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) == 0.5\n  \
    \      if value > 0\n            return floor(value) + 1\n        else\n     \
    \       return floor(value) - 1\n        end\n    else\n        return floor(value\
    \ + 0.5)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_fb4lxv4.jl:37\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -17 == -16\nStacktrace:\n [1] top-level scope at\
    \ /tmp/tmp_fb4lxv4.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_fb4lxv4.jl:34\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_fb4lxv4.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7oyvm0dl.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(::Type{Int64}, ::String,\
    \ ::Int64, ::Int64, ::Int64, ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64},\
    \ ::String; base::Nothing) at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n\
    \   [4] closest_integer(::String) at /tmp/tmp7oyvm0dl.jl:19\n   [5] top-level\
    \ scope at /tmp/tmp7oyvm0dl.jl:27\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp7oyvm0dl.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmp7oyvm0dl.jl:28\n  Test threw exception\n  Expression: candidate(\"\
    -15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"-15.5\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmp7oyvm0dl.jl:19\n   [5] top-level scope at /tmp/tmp7oyvm0dl.jl:28\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp7oyvm0dl.jl:25\n  \ntest set: Error During\
    \ Test at /tmp/tmp7oyvm0dl.jl:29\n  Test threw exception\n  Expression: candidate(\"\
    15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"15.3\"\n  Stacktrace:\n\
    \   [1] tryparse_internal(::Type{Int64}, ::String, ::Int64, ::Int64, ::Int64,\
    \ ::Bool) at ./parse.jl:132\n   [2] parse(::Type{Int64}, ::String; base::Nothing)\
    \ at ./parse.jl:238\n   [3] parse at ./parse.jl:238 [inlined]\n   [4] closest_integer(::String)\
    \ at /tmp/tmp7oyvm0dl.jl:19\n   [5] top-level scope at /tmp/tmp7oyvm0dl.jl:29\n\
    \   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmp7oyvm0dl.jl:25\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7oyvm0dl.jl:23\n"
  exit_code: 1
  status: SyntaxError
