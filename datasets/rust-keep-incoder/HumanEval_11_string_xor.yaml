name: HumanEval_11_string_xor
language: rust
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
  \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    let mut res = String::new();\n    for i in 0..a.len() {\n     \
    \   res.push_str(&a[i..].iter().filter(|&x| x == b[i]).collect::<String>());\n\
    \    }\n    res", '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n  \
    \      res.push_str(&format!(\"{:b}\", c ^ c));\n    }\n    res", '    a.to_owned()
    & b.to_owned()', "    a.to_string() + b.to_string()\n        .chars()\n      \
    \  .map(|c| if c == '1' { 0 } else { 1 })\n        .fold(String::new(), |mut acc,\
    \ x| {\n            acc.push_str(&x.to_string());\n            acc\n        })",
  "    let mut result = String::new();\n    for &c in &a & &b {\n        match c {\n\
    \            '0' => result.push('0'),\n            '1' => result.push('1'),\n\
    \            _ => panic!(\"String contains invalid character: {}\", c),\n    \
    \    }\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    a.to_string() + b.to_string()\n        .chars()\n\
    \        .filter(|c| c.to_digit(16).is_some())\n        .fold(String::new(), |mut\
    \ acc, c| {\n            acc.push_str(&c.to_digit(16).unwrap().to_string());\n\
    \            acc\n        })", "    a.to_string() + b.to_string()\n        .chars()\n\
    \        .filter(|c| c == '0' || c == '1')\n        .collect::<Vec<_>>()\n   \
    \     .iter()\n        .map(|c| if c == '0' { 0 } else { 1 })\n        .fold(0,\
    \ |x, y| x ^ y)\n        .to_string()", "    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_string()", '    a.to_owned() & b.to_owned()',
  '    a.to_owned() & b.to_owned()', '    a.chars().zip(b.chars()).map(|(a, b)| a
    ^ b).collect()', "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|&x|\
    \ x == b[i..]).collect::<String>());\n    }\n    res", '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()\n\
    \        .to_string()", "    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result", "  \
    \  a.to_string() + b.to_string()\n        .chars()\n        .filter(|c| c == '0'\
    \ || c == '1')\n        .collect::<Vec<_>>()\n        .iter()\n        .map(|c|\
    \ match c {\n            '0' => '1',\n            '1' => '0',\n            _ =>\
    \ panic!(\"String contains invalid character: {}\", c),\n        })\n        .collect::<String>()",
  "    let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i\
    \ ^ b.as_bytes()[i as usize]]);\n    }\n    res", "    a.to_string() + b.to_string()\n\
    \        .chars()\n        .filter(|c| c == '0' || c == '1')\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|c| match c {\n            '0' => '1',\n      \
    \      '1' => '0',\n            _ => panic!(\"Invalid character in input\"),\n\
    \        })\n        .collect::<String>()", "    let mut res = String::new();\n\
    \    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|c| b[i]\
    \ == c).collect::<String>());\n    }\n    res", "    a.to_string() + b.to_string()\n\
    \        .chars()\n        .filter(|c| c.is_ascii())\n        .fold(String::new(),\
    \ |mut acc, c| {\n            acc.push_str(&format!(\"{:02x}\", c ^ 0xff));\n\
    \            acc\n        })", '    a.chars().zip(b.chars()).map(|(a, b)| a ^
    b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', " \
    \   a.to_string() + b.to_string()\n        .chars()\n        .filter(|c| c ==\
    \ '0' || c == '1')\n        .collect::<Vec<_>>()\n        .iter()\n        .map(|c|\
    \ match c {\n            '0' => '1',\n            '1' => '0',\n            _ =>\
    \ panic!(\"Unexpected character in input: {}\", c),\n        })\n        .collect::<String>()",
  "    a.to_string() + b.to_string()\n        .chars()\n        .filter(|c| c.to_digit(16).is_some())\n\
    \        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_digit(16).unwrap().to_string());\n\
    \            acc\n        })", "    let mut res = String::new();\n    for i in\
    \ 0..a.len() {\n        res.push_str(&a[i..].iter().map(|x| if x == b[i] { x }\
    \ else { 0 }).collect());\n    }\n    res", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect::<String>()', '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', "    let mut res =\
    \ String::new();\n    for i in 0..a.len() {\n        res.push_str(&a.chars()[i\
    \ as usize] ^ &b.chars()[i as usize]);\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n    }\n    res",
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result .= if *a != *b { 1 } else { 0 };\n    }\n    result", "  \
    \  let mut res = String::new();\n    for &c in &a { res.push(c); }\n    for &c\
    \ in &b { res.push(c); }\n    res", "    let mut result = String::new();\n   \
    \ for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()', "    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect::<String>());\n    }\n    res", '    a.to_owned()
    & b.to_owned()', "    a.to_string() + b.to_string()\n        .chars()\n      \
    \  .filter(|c| c == '1')\n        .collect::<String>()\n        .iter()\n    \
    \    .cloned()\n        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_string());\n\
    \            acc\n        })", "    let mut result = String::new();\n    for i\
    \ in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result", "  \
    \  let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&b|\
    \ b == '1').collect::<String>());\n    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n    }\n    res", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", '    a.to_owned() & b.to_owned()',
  '    a.to_owned() & b.to_owned()', "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut result = String::new();\n    for &c in &a & &b {\n        if *c !=\
    \ '0' {\n            result.push(*c);\n        }\n    }\n    result", "    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut res = String::new();\n    for i in\
    \ 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|c| b[i] == c).collect::<String>());\n\
    \    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', "    let mut res =\
    \ String::new();\n    for i in 0..a.len() {\n        res.push_str(&a.chars()\n\
    \            .skip(i)\n            .take(b.len())\n            .map(|c| match\
    \ c {\n                b'0' => b'1',\n                b'1' => b'0',\n        \
    \        _ => panic!(\"Unexpected character in input: {}\", c),\n            })\n\
    \            .collect::<String>());\n    }\n    res", "    let mut res = String::new();\n\
    \    for i in 0..a.len() {\n        res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n\
    \    }\n    res", '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n    }\n    res", "    let mut res = String::new();\n\
    \    for i in 0..a.len() {\n        if a[i] != b[i] {\n            res.push_str(&format!(\"\
    {}\", a[i] ^ b[i]));\n        } else {\n            res.push(a[i]);\n        }\n\
    \    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  "    a.to_string() + b.to_string()\n        .chars()\n        .filter(|c| c == '0'\
    \ || c == '1')\n        .fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_string());\n\
    \            acc.push('0');\n            acc\n        })\n        .to_string()",
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for (a, b) in\
    \ a.chars().zip(b.chars()) {\n        result .push((a ^ b) as char);\n    }\n\
    \    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)|
    a ^ b).collect()', "    let mut res = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        if *c != *c {\n            res.push(*c);\n        }\n    }\n    res",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        *result += *a ^ *b;\n    }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        res.push_str(c.0);\n        res.push_str(c.1);\n    }\n    res",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut res = String::new();\n\
    \    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|&c| c\
    \ == '1').count() as char);\n    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].chars().filter(|&c|\
    \ c == '1').count() as char);\n    }\n    res", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].iter().filter(|&x| x == b[i]).collect::<String>());\n\
    \    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut res = String::new();\n    for &c in &a { res.push(c); }\n    for &c\
    \ in &b { res.push(c); }\n    res", "    let mut res = String::new();\n    for\
    \ i in 0..a.len() {\n        res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n\
    \    }\n    res", "    a.to_string() + b.to_string()\n        .chars()\n     \
    \   .map(|c| if c == '0' || c == '1' { c == '0' ? '1' : '0' } else { c })\n  \
    \      .collect()", "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a[i] != b[i] {\n            result.push('a');\n        } else\
    \ {\n            result.push('0');\n        }\n    }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].chars().filter(|c| b[i..].contains(&c)).collect::<String>());\n\
    \    }\n    res", "    a.to_string() + b.to_string()\n        .chars()\n     \
    \   .filter(|c| c == '0' || c == '1')\n        .fold(String::new(), |mut acc,\
    \ c| {\n            acc.push_str(&c.to_string());\n            acc.push('0');\n\
    \            acc\n        })\n        .to_string()", "    let mut result = String::new();\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        result .= if *a != *b {\
    \ 1 } else { 0 };\n    }\n    result", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result",
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    a.to_string() + b.to_string()\n        .chars()\n\
    \        .filter(|c| c == '0' || c == '1')\n        .fold(String::new(), |mut\
    \ acc, c| {\n            acc.push_str(&c ^ &c.to_string());\n            acc\n\
    \        })", "    let mut result = String::new();\n    for &c in &a & &b {\n\
    \        if *c != '0' {\n            result.push(*c);\n        }\n    }\n    result",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result .push((a ^ b) as char);\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result", "  \
    \  let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|&c|\
    \ b[i..].chars().any(|&c| c == c)).collect::<String>());\n    }\n    res", " \
    \   let mut res = String::new();\n    for i in 0..a.len() {\n        if a[i] !=\
    \ b[i] {\n            res.push_str(&format!(\"{}\", a[i] ^ b[i]));\n        }\
    \ else {\n            res.push_str(&format!(\"{}\", a[i]));\n        }\n    }\n\
    \    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)|
    a ^ b).collect()', '    a.to_owned() & b.to_owned()', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    a.to_string() + b.to_string()\n        .chars()\n\
    \        .filter(|c| c == '0' || c == '1')\n        .collect::<String>()\n   \
    \     .iter()\n        .map(|c| if c == '0' { 0 } else { 1 })\n        .fold(0,\
    \ |x, y| x ^ y)\n        .to_string()", '    a.to_owned() & b.to_owned()', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].chars().filter(|c| b[c..].is_empty()).collect::<String>());\n\
    \    }\n    res", '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a[i] != b[i] {\n            result.push('a');\n        } else\
    \ {\n            result.push('0');\n        }\n    }\n    result", "    let mut\
    \ result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    a.to_string() + b.to_string()\n        .chars()\n\
    \        .filter(|c| c == '0' || c == '1')\n        .fold(String::new(), |mut\
    \ acc, c| {\n            acc.push_str(&c ^ &c.to_string());\n            acc\n\
    \        })", "    let mut res = String::new();\n    for i in 0..a.len() {\n \
    \       res.push_str(&a[i..].iter().filter(|&b| b == '1').collect::<String>());\n\
    \    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n    }\n    res", "    a.to_string() + b.to_string()\n\
    \        .chars()\n        .filter(|c| c == '1')\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .fold(String::new(), |mut acc, x| {\n            acc.push_str(&x.to_string());\n\
    \            acc\n        })", '    a.chars().zip(b.chars()).map(|(a, b)| a ^
    b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', " \
    \   a.to_string().chars().zip(b.to_string().chars())\n        .map(|(a, b)| a\
    \ ^ b)\n        .collect()\n        .to_owned()", "    a.to_string() + b.to_string()\n\
    \        .chars()\n        .filter(|c| c == '0' || c == '1')\n        .fold(String::new(),\
    \ |mut acc, c| {\n            acc.push_str(&c ^ &c.to_string());\n           \
    \ acc\n        })", "    a.to_string() + b.to_string()\n        .chars()\n   \
    \     .filter(|c| c == '0' || c == '1')\n        .fold(String::new(), |mut acc,\
    \ c| {\n            acc.push_str(&c.to_string());\n            acc.push('0');\n\
    \            acc\n        })\n        .to_string()", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', "    let mut res =\
    \ String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&b|\
    \ b == '1').collect::<String>());\n    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_owned()\n        .to_string()", '    a.to_owned()
    & b.to_owned()', "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        *result += if *c != *c { *c } else { 0 };\n    }\n    result", " \
    \   let mut result = String::new();\n    for i in 0..a.len() {\n        if a[i]\
    \ != b[i] {\n            result.push('a');\n        } else {\n            result.push('0');\n\
    \        }\n    }\n    result", "    a.to_string() + b.to_string()\n        .chars()\n\
    \        .map(|c| match c {\n            '0' | '1' => c,\n            _ => panic!(\"\
    String contains invalid character: {}\", c),\n        })\n        .collect::<String>()",
  "    let mut res = String::new();\n    for &c in &a { res += &c ^ &b[c.to_digit(10).unwrap()];\
    \ }\n    res", "    let mut res = String::new();\n    for i in 0..a.len() {\n\
    \        res.push_str(&a[i..].iter().filter(|&x| x == b[i..]).collect::<String>());\n\
    \    }\n    res", '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()', "    let\
    \ mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n       \
    \ if *c != *c {\n            res.push_str(&format!(\"{:02x}\", *c));\n       \
    \ } else {\n            res.push_str(&format!(\"{:02x}\", *c ^ 1));\n        }\n\
    \    }\n    res", '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()',
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        res.push_str(c.0 ^ c.1);\n    }\n    res", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', "    let mut result\
    \ = String::new();\n    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n\
    \    }\n    result", "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i ^ b.len()]);\n    }\n    res", '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  '    a.to_owned() & b.to_owned()', '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  '    a.to_owned() & b.to_owned()', '    a.to_owned() & b.to_owned()', "    a.to_string()\
    \ + b.to_string()\n        .chars()\n        .filter(|c| c == '0' || c == '1')\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| if c == '0' {\
    \ 0 } else { 1 })\n        .fold(0, |acc, x| acc ^ x)\n        .to_string()",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()", "   \
    \ let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for &c in &a { res.push(c);\
    \ }\n    for &c in &b { res.push(c); }\n    res", "    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()", '    a.to_owned()
    & b.to_owned()', "    a.to_string() + b.to_string()\n        .chars()\n      \
    \  .filter(|c| c == '0' || c == '1')\n        .collect::<Vec<_>>()\n        .iter()\n\
    \        .map(|c| match c {\n            '0' => '1',\n            '1' => '0',\n\
    \            _ => panic!(\"Unexpected character in input: {}\", c),\n        })\n\
    \        .collect::<String>()", '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_owned()", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  '    a.to_owned() & b.to_owned()', "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut res = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        res.push_str(&format!(\"{:02x}\", a ^ b));\n    }\n    res", '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    a.to_string() + b.to_string()\n        .chars()\n        .filter(|c| c != '0')\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| c ^ 1)\n    \
    \    .collect::<String>()", "    a.to_string() + b.to_string()\n        .chars()\n\
    \        .filter(|c| c.to_digit(16).is_some())\n        .fold(String::new(), |mut\
    \ acc, c| {\n            acc.push_str(&c.to_digit(16).unwrap().to_string());\n\
    \            acc\n        })", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].iter().filter(|&x| x == b[i]).collect::<String>());\n\
    \    }\n    res", "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        result.push((*c).xor(*c).to_string());\n    }\n    result", "   \
    \ let mut result = String::new();\n    for &c in &a { result.push(c); }\n    for\
    \ &c in &b { result.push(c); }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i\
    \ ^ b.len()]);\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].iter().filter(|&x| x == b[i]).collect::<String>());\n\
    \    }\n    res", '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect::<String>()',
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result"]
stop_tokens:
- "\n}"
