name: HumanEval_149_sorted_list_sum
language: lua
results:
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j], sorted_list[i] = current_word,\
    \ next_word\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpipfo86ni.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpipfo86ni.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_index_size = #sorted_list\n  while sorted_list_index\
    \ < sorted_list_size do\n    local current_word = sorted_list[sorted_list_index]\n\
    \    local current_word_size = #current_word\n    local current_word_index = 1\n\
    \    while current_word_index < current_word_size do\n      local next_word =\
    \ sorted_list[sorted_list_index + current_word_index]\n      local next_word_size\
    \ = #next_word\n      local next_word_index = 1\n      while next_word_index <\
    \ next_word_size do\n        if current_word_size == next_word_size then\n   \
    \       -- If the current word is the same length as the next word,\n        \
    \  -- then compare the two words and sort the list alphabetically.\n         \
    \ if current_word < next_word then\n            -- If the current word is alphabetically\
    \ less than the next word,\n            -- then swap the two words and continue\
    \ to the next word.\n            sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n            sorted_list[sorted_list_index + next_word_index] =\
    \ current_word\n          else\n            -- If the current word is alphabetically\
    \ greater than the next word,\n            -- then swap the two words and continue\
    \ to the next word.\n            sorted_list[sorted_list_index + current_word_index]\
    \ = current_word\n            sorted_list[sorted_list_index + next_word_index]\
    \ = next_word\n          end\n        else\n          -- If the current word is\
    \ longer than the next word,\n          -- then swap the two words and continue\
    \ to the next word.\n          sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n        end\n        next_word_index = next_word_index + 1\n  \
    \    end\n      current_word_index = current_word_index + 1\n    end\n    sorted_list_index\
    \ = sorted_list_index + 1\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphc5hpn_7.lua:59:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmphc5hpn_7.lua:59:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for i = 1, #lst do\n    local word = lst[i]\n  \
    \  local length = #word\n    if length % 2 == 1 then\n      sorted_list[#sorted_list\
    \ + 1] = word\n    end\n  end\n  table.sort(sorted_list)\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr1a_xro8.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpr1a_xro8.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_index_size = #sorted_list\n  while sorted_list_index\
    \ <= sorted_list_size do\n    local current_word = sorted_list[sorted_list_index]\n\
    \    local current_word_size = #current_word\n    local current_word_index = 1\n\
    \    local current_word_index_size = #current_word\n    while current_word_index\
    \ <= current_word_size do\n      local next_word = sorted_list[sorted_list_index\
    \ + current_word_index]\n      local next_word_size = #next_word\n      local\
    \ next_word_index = 1\n      local next_word_index_size = #next_word\n      if\
    \ current_word_size == next_word_size then\n        if current_word_index == next_word_index\
    \ then\n          sorted_list[sorted_list_index + current_word_index] = nil\n\
    \          sorted_list_size = sorted_list_size - 1\n          sorted_list_index\
    \ = sorted_list_index - 1\n          sorted_list_index_size = sorted_list_index_size\
    \ - 1\n        else\n          sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n          sorted_list_size = sorted_list_size - 1\n          sorted_list_index\
    \ = sorted_list_index - 1\n          sorted_list_index_size = sorted_list_index_size\
    \ - 1\n        end\n      else\n        if current_word_index > next_word_index\
    \ then\n          sorted_list[sorted_list_index + current_word_index] = nil\n\
    \          sorted_list_size = sorted_list_size - 1\n          sorted_list_index\
    \ = sorted_list_index - 1\n          sorted_list_index_size = sorted_list_index_size\
    \ - 1\n        else\n          local word_length = current_word_size - next_word_size\n\
    \          local word_length_difference = word_length - current_word_length\n\
    \          if word_length_difference > 0 then\n            local word_length_difference_index\
    \ = 1\n            local word_length_difference_index_size = word_length_difference\n\
    \            while word_length_difference_index <= word_length_difference_index_size\
    \ do\n              local next_next_word = sorted_list[sorted_list_index + word_length_difference_index\
    \ + 1]\n              local next_next_word_size = #next_next_word\n          \
    \    local next_next_word_index = 1\n              local next_next_word_index_size\
    \ = #next_next_word\n              if next_next_word_size == next_word_size then\n\
    \                if next_next_word_index == next_word_index then\n           \
    \       sorted_list[sorted_list_index + word_length_difference_index + 1] = nil\n\
    \                  sorted_list_size = sorted_list_size - 1\n                 \
    \ sorted_list_index = sorted_list_index - 1\n                  sorted_list_index_size\
    \ = sorted_list_index_size - 1\n                else\n                  sorted_list[sorted_list_index\
    \ + word_length_difference_index + 1] = next_next_word\n                  sorted_list_size\
    \ = sorted_list_size - 1\n                  sorted_list_index = sorted_list_index\
    \ - 1\n                  sorted_list_index_size = sorted_list_index_size - 1\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpmhxopgg2.lua:82: 'end' expected (to close 'if' at line 59)\
    \ near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    if current_word_length % 2 == 1 then\n      -- If the current\
    \ word has an odd length, delete it.\n      sorted_list[sorted_list_index] = nil\n\
    \      sorted_list_length = sorted_list_length - 1\n      sorted_list_index =\
    \ sorted_list_index - 1\n    else\n      -- If the current word has an even length,\
    \ sort the list alphabetically.\n      -- The function should return a list of\
    \ strings in sorted order.\n      -- You may assume that all words will have the\
    \ same length.\n      sorted_list[sorted_list_index] = current_word\n      sorted_list_length\
    \ = sorted_list_length - 1\n      sorted_list_index = sorted_list_index - 1\n\
    \    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6bl0pko6.lua:20:\
    \ attempt to get length of local 'current_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmp6bl0pko6.lua:41: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for i = 1, #lst do\n    local word = lst[i]\n    local\
    \ length = #word\n    if length % 2 == 1 then\n      sorted_lst[#sorted_lst +\
    \ 1] = word\n    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a\
    \ < #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn7z9scu_.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpn7z9scu_.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  local sorted_length = #lst\n\
    \  for i = 1, sorted_length do\n    local word = lst[i]\n    local index = sorted_index\n\
    \    for j = 1, sorted_length do\n      if sorted_index > i then\n        if sorted_index\
    \ > j then\n          local word_1 = lst[j]\n          local word_2 = lst[i]\n\
    \          local word_1_length = #word_1\n          local word_2_length = #word_2\n\
    \          if word_1_length < word_2_length then\n            sorted_index = j\n\
    \          else\n            sorted_index = i\n          end\n        else\n \
    \         sorted_index = j\n        end\n      else\n        sorted_index = j\n\
    \      end\n    end\n    table.insert(sorted_lst, word)\n  end\n  return sorted_lst\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppj2qzdky.lua:48:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmppj2qzdky.lua:48:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      if current_word_index == current_word_size then\n        sorted_list[sorted_list_index]\
    \ = current_word\n        break\n      end\n      local next_word = sorted_list[sorted_list_index\
    \ + current_word_index]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n      else\n        sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n        sorted_list_index = sorted_list_index + current_word_index\n\
    \      end\n      current_word_index = current_word_index + next_word_size\n \
    \   end\n    sorted_list_index = sorted_list_index + current_word_size\n  end\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2unkxh5y.lua:45:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp2unkxh5y.lua:45:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for i = 1, #lst do\n    local word = lst[i]\n    local\
    \ length = #word\n    if length % 2 == 1 then\n      sorted_lst[#sorted_lst +\
    \ 1] = word\n    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a\
    \ < #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpug7jh0tm.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpug7jh0tm.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    local current_word_index = 1\n    while current_word_index\
    \ < current_word_length do\n      local next_word = sorted_list[sorted_list_index\
    \ + current_word_index]\n      local next_word_length = #next_word\n      if next_word_length\
    \ < current_word_length then\n        sorted_list[sorted_list_index + current_word_index]\
    \ = nil\n      else\n        local next_word_index = 1\n        while next_word_index\
    \ < next_word_length do\n          if next_word[next_word_index] == current_word[current_word_index]\
    \ then\n            sorted_list[sorted_list_index + current_word_index] = nil\n\
    \          else\n            local next_word_index = next_word_index + 1\n   \
    \       end\n        end\n      end\n      current_word_index = current_word_index\
    \ + 1\n    end\n    sorted_list_index = sorted_list_index + 1\n  end\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplqmzjdx_.lua:20:\
    \ attempt to get length of local 'current_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmplqmzjdx_.lua:47: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = {}\n  local sorted_length = {}\n\
    \  local sorted_length_index = {}\n  local sorted_length_total = 0\n  local sorted_length_total_index\
    \ = 0\n  for i = 1, #lst do\n    local length = string.len(lst[i])\n    sorted_length[length]\
    \ = sorted_length[length] + 1\n    sorted_length_index[length] = i\n    sorted_length_total\
    \ = sorted_length_total + 1\n  end\n  for i = 1, #lst do\n    local length = string.len(lst[i])\n\
    \    if sorted_length[length] == 1 then\n      sorted_lst[sorted_length_index[length]]\
    \ = lst[i]\n      sorted_index[sorted_length_index[length]] = i\n      sorted_length_total_index\
    \ = sorted_length_total_index + 1\n    end\n  end\n  for i = 1, #lst do\n    local\
    \ length = string.len(lst[i])\n    if sorted_length[length] > 1 then\n      local\
    \ j = 1\n      while j <= sorted_length[length] do\n        local k = j\n    \
    \    while k <= sorted_length[length] and string.len(lst[sorted_index[k]]) > j\
    \ do\n          k = k + 1\n        end\n        local tmp = lst[sorted_index[k]]\n\
    \        lst[sorted_index[k]] = lst[sorted_index[j]]\n        lst[sorted_index[j]]\
    \ = tmp\n        j = j + 1\n      end\n    end\n  end\n  for i = 1, #lst do\n\
    \    local length = string.len(lst[i])\n    sorted_length[length] = sorted_length[length]\
    \ - 1\n    if sorted_length[length] == 0 then\n      sorted_lst[sorted_length_total_index\
    \ + i] = lst[i]\n    end\n  end\n  return sorted_lst\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplcjrp5c0.lua:23:\
    \ attempt to perform arithmetic on field '?' (a nil value)\nstack traceback:\n\
    \t/tmp/tmplcjrp5c0.lua:64: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  for i\
    \ = 1, sorted_list_length do\n    local current_word = sorted_list[i]\n    local\
    \ current_word_length = #current_word\n    for j = i + 1, sorted_list_length do\n\
    \      local next_word = sorted_list[j]\n      local next_word_length = #next_word\n\
    \      if next_word_length < current_word_length then\n        sorted_list[j],\
    \ sorted_list[i] = sorted_list[i], sorted_list[j]\n      end\n    end\n  end\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppas1bvio.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmppas1bvio.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ if sorted_index == #sorted_lst then\n      table.insert(sorted_lst, lst[i])\n\
    \      sorted_index = i + 1\n    elseif sorted_index == #lst then\n      table.insert(sorted_lst,\
    \ lst[i])\n      sorted_index = i + 1\n    elseif sorted_index <= #sorted_lst\
    \ then\n      if sorted_lst[sorted_index] < lst[i] then\n        table.insert(sorted_lst,\
    \ lst[i])\n        sorted_index = i + 1\n      else\n        table.insert(sorted_lst,\
    \ sorted_lst[sorted_index])\n        table.insert(sorted_lst, lst[i])\n      \
    \  sorted_index = i + 1\n      end\n    end\n  end\n  return sorted_lst\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoqduvt2v.lua:41:\
    \ expected: {\"aa\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpoqduvt2v.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = 0\n  for i = 1, #lst\
    \ do\n    local length = string.len(lst[i])\n    if sorted_list_length < length\
    \ then\n      sorted_list[#sorted_list + 1] = lst[i]\n      sorted_list_length\
    \ = length\n    else\n      local j = i\n      while j > 0 and string.len(lst[j\
    \ - 1]) > length do\n        sorted_list[#sorted_list + 1] = lst[j]\n        j\
    \ = j - 1\n      end\n      sorted_list[#sorted_list + 1] = lst[j]\n    end\n\
    \  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu77f9ho2.lua:24:\
    \ bad argument #1 to 'len' (string expected, got nil)\nstack traceback:\n\t/tmp/tmpu77f9ho2.lua:24:\
    \ in function 'candidate'\n\t/tmp/tmpu77f9ho2.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j] = nil\n      elseif next_word_size\
    \ > current_word_size then\n        sorted_list[i] = current_word\n        sorted_list[j]\
    \ = next_word\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjjt4pkim.lua:37:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpjjt4pkim.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ v)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n  return\
    \ sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphtt2dkb1.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmphtt2dkb1.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_index_size = #sorted_list\n  while sorted_list_index\
    \ < sorted_list_size do\n    local current_word = sorted_list[sorted_list_index]\n\
    \    local current_word_size = #current_word\n    local current_word_index = 1\n\
    \    while current_word_index < current_word_size do\n      local next_word =\
    \ sorted_list[sorted_list_index + current_word_index]\n      local next_word_size\
    \ = #next_word\n      local next_word_index = 1\n      while next_word_index <\
    \ next_word_size do\n        local current_word_length = current_word_index +\
    \ 1\n        local next_word_length = next_word_index + 1\n        if current_word_length\
    \ == next_word_length then\n          sorted_list[sorted_list_index + current_word_index]\
    \ = sorted_list[sorted_list_index + current_word_index + 1]\n          sorted_list_index\
    \ = sorted_list_index + 1\n          sorted_list_index_size = sorted_list_index_size\
    \ - 1\n          current_word_index = current_word_index + 1\n        elseif current_word_length\
    \ > next_word_length then\n          sorted_list[sorted_list_index + current_word_index]\
    \ = sorted_list[sorted_list_index + current_word_index + 1]\n          sorted_list_index\
    \ = sorted_list_index + 1\n          sorted_list_index_size = sorted_list_index_size\
    \ - 1\n          current_word_index = current_word_index + 1\n        else\n \
    \         sorted_list[sorted_list_index + current_word_index] = next_word\n  \
    \        sorted_list_index = sorted_list_index + 1\n          sorted_list_index_size\
    \ = sorted_list_index_size - 1\n          current_word_index = current_word_index\
    \ + 1\n          next_word_index = next_word_index + 1\n        end\n      end\n\
    \    end\n    sorted_list_index = sorted_list_index + 1\n    sorted_list_index_size\
    \ = sorted_list_index_size - 1\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ v)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n  return\
    \ sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyyv65k6m.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpyyv65k6m.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      if next_word_size % 2 ~= 0 then\n\
    \        sorted_list[sorted_list_index + current_word_index] = next_word\n   \
    \   end\n      current_word_index = current_word_index + next_word_size\n    end\n\
    \    sorted_list_index = sorted_list_index + current_word_size\n  end\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5ho1r7ck.lua:38:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp5ho1r7ck.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  for i = 1, sorted_list_length\
    \ do\n    local word = lst[i]\n    local word_length = #word\n    if word_length\
    \ % 2 == 1 then\n      table.insert(sorted_list, word)\n    end\n  end\n  table.sort(sorted_list)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuwlidsv3.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpuwlidsv3.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ local word = lst[i]\n    local length = #word\n    if length % 2 == 1 then\n\
    \      sorted_lst[sorted_index] = word\n      sorted_index = sorted_index + 1\n\
    \    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a < #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5n2yquv1.lua:32:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp5n2yquv1.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_keys = {}\n  for i = 1, #lst do\n   \
    \ local key = lst[i]\n    sorted_keys[#sorted_keys + 1] = key\n    sorted_lst[#sorted_lst\
    \ + 1] = key\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n\
    \  table.sort(sorted_keys, function(a, b) return #a < #b end)\n  for i = 1, #sorted_lst\
    \ do\n    sorted_lst[i] = sorted_keys[i - 1]\n  end\n  return sorted_lst\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4aphdaef.lua:33:\
    \ expected: {\"aa\"}\nactual: {2=\"a\", 3=\"aa\"}\nstack traceback:\n\t/tmp/tmp4aphdaef.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_index_size = #sorted_list\n  local sorted_list_index_value\
    \ = 1\n  local sorted_list_index_value_max = 1\n  local sorted_list_index_value_min\
    \ = 1\n  local sorted_list_index_value_sum = 1\n  local sorted_list_index_value_sum_size\
    \ = 1\n  local sorted_list_index_value_sum_max = 1\n  local sorted_list_index_value_sum_min\
    \ = 1\n  local sorted_list_index_value_sum_sum = 1\n  local sorted_list_index_value_sum_sum_size\
    \ = 1\n  local sorted_list_index_value_sum_sum_max = 1\n  local sorted_list_index_value_sum_sum_min\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum = 1\n  local sorted_list_index_value_sum_sum_sum_size\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_max = 1\n  local sorted_list_index_value_sum_sum_sum_min\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum = 1\n  local sorted_list_index_value_sum_sum_sum_sum_size\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_max = 1\n  local sorted_list_index_value_sum_sum_sum_sum_min\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_sum = 1\n  local sorted_list_index_value_sum_sum_sum_sum_size\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_max = 1\n  local sorted_list_index_value_sum_sum_sum_sum_min\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_sum = 1\n  local sorted_list_index_value_sum_sum_sum_sum_size\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_max = 1\n  local sorted_list_index_value_sum_sum_sum_sum_min\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_sum = 1\n  local sorted_list_index_value_sum_sum_sum_sum_size\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_max = 1\n  local sorted_list_index_value_sum_sum_sum_sum_min\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_sum = 1\n  local sorted_list_index_value_sum_sum_sum_sum_size\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_max = 1\n  local sorted_list_index_value_sum_sum_sum_sum_min\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_sum = 1\n  local sorted_list_index_value_sum_sum_sum_sum_size\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_max = 1\n  local sorted_list_index_value_sum_sum_sum_sum_min\
    \ = 1\n  local sorted_list_index_value_sum_sum_sum_sum_sum = 1\n  \nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1d65bfmm.lua:73: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_index_size = #sorted_list\n  while sorted_list_index\
    \ < sorted_list_size do\n    local current_word = sorted_list[sorted_list_index]\n\
    \    local current_word_size = #current_word\n    local current_word_index = 1\n\
    \    while current_word_index < current_word_size do\n      local next_word =\
    \ sorted_list[sorted_list_index + current_word_index]\n      local next_word_size\
    \ = #next_word\n      if next_word_size % 2 ~= 0 then\n        sorted_list[sorted_list_index\
    \ + current_word_index] = next_word\n      else\n        local current_word_index_size\
    \ = #current_word\n        local current_word_index_index = 1\n        while current_word_index_index\
    \ < current_word_index_size do\n          local next_next_word = sorted_list[sorted_list_index\
    \ + current_word_index_index + current_word_index_size]\n          local next_next_word_size\
    \ = #next_next_word\n          if next_next_word_size % 2 ~= 0 then\n        \
    \    sorted_list[sorted_list_index + current_word_index_index + current_word_index_size]\
    \ = next_next_word\n          else\n            local next_next_word_index_size\
    \ = #next_next_word\n            local next_next_word_index_index = 1\n      \
    \      while next_next_word_index_index < next_next_word_index_size do\n     \
    \         local next_next_next_word = sorted_list[sorted_list_index + current_word_index_index\
    \ + current_word_index_size + next_next_word_index_index]\n              local\
    \ next_next_next_word_size = #next_next_next_word\n              if next_next_next_word_size\
    \ % 2 ~= 0 then\n                sorted_list[sorted_list_index + current_word_index_index\
    \ + current_word_index_size + next_next_word_index_index] = next_next_next_word\n\
    \              else\n                local next_next_next_word_index_size = #next_next_next_word\n\
    \                local next_next_next_word_index_index = 1\n                while\
    \ next_next_next_word_index_index < next_next_next_word_index_size do\n      \
    \            local next_next_next_next_word = sorted_list[sorted_list_index +\
    \ current_word_index_index + current_word_index_size + next_next_word_index_index\
    \ + next_next_next_word_index_index]\n                  local next_next_next_next_word_size\
    \ = #next_next_next_next_word\n                  if next_next_next_next_word_size\
    \ % 2 ~= 0 then\n                    sorted_list[sorted_list_index + current_word_index_index\
    \ + current_word_index_size + next_next_word_index_index + next_next_next_word_index_index]\
    \ = next_next_next_next_word\n                  else\n                    local\
    \ next_next_next_next_word_index_size = #next_next_next_next_word\n          \
    \          local next_next_next_next_word_index_index = 1\n                  \
    \  while next_next_next_next_word_index_index < next_next_next_next_word_index_\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpv8jtwu4y.lua:56: 'do' expected near 'lu'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for i = 1, #lst do\n    local word = lst[i]\n    sorted_lst[#sorted_lst\
    \ + 1] = word\n  end\n  table.sort(sorted_lst, function(a, b) return #a < #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt39lveqp.lua:27:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpt39lveqp.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j] = nil\n      elseif next_word_size\
    \ > current_word_size then\n        sorted_list[i] = current_word\n        sorted_list[j]\
    \ = next_word\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpo52h7weh.lua:37:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpo52h7weh.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, word in ipairs(lst) do\n    sorted_lst[#sorted_lst\
    \ + 1] = word\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b\
    \ end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxddtftca.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpxddtftca.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_len = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_len do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_len = #current_word\n\
    \    if current_word_len % 2 == 1 then\n      table.insert(sorted_list, current_word)\n\
    \    end\n    sorted_list_index = sorted_list_index + 1\n  end\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphl_bf7sy.lua:32:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\", \"a\"}\nstack traceback:\n\
    \t/tmp/tmphl_bf7sy.lua:32: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = 1, #lst do\n    local j = i\n    while j\
    \ > 0 and sorted_list[j - 1] > sorted_list[j] do\n      sorted_list[j] = sorted_list[j\
    \ - 1]\n      j = j - 1\n    end\n    sorted_list[j] = lst[i]\n  end\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb4ytgdi8.lua:18:\
    \ attempt to compare string with nil\nstack traceback:\n\t/tmp/tmpb4ytgdi8.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ local word = lst[i]\n    local length = #word\n    if length % 2 == 1 then\n\
    \      sorted_lst[sorted_index] = word\n      sorted_index = sorted_index + 1\n\
    \    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a < #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph9j1h7l5.lua:32:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmph9j1h7l5.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j] = nil\n      elseif next_word_size\
    \ > current_word_size then\n        sorted_list[i] = current_word\n        sorted_list[j]\
    \ = next_word\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp041k2ty.lua:37:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpp041k2ty.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = {}\n  local sorted_index2 = 0\n\
    \  local sorted_index3 = 0\n  local sorted_index4 = 0\n  local sorted_index5 =\
    \ 0\n  local sorted_index6 = 0\n  local sorted_index7 = 0\n  local sorted_index8\
    \ = 0\n  local sorted_index9 = 0\n  local sorted_index10 = 0\n  local sorted_index11\
    \ = 0\n  local sorted_index12 = 0\n  local sorted_index13 = 0\n  local sorted_index14\
    \ = 0\n  local sorted_index15 = 0\n  local sorted_index16 = 0\n  local sorted_index17\
    \ = 0\n  local sorted_index18 = 0\n  local sorted_index19 = 0\n  local sorted_index20\
    \ = 0\n  local sorted_index21 = 0\n  local sorted_index22 = 0\n  local sorted_index23\
    \ = 0\n  local sorted_index24 = 0\n  local sorted_index25 = 0\n  local sorted_index26\
    \ = 0\n  local sorted_index27 = 0\n  local sorted_index28 = 0\n  local sorted_index29\
    \ = 0\n  local sorted_index30 = 0\n  local sorted_index31 = 0\n  local sorted_index32\
    \ = 0\n  local sorted_index33 = 0\n  local sorted_index34 = 0\n  local sorted_index35\
    \ = 0\n  local sorted_index36 = 0\n  local sorted_index37 = 0\n  local sorted_index38\
    \ = 0\n  local sorted_index39 = 0\n  local sorted_index40 = 0\n  local sorted_index41\
    \ = 0\n  local sorted_index42 = 0\n  local sorted_index43 = 0\n  local sorted_index44\
    \ = 0\n  local sorted_index45 = 0\n  local sorted_index46 = 0\n  local sorted_index47\
    \ = 0\n  local sorted_index48 = 0\n  local sorted_index49 = 0\n  local sorted_index50\
    \ = 0\n  local sorted_index51 = 0\n  local sorted_index52 = 0\n  local sorted_index53\
    \ = 0\n  local sorted_index54 = 0\n  local sorted_index55 = 0\n  local sorted_index56\
    \ = 0\n  local sorted_index57 = 0\n  local sorted_index58 = 0\n  local sorted_index59\
    \ = 0\n  local sorted_index60 = 0\n  local sorted_index61 = 0\n  local sorted_index62\
    \ = 0\n  local sorted_index63 = 0\n  local sorted_index64 = 0\n  local sorted_index65\
    \ = 0\n  local sorted_index66 = 0\n  local sorted_index67 = 0\n  local sorted_index68\
    \ = 0\n  local sorted_index69 = 0\n  local sorted_index70 = 0\n  local sorted_index71\
    \ = 0\n  local sorted_index72 = 0\n  local sorted_\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvb_61pjq.lua:102: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = {}\n  local sorted_lengths =\
    \ {}\n  local sorted_lengths_index = {}\n  for i = 1, #lst do\n    local length\
    \ = string.len(lst[i])\n    sorted_lengths[length] = sorted_lengths[length] or\
    \ 0\n    sorted_lengths[length] = sorted_lengths[length] + 1\n    sorted_index[length]\
    \ = i\n    sorted_lengths_index[length] = i\n  end\n  for i = 1, #sorted_lengths\
    \ do\n    sorted_lst[sorted_lengths_index[sorted_lengths[i]]] = lst[sorted_index[sorted_lengths[i]]]\n\
    \  end\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9qtfvekg.lua:35:\
    \ expected: {\"aa\"}\nactual: {2=\"a\"}\nstack traceback:\n\t/tmp/tmp9qtfvekg.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_keys = {}\n  local sorted_key = 0\n \
    \ for i = 1, #lst do\n    local key = lst[i]\n    sorted_keys[#sorted_keys + 1]\
    \ = key\n    sorted_key = sorted_key + 1\n  end\n  table.sort(sorted_keys, function(a,\
    \ b) return #a == #b end)\n  for i = 1, #sorted_keys do\n    sorted_lst[sorted_keys[i]]\
    \ = lst[i]\n  end\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq8v0unr2.lua:33:\
    \ expected: {\"aa\"}\nactual: {a=\"a\", aa=\"aa\", aaa=\"aaa\"}\nstack traceback:\n\
    \t/tmp/tmpq8v0unr2.lua:33: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      local next_word_index = 1\n  \
    \    while next_word_index < next_word_size do\n        if next_word_index ==\
    \ current_word_index then\n          sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n          sorted_list_index = sorted_list_index + next_word_index\n\
    \        else\n          local next_next_word = sorted_list[sorted_list_index\
    \ + current_word_index + next_word_index]\n          local next_next_word_size\
    \ = #next_next_word\n          local next_next_word_index = 1\n          while\
    \ next_next_word_index < next_next_word_size do\n            if next_next_word_index\
    \ == current_word_index + next_word_index then\n              sorted_list[sorted_list_index\
    \ + current_word_index + next_word_index] = next_next_word\n              sorted_list_index\
    \ = sorted_list_index + next_next_word_index\n            else\n             \
    \ local next_next_next_word = sorted_list[sorted_list_index + current_word_index\
    \ + next_word_index + next_next_word_index]\n              local next_next_next_word_size\
    \ = #next_next_next_word\n              local next_next_next_word_index = 1\n\
    \              while next_next_next_word_index < next_next_next_word_size do\n\
    \                if next_next_next_word_index == current_word_index + next_word_index\
    \ + next_next_word_index then\n                  sorted_list[sorted_list_index\
    \ + current_word_index + next_word_index + next_next_word_index] = next_next_next_word\n\
    \                  sorted_list_index = sorted_list_index + next_next_next_word_index\n\
    \                else\n                  local next_next_next_next_word = sorted_list[sorted_list_index\
    \ + current_word_index + next_word_index + next_next_word_index + next_next_next_word_index]\n\
    \                  local next_next_next_next_word_size = #next_next_next_next_word\n\
    \                  local next_next_next_next_word_index = 1\n                \
    \  while next_next_next_next_word_index < next_next_next_next_word_size do\n \
    \                   if next_next_next_next_word_index == current_word_index +\
    \ next_word_index + next_next_word_index + next_next_next_word_index then\n  \
    \                    sorted_list[sorted_list_index + current_word_index + next_word_index\
    \ + next_next_word_index + next_next_next_word_index] = next_next_next_next_word\n\
    \                      sorted_list_index = sorted_list_index + next_next_next_next_word_index\n\
    \                    else\n                      local next_next_next_next_next_word\
    \ = sorted_list[sorted_list_index + current_word_index + next_word_index + next_next_word_\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpefyblv8o.lua:56: ']' expected near 'lu'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      sorted_list[i] = word\n    end\n\
    \  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp40o3cicr.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp40o3cicr.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_size = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_value = lst[1]\n  local sorted_list_value_size = #sorted_list_value\n\
    \  local sorted_list_value_length = sorted_list_value_size\n  local sorted_list_value_char\
    \ = sorted_list_value[1]\n  local sorted_list_value_char_length = sorted_list_value_length\n\
    \  local sorted_list_value_char_index = sorted_list_value_char\n  local sorted_list_value_char_index_length\
    \ = sorted_list_value_char_length\n  local sorted_list_value_char_index_index\
    \ = 1\n  local sorted_list_value_char_index_value = sorted_list_value_char_index\n\
    \  local sorted_list_value_char_index_value_size = sorted_list_value_char_index_length\n\
    \  local sorted_list_value_char_index_value_length = sorted_list_value_char_index_value\n\
    \  local sorted_list_value_char_index_value_char = sorted_list_value_char_index_value[1]\n\
    \  local sorted_list_value_char_index_value_char_length = sorted_list_value_char_index_value_length\n\
    \  local sorted_list_value_char_index_value_char_index = sorted_list_value_char_index_value_char\n\
    \  local sorted_list_value_char_index_value_char_index_length = sorted_list_value_char_index_value_char_length\n\
    \  local sorted_list_value_char_index_value_char_index_index = 1\n  local sorted_list_value_char_index_value_char_index_value\
    \ = sorted_list_value_char_index_value_char_index_index\n  local sorted_list_value_char_index_value_char_index_value_size\
    \ = sorted_list_value_char_index_value_char_index_value_length\n  local sorted_list_value_char_index_value_char_index_value_char\
    \ = sorted_list_value_char_index_value_char_index_value[1]\n  local sorted_list_value_char_index_value_char_index_value_char_length\
    \ = sorted_list_value_char_index_value_char_index_value_char_length\n  local sorted_list_value_char_index_value_char_index_value_char_index\
    \ = sorted_list_value_char_index_value_char_index_value_char\n  local sorted_list_value_char_index_value_char_index_value_char_index_length\
    \ = sorted_list_value_char_index_value_char_index_value_char_index_length\n  local\
    \ sorted_list_value_char_index_value_char_index_value_char_index_index = 1\n \
    \ local sorted_list_value_char_index_value_char_index_value_char_index_value =\
    \ sorted_list_value_char_index_value_char_index_value_char_index_index\n  local\
    \ sorted_list_value_char_index_value_char_index_value_char_index_value_size =\
    \ sorted_list_value_char_index_value_char_index_value_char_index_value_length\n\
    \  local sorted_list_value_char_index_value_char_index_value_char_index_value_char\
    \ = sorted_list_value_char_index_value_char_index_value_char_index_value_char[1]\n\
    \  local sorted_list_value_char_index_value_char_index_value_char_index_value_char_length\
    \ = sorted_list_value_char_index_value_char_index_\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpwz5_t_k3.lua:58: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = 1, #sorted_list do\n    local word = sorted_list[i]\n\
    \    local word_length = #word\n    if word_length % 2 == 1 then\n      table.insert(sorted_list,\
    \ word)\n    end\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgr3o9253.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"a\", \"aa\", \"aaa\", \"aaa\"}\nstack\
    \ traceback:\n\t/tmp/tmpgr3o9253.lua:30: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = 0\n  for i = 1, #lst\
    \ do\n    sorted_list_length = sorted_list_length + 1\n    sorted_list[sorted_list_length]\
    \ = lst[i]\n  end\n  table.sort(sorted_list, function(a, b) return #a < #b end)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5_ihkj5k.lua:28:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp5_ihkj5k.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    if current_word_size % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  local sorted_length = #lst\n\
    \  for i = 1, sorted_length do\n    local word = lst[i]\n    local word_length\
    \ = #word\n    if word_length % 2 == 1 then\n      table.insert(sorted_lst, word)\n\
    \      sorted_index = sorted_index + 1\n    end\n  end\n  table.sort(sorted_lst,\
    \ function(a, b) return #a < #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj4n6k1wy.lua:33:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpj4n6k1wy.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      local next_word_index = 1\n  \
    \    while next_word_index < next_word_size do\n        if current_word_index\
    \ == next_word_index then\n          sorted_list[sorted_list_index + current_word_index]\
    \ = nil\n          sorted_list_index = sorted_list_index + current_word_index\n\
    \          sorted_list_size = sorted_list_size - current_word_index\n        \
    \  break\n        end\n        if next_word_index == next_word_size + 1 then\n\
    \          sorted_list[sorted_list_index + current_word_index] = next_word\n \
    \         sorted_list_index = sorted_list_index + current_word_index\n       \
    \   sorted_list_size = sorted_list_size - current_word_index\n          break\n\
    \        end\n        if next_word_index == next_word_size + 2 then\n        \
    \  sorted_list[sorted_list_index + current_word_index] = next_word\n         \
    \ sorted_list_index = sorted_list_index + current_word_index\n          sorted_list_size\
    \ = sorted_list_size - current_word_index\n          break\n        end\n    \
    \    if next_word_index == next_word_size + 3 then\n          sorted_list[sorted_list_index\
    \ + current_word_index] = next_word\n          sorted_list_index = sorted_list_index\
    \ + current_word_index\n          sorted_list_size = sorted_list_size - current_word_index\n\
    \          break\n        end\n        if next_word_index == next_word_size +\
    \ 4 then\n          sorted_list[sorted_list_index + current_word_index] = next_word\n\
    \          sorted_list_index = sorted_list_index + current_word_index\n      \
    \    sorted_list_size = sorted_list_size - current_word_index\n          break\n\
    \        end\n        if next_word_index == next_word_size + 5 then\n        \
    \  sorted_list[sorted_list_index + current_word_index] = next_word\n         \
    \ sorted_list_index = sorted_list_index + current_word_index\n          sorted_list_size\
    \ = sorted_list_size - current_word_index\n          break\n        end\n    \
    \    if next_word_index == next_word_size + 6 then\n          sorted_list[sorted_list_index\
    \ + current_word_index] = next_word\n          sorted_list_index = sorted_list_index\
    \ + current_word_index\n          sorted_list_size = sorted_list_size - current_word_index\n\
    \          break\n        end\n        if next_word_index == next_word_size +\
    \ 7 then\n          sorted_list[sorted_list_index + current_word_index] = next_word\n\
    \          sorted_list_index = sorted_list_index + current_word_index\n      \
    \    sorted_list_size = sorted_list_size - current_word_index\n          break\n\
    \        end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n\
    \    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf',\
    \ 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d',\
    \ 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI',\
    \ 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b',\
    \ 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd',\
    \ 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvtgd5obd.lua:89: 'end' expected (to close 'while' at line\
    \ 26) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = 0\n  local sorted_list_index\
    \ = 0\n  local sorted_list_length_index = 0\n  local sorted_list_length_index_max\
    \ = 0\n  local sorted_list_length_index_max_index = 0\n  for i = 1, #lst do\n\
    \    local length = string.len(lst[i])\n    if sorted_list_length_index == sorted_list_length_index_max\
    \ then\n      sorted_list_length_index_max = sorted_list_length_index\n    end\n\
    \    if sorted_list_length_index == sorted_list_length_index_max_index then\n\
    \      sorted_list_length_index_max_index = sorted_list_length_index_max\n   \
    \ end\n    if sorted_list_length_index < sorted_list_length_index_max then\n \
    \     if sorted_list_length_index == sorted_list_length_index_max_index then\n\
    \        sorted_list_length_index_max_index = sorted_list_length_index_max\n \
    \     end\n      sorted_list_length_index = sorted_list_length_index + 1\n   \
    \ end\n    sorted_list[sorted_list_index] = lst[i]\n    sorted_list_index = sorted_list_index\
    \ + 1\n  end\n  for i = 1, sorted_list_length_index_max_index do\n    sorted_list[#sorted_list\
    \ + 1] = sorted_list[i]\n  end\n  for i = 1, #lst do\n    local length = string.len(lst[i])\n\
    \    if sorted_list_length_index == sorted_list_length_index_max then\n      sorted_list_length_index_max\
    \ = sorted_list_length_index\n    end\n    if sorted_list_length_index == sorted_list_length_index_max_index\
    \ then\n      sorted_list_length_index_max_index = sorted_list_length_index_max\n\
    \    end\n    if sorted_list_length_index < sorted_list_length_index_max then\n\
    \      if sorted_list_length_index == sorted_list_length_index_max_index then\n\
    \        sorted_list_length_index_max_index = sorted_list_length_index_max\n \
    \     end\n      sorted_list_length_index = sorted_list_length_index + 1\n   \
    \ end\n    sorted_list[sorted_list_index] = lst[i]\n    sorted_list_index = sorted_list_index\
    \ + 1\n  end\n  for i = 1, sorted_list_length_index_max_index do\n    sorted_list[#sorted_list\
    \ + 1] = sorted_list[i]\n  end\n  for i = 1, #lst do\n    local length = string.len(lst[i])\n\
    \    if sorted_list_length_index == sorted_list_length_index_max then\n      sorted_list_length_index_max\
    \ = sorted_list_length_index\n    end\n    if sorted_list_length_index == sorted_list_length_index_max_index\
    \ then\n      sorted_list_length_index_max_index = sorted_list_length_index_max\n\
    \    end\n    if sorted_list_length_index < sorted_list_length_index_max then\n\
    \      if sorted_list_length_index == sorted_list_length_index_max_index then\n\
    \        sorted_list_length_index_max_index = sorted_list_length_index_max\n \
    \     end\n      sorted_list_length\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpk3rgz1nv.lua:74: '=' expected near 'lu'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j] = nil\n      elseif next_word_size\
    \ < current_word_size then\n        sorted_list[j + 1] = current_word\n      else\n\
    \        sorted_list[i] = current_word\n      end\n    end\n  end\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0fo6iaa1.lua:22:\
    \ attempt to get length of local 'next_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmp0fo6iaa1.lua:38: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, word in ipairs(lst) do\n    table.insert(sorted_list,\
    \ word)\n  end\n  table.sort(sorted_list, function(a, b) return #a < #b end)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnrfcwjxu.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpnrfcwjxu.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  local sorted_length = #lst\n\
    \  for i = 1, sorted_length do\n    local word = lst[i]\n    local index = sorted_index\n\
    \    sorted_index = sorted_index + 1\n    for j = 1, sorted_length do\n      if\
    \ sorted_index > j then\n        local word2 = lst[j]\n        if word:len() >\
    \ word2:len() then\n          sorted_index = sorted_index + 1\n          break\n\
    \        end\n      end\n    end\n    table.insert(sorted_lst, word)\n  end\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbcwgg01r.lua:39:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpbcwgg01r.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, word in ipairs(lst) do\n    table.insert(sorted_list,\
    \ word)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz_1n8wun.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpz_1n8wun.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    if current_word_length % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  for i\
    \ = 1, sorted_list_length do\n    local current_word = sorted_list[i]\n    local\
    \ current_word_length = #current_word\n    for j = i + 1, sorted_list_length do\n\
    \      local next_word = sorted_list[j]\n      local next_word_length = #next_word\n\
    \      if current_word_length < next_word_length then\n        sorted_list[j],\
    \ sorted_list[i] = sorted_list[i], sorted_list[j]\n      end\n    end\n  end\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgx4jp3vz.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"aaa\", \"aa\", \"a\"}\nstack traceback:\n\t/tmp/tmpgx4jp3vz.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ if sorted_index == #sorted_lst then\n      table.insert(sorted_lst, lst[i])\n\
    \      sorted_index = sorted_index + 1\n    elseif sorted_index == 1 then\n  \
    \    table.insert(sorted_lst, lst[i])\n    else\n      if sorted_lst[sorted_index\
    \ - 1] < lst[i] then\n        table.insert(sorted_lst, lst[i])\n      else\n \
    \       local j = sorted_index - 1\n        while j > 0 and sorted_lst[j] == sorted_lst[j\
    \ - 1] do\n          table.remove(sorted_lst, j)\n          j = j - 1\n      \
    \  end\n        table.insert(sorted_lst, lst[i])\n      end\n    end\n  end\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph4bjyoti.lua:42:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmph4bjyoti.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for i = 1, #lst do\n    local word = lst[i]\n  \
    \  local length = #word\n    if length % 2 == 1 then\n      sorted_list[#sorted_list\
    \ + 1] = word\n    end\n  end\n  table.sort(sorted_list)\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmn6lvnd_.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpmn6lvnd_.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, str in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ str)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpepzdcqz9.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpepzdcqz9.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index <= sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    if current_word_size % 2 == 1 then\n      -- The current word has an odd\
    \ length, so we remove it\n      sorted_list[sorted_list_index] = nil\n      sorted_list_size\
    \ = sorted_list_size - 1\n      sorted_list_index = sorted_list_index - 1\n  \
    \  else\n      -- The current word has an even length, so we sort it\n      table.insert(sorted_list,\
    \ current_word)\n    end\n  end\n  -- Sort the list alphabetically\n  table.sort(sorted_list)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for i = 1, #lst do\n    local word = lst[i]\n    local\
    \ length = #word\n    if length % 2 == 1 then\n      sorted_lst[#sorted_lst +\
    \ 1] = word\n    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a\
    \ < #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc253995o.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpc253995o.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = 1, #lst do\n    local j = i\n    while j\
    \ > 0 and sorted_list[j - 1] == sorted_list[j] do\n      sorted_list[j] = nil\n\
    \      j = j - 1\n    end\n  end\n  table.sort(sorted_list)\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpftkbxdp3.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpftkbxdp3.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_index_length = #sorted_list\n  local\
    \ sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_index_length\n\
    \  local sorted_list_index_length\n  local sorted_list_index_length\n  local sorted_list_\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpcw41d5rj.lua:101: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size\
    \ = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n\
    \  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size\
    \ = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n\
    \  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size\
    \ = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n\
    \  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size\
    \ = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n\
    \  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpajkqdp72.lua:93: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_len = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_value = lst[1]\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpx3yy7ph7.lua:73: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      local next_word_index = 1\n  \
    \    while next_word_index < next_word_size do\n        if next_word_index ==\
    \ current_word_index then\n          sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n          sorted_list_index = sorted_list_index + current_word_index\n\
    \          current_word_index = current_word_index + next_word_index\n       \
    \ else\n          local word_length = next_word_index - current_word_index\n \
    \         if word_length == 1 then\n            sorted_list[sorted_list_index\
    \ + current_word_index] = next_word\n            sorted_list_index = sorted_list_index\
    \ + current_word_index\n            current_word_index = current_word_index +\
    \ next_word_index\n          elseif word_length > 1 then\n            local word_length_sum\
    \ = word_length\n            local word_length_sum_index = 1\n            while\
    \ word_length_sum_index < word_length_sum do\n              local next_next_word\
    \ = sorted_list[sorted_list_index + word_length_sum_index]\n              local\
    \ next_next_word_size = #next_next_word\n              local next_next_word_index\
    \ = 1\n              while next_next_word_index < next_next_word_size do\n   \
    \             if next_next_word_index == word_length_sum_index then\n        \
    \          sorted_list[sorted_list_index + current_word_index] = next_next_word\n\
    \                  sorted_list_index = sorted_list_index + current_word_index\n\
    \                  current_word_index = current_word_index + next_next_word_index\n\
    \                else\n                  local word_length_sum_next = next_next_word_index\
    \ - word_length_sum_index\n                  if word_length_sum_next == 1 then\n\
    \                    sorted_list[sorted_list_index + current_word_index] = next_next_word\n\
    \                    sorted_list_index = sorted_list_index + current_word_index\n\
    \                    current_word_index = current_word_index + next_next_word_index\n\
    \                  elseif word_length_sum_next > 1 then\n                    local\
    \ word_length_sum_sum_next = word_length_sum_sum_index\n                    local\
    \ word_length_sum_sum_next_index = 1\n                    while word_length_sum_sum_next_index\
    \ < word_length_sum_sum_next do\n                      local next_next_next_word\
    \ = sorted_list[sorted_list_index + word_length_sum_sum_next_index]\n        \
    \              local next_next_next_word_size = #next_next_next_word\n       \
    \               local next_next_next_word_index = 1\n                      while\
    \ next_next_next_word_index < next_next_next_word_size do\n                  \
    \      if next_next_next_word_index == \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdk1r2xak.lua:64: 'then' expected near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for i = 1, #lst do\n    local word = lst[i]\n    local\
    \ length = #word\n    if length % 2 == 1 then\n      sorted_lst[#sorted_lst +\
    \ 1] = word\n    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a\
    \ == #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8h8df0sj.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp8h8df0sj.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j] = nil\n      elseif current_word_size\
    \ > next_word_size then\n        sorted_list[j], sorted_list[i] = sorted_list[i],\
    \ sorted_list[j]\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyu0122fq.lua:36:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpyu0122fq.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    local current_word_index = 1\n    while current_word_index\
    \ < current_word_length do\n      local next_word = sorted_list[sorted_list_index\
    \ + current_word_index]\n      local next_word_length = #next_word\n      if next_word_length\
    \ == current_word_length then\n        sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n      else\n        local next_word_index = 1\n        while next_word_index\
    \ < next_word_length do\n          local next_next_word = sorted_list[sorted_list_index\
    \ + current_word_index + next_word_index]\n          local next_next_word_length\
    \ = #next_next_word\n          if next_next_word_length == next_word_length then\n\
    \            sorted_list[sorted_list_index + current_word_index + next_word_index]\
    \ = next_next_word\n          else\n            local next_next_word_index = 1\n\
    \            while next_next_word_index < next_next_word_length do\n         \
    \     local next_next_next_word = sorted_list[sorted_list_index + current_word_index\
    \ + next_word_index + next_next_word_index]\n              local next_next_next_word_length\
    \ = #next_next_next_word\n              if next_next_next_word_length == next_next_word_length\
    \ then\n                sorted_list[sorted_list_index + current_word_index + next_word_index\
    \ + next_next_word_index] = next_next_next_word\n              else\n        \
    \        next_next_word_index = next_next_word_index + 1\n              end\n\
    \            end\n          end\n          next_word_index = next_word_index +\
    \ 1\n        end\n      end\n      current_word_index = current_word_index + 1\n\
    \    end\n    sorted_list_index = sorted_list_index + 1\n  end\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpowcwayzk.lua:59:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpowcwayzk.lua:59:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j] = nil\n      elseif next_word_size\
    \ < current_word_size then\n        sorted_list[j + 1] = nil\n      end\n    end\n\
    \  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjj6v4824.lua:22:\
    \ attempt to get length of local 'next_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmpjj6v4824.lua:36: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index <= sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index <= current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      if next_word_size < current_word_size\
    \ then\n        sorted_list[sorted_list_index + current_word_index] = nil\n  \
    \    else\n        local next_word_index = current_word_index + next_word_size\
    \ - 1\n        while next_word_index <= current_word_size do\n          sorted_list[sorted_list_index\
    \ + next_word_index + 1] = nil\n          next_word_index = next_word_index +\
    \ 1\n        end\n      end\n      current_word_index = current_word_index + next_word_size\
    \ - 1\n    end\n    sorted_list_index = sorted_list_index + 1\n  end\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdr1m5zdx.lua:24:\
    \ attempt to get length of local 'next_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmpdr1m5zdx.lua:44: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  for i = 1, sorted_list_length\
    \ do\n    local word = lst[i]\n    local word_length = #word\n    if word_length\
    \ % 2 == 1 then\n      table.insert(sorted_list, word)\n    end\n  end\n  table.sort(sorted_list)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps22sdohr.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmps22sdohr.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      sorted_list[i] = word:sub(1,\
    \ word_size - 1)\n    end\n  end\n  table.sort(sorted_list)\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpusbaciqp.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"\", \"aa\", \"aa\"}\nstack traceback:\n\t/tmp/tmpusbaciqp.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    if current_word_size % 2 == 1 then\n      sorted_list[#sorted_list\
    \ + 1] = current_word\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkzv6q5wl.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\", \"a\", \"aaa\"}\nstack\
    \ traceback:\n\t/tmp/tmpkzv6q5wl.lua:30: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ local word = lst[i]\n    local length = #word\n    if length % 2 == 1 then\n\
    \      table.insert(sorted_lst, word)\n    else\n      local last_word = sorted_lst[#sorted_lst]\n\
    \      if last_word ~= word then\n        table.insert(sorted_lst, word)\n   \
    \   end\n    end\n  end\n  for i = 1, #sorted_lst do\n    sorted_lst[i] = sorted_lst[i]:gsub(\"\
    %w+\", \"\")\n  end\n  table.sort(sorted_lst, function(a, b) return #a < #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjn158t8v.lua:39:\
    \ expected: {\"aa\"}\nactual: {\"\", \"\", \"\"}\nstack traceback:\n\t/tmp/tmpjn158t8v.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, word in ipairs(lst) do\n    sorted_list[#sorted_list\
    \ + 1] = word\n  end\n  table.sort(sorted_list, function(a, b) return #a < #b\
    \ end)\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4cm4rln7.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp4cm4rln7.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      if next_word_size == current_word_size\
    \ then\n        sorted_list[sorted_list_index + current_word_index] = next_word\n\
    \      else\n        sorted_list_index = sorted_list_index + current_word_index\n\
    \      end\n      current_word_index = current_word_index + next_word_size\n \
    \   end\n    sorted_list_index = sorted_list_index + current_word_size\n  end\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfyk5oqc8.lua:40:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpfyk5oqc8.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  for i = 1, sorted_list_length\
    \ do\n    local word = lst[i]\n    local word_length = #word\n    if word_length\
    \ % 2 == 1 then\n      table.insert(sorted_list, word)\n    end\n  end\n  table.sort(sorted_list)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq13zm9po.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpq13zm9po.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = 1, #lst do\n    local word = sorted_list[i]\n\
    \    local word_length = #word\n    if word_length % 2 == 1 then\n      sorted_list[i]\
    \ = word\n    end\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsre45r9x.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpsre45r9x.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, word in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ word)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj8i7sivr.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpj8i7sivr.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size\
    \ = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n\
    \  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size\
    \ = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n\
    \  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size\
    \ = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n\
    \  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size\
    \ = #sorted_list\n  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n\
    \  local sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n  local\
    \ sorted_list_size = #sorted_list\n  \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpge01zmr7.lua:93: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index <= sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index <= current_word_size\
    \ do\n      local current_word_char = current_word[current_word_index]\n     \
    \ local current_word_char_length = #current_word_char\n      if current_word_char_length\
    \ % 2 == 1 then\n        -- If the current word has odd length, delete it from\
    \ the list.\n        -- The list should be sorted by length of each word.\n  \
    \      -- The list should be sorted by alphabetically if two words have the same\
    \ length.\n        -- The list should be sorted by length if two words have the\
    \ same length.\n        -- The list should be sorted by alphabetically if two\
    \ words have the same length.\n        -- The list should be sorted by length\
    \ if two words have the same length.\n        -- The list should be sorted by\
    \ alphabetically if two words have the same length.\n        -- The list should\
    \ be sorted by length if two words have the same length.\n        -- The list\
    \ should be sorted by alphabetically if two words have the same length.\n    \
    \    -- The list should be sorted by length if two words have the same length.\n\
    \        -- The list should be sorted by alphabetically if two words have the\
    \ same length.\n        -- The list should be sorted by length if two words have\
    \ the same length.\n        -- The list should be sorted by alphabetically if\
    \ two words have the same length.\n        -- The list should be sorted by length\
    \ if two words have the same length.\n        -- The list should be sorted by\
    \ alphabetically if two words have the same length.\n        -- The list should\
    \ be sorted by length if two words have the same length.\n        -- The list\
    \ should be sorted by alphabetically if two words have the same length.\n    \
    \    -- The list should be sorted by length if two words have the same length.\n\
    \        -- The list should be sorted by alphabetically if two words have the\
    \ same length.\n        -- The list should be sorted by length if two words have\
    \ the same length.\n        -- The list should be sorted by alphabetically if\
    \ two words have the same length.\n        -- The list should be sorted by length\
    \ if two words have the same length.\n        -- The list should be sorted by\
    \ alphabetically if two words have the same length.\n        -- The list should\
    \ be sorted by length if two words have the same length.\n        -- The list\
    \ should be sorted by alphabetically if two words have the same length.\n    \
    \    -- The list should be sorted by length if two words have the same length.\n\
    \        -- \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n\
    \    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf',\
    \ 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d',\
    \ 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI',\
    \ 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b',\
    \ 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd',\
    \ 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpq0_7r8xf.lua:66: 'end' expected (to close 'if' at line 25)\
    \ near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, v in ipairs(lst) do\n    table.insert(sorted_list,\
    \ v)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46kcxugb.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp46kcxugb.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j] = nil\n      elseif current_word_size\
    \ > next_word_size then\n        sorted_list[j], sorted_list[i] = sorted_list[i],\
    \ sorted_list[j]\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi6jn0lhi.lua:36:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpi6jn0lhi.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ local word = lst[i]\n    local length = #word\n    if length % 2 == 1 then\n\
    \      table.insert(sorted_lst, word)\n    else\n      local index = sorted_index\n\
    \      sorted_index = sorted_index + 1\n      table.insert(sorted_lst, word)\n\
    \      table.insert(sorted_lst, word:sub(1, length - 1))\n    end\n  end\n  table.sort(sorted_lst,\
    \ function(a, b) return #a == #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp29kb10_x.lua:36:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\", \"a\"}\nstack traceback:\n\
    \t/tmp/tmp29kb10_x.lua:36: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      sorted_list[i] = word\n    end\n\
    \  end\n  table.sort(sorted_list, function(a, b) return #a < #b end)\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpygzx8chp.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpygzx8chp.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  for i = 1, sorted_list_length\
    \ do\n    sorted_list[#sorted_list + 1] = lst[i]\n  end\n  table.sort(sorted_list)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5u7fx1ap.lua:27:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp5u7fx1ap.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_value = lst[1]\n  local sorted_list_value_index = 1\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length_index\
    \ = 1\n  local sorted_list_value_length_value = sorted_list_length\n  local sorted_list_value_length_value_index\
    \ = 1\n  local sorted_list_value_length_value_value = sorted_list_length\n  local\
    \ sorted_list_value_length_value_value = 1\n  local sorted_list_value_length_value_value_index\
    \ = 1\n  local sorted_list_value_length_value_value_value = sorted_list_length\n\
    \  local sorted_list_value_length_value_value_index = 1\n  local sorted_list_value_length_value_value_value\
    \ = sorted_list_length\n  local sorted_list_value_length_value_value_index = 1\n\
    \  local sorted_list_value_length_value_value_value = sorted_list_length\n  local\
    \ sorted_list_value_length_value_value_index = 1\n  local sorted_list_value_length_value_value_value\
    \ = sorted_list_length\n  local sorted_list_value_length_value_value_index = 1\n\
    \  local sorted_list_value_length_value_value_value = sorted_list_length\n  local\
    \ sorted_list_value_length_value_value_index = 1\n  local sorted_list_value_length_value_value_value\
    \ = sorted_list_length\n  local sorted_list_value_length_value_value_index = 1\n\
    \  local sorted_list_value_length_value_value_value = sorted_list_length\n  local\
    \ sorted_list_value_length_value_value_index = 1\n  local sorted_list_value_length_value_value_value\
    \ = sorted_list_length\n  local sorted_list_value_length_value_value_index = 1\n\
    \  local sorted_list_value_length_value_value_value = sorted_list_length\n  local\
    \ sorted_list_value_length_value_value_index = 1\n  local sorted_list_value_length_value_value_value\
    \ = sorted_list_length\n  local sorted_list_value_length_value_value_index = 1\n\
    \  local sorted_list_value_length_value_value_value = sorted_list_length\n  local\
    \ sorted_list_value_length_value_value_index = 1\n  local sorted_list_value_length_value_value_value\
    \ = sorted_list_length\n  local sorted_list_value_length_value_value_index = 1\n\
    \  local sorted_list_value_length_value_value_value = sorted_list_length\n  local\
    \ sorted_list_value_length_value_value_index = 1\n  local sorted_list_value_length_value_value_value\
    \ = sorted_list_length\n  local sorted_list_value_length_value_value_index = 1\n\
    \  local sorted_list_value_length_value_value_value = sorted_list_length\n  local\
    \ sorted_list_value_length_value_value_index = 1\n  local sorted_list_value_length_value_value_value\
    \ = sorted_list_length\n  local sorted_list_value_length_value_value_index = 1\n\
    \  local sorted_list_value_length_value_value_value = sorted_list_length\n  local\
    \ sorted_\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n\
    \    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf',\
    \ 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d',\
    \ 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI',\
    \ 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b',\
    \ 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd',\
    \ 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppgnt8r34.lua:74: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        if current_word < next_word then\n         \
    \ table.insert(sorted_list, current_word)\n          table.insert(sorted_list,\
    \ next_word)\n        end\n      elseif current_word_size > next_word_size then\n\
    \        table.insert(sorted_list, current_word)\n        table.insert(sorted_list,\
    \ next_word)\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphio6a7z_.lua:40:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\", \"aa\", \"a\"}\nstack traceback:\n\
    \t/tmp/tmphio6a7z_.lua:40: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, v in ipairs(lst) do\n    table.insert(sorted_list,\
    \ v)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdufpa1wy.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpdufpa1wy.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for i = 1, #lst do\n    local word = lst[i]\n    local\
    \ length = #word\n    if length % 2 == 1 then\n      sorted_lst[#sorted_lst +\
    \ 1] = word\n    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a\
    \ < #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9x6qboll.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp9x6qboll.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_length = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_length = #lst\n  local sorted_list_index = 1\n  local sorted_list_length\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_length = #lst\n \
    \ local sorted_list_index = 1\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_length = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_length = #lst\n  local sorted_list_index = 1\n  local sorted_list_length\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_length = #lst\n \
    \ local sorted_list_index = 1\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_length = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_length = #lst\n  local sorted_list_index = 1\n  local sorted_list_length\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_length = #lst\n \
    \ local sorted_list_index = 1\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_length = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_length = #lst\n  local sorted_list_index = 1\n  local sorted_list_length\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_length = #lst\n \
    \ local sorted_list_index = 1\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_length = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_length = #lst\n  local sorted_list_index = 1\n  local sorted_list_length\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_length = #lst\n \
    \ local sorted_list_index = 1\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_length = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_length = #lst\n  local sorted_list_index = 1\n  local sorted_list_length\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_length = #lst\n \
    \ local sorted_list_index = 1\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_length = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_length = #lst\n  local sorted_list_index = 1\n  local sorted_list_length\
    \ = #lst\n  local \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp2u8fdus1.lua:97: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = 1, #lst do\n    local word = sorted_list[i]\n\
    \    local length = #word\n    if length % 2 == 1 then\n      sorted_list[#sorted_list\
    \ + 1] = word\n    end\n  end\n  table.sort(sorted_list)\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptb5w9ttx.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"a\", \"aa\", \"aaa\", \"aaa\"}\nstack\
    \ traceback:\n\t/tmp/tmptb5w9ttx.lua:30: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_len = #lst\n  for i = 1, sorted_list_len\
    \ do\n    local word = lst[i]\n    sorted_list[#sorted_list + 1] = word\n  end\n\
    \  table.sort(sorted_list, function(a, b) return #a == #b end)\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjtdy7y6f.lua:28:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpjtdy7y6f.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  for i = 1, sorted_list_length\
    \ do\n    local word = lst[i]\n    local length = #word\n    if length % 2 ==\
    \ 1 then\n      table.insert(sorted_list, word)\n    end\n  end\n  table.sort(sorted_list,\
    \ function(a, b) return #a < #b end)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptqiksw9g.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmptqiksw9g.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ v)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n  return\
    \ sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf_mstyw4.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpf_mstyw4.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_size = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_value = lst[1]\n  local sorted_list_value_length =\
    \ #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = 1\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length\
    \ = #sorted_list_value\n  local sorted_list_value_length = #sorted_list_value\n\
    \  local sorted_list_value_length = #sorted_list_value\n  \nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7bdfv87e.lua:77: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for i = 1, #lst do\n    local word = lst[i]\n    local\
    \ index = i\n    for j = i + 1, #lst do\n      if word:len() > lst[j]:len() then\n\
    \        index = j\n      end\n    end\n    table.insert(sorted_lst, word)\n \
    \   table.insert(sorted_lst, lst[index])\n  end\n  return sorted_lst\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpez8ammh3.lua:33:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"a\", \"a\", \"aaa\", \"aaa\"}\n\
    stack traceback:\n\t/tmp/tmpez8ammh3.lua:33: in function 'test_humaneval'\n\n\
    Ran 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ if sorted_index == #sorted_lst then\n      table.insert(sorted_lst, lst[i])\n\
    \    elseif sorted_index == 1 then\n      table.insert(sorted_lst, lst[i])\n \
    \   else\n      if sorted_lst[sorted_index] < lst[i] then\n        table.insert(sorted_lst,\
    \ lst[i])\n      else\n        table.insert(sorted_lst, sorted_lst[sorted_index])\n\
    \      end\n    end\n    sorted_index = sorted_index + 1\n  end\n  return sorted_lst\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw8ycbvgs.lua:23:\
    \ attempt to compare nil with string\nstack traceback:\n\t/tmp/tmpw8ycbvgs.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = 1, #lst do\n    local j = 1\n    while j\
    \ < #sorted_list do\n      if sorted_list[j] == lst[i] then\n        j = j + 1\n\
    \      else\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, lst[i])\n        table.insert(sorted_list,\
    \ lst[j])\n        table.insert(sorted_list, \nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpuu0n6i5k.lua:81: ')' expected (to close '(' at line 80) near\
    \ '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = 1, #lst do\n    local length = sorted_list[i]:len()\n\
    \    if length % 2 == 1 then\n      sorted_list[i]:gsub(\"%w+\", \"\")\n    end\n\
    \  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd02xt129.lua:29:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpd02xt129.lua:29:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j], sorted_list[i] = sorted_list[i],\
    \ sorted_list[j]\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcmfd1dco.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpcmfd1dco.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_index_size = #sorted_list\n  local sorted_list_index_value\
    \ = 1\n  while sorted_list_index_value < sorted_list_size do\n    local current_value\
    \ = sorted_list[sorted_list_index_value]\n    local current_index = sorted_list_index\n\
    \    local current_index_size = sorted_list_index_size\n    while current_index_size\
    \ >= 1 do\n      local next_value = sorted_list[current_index_size]\n      local\
    \ next_index = current_index + 1\n      local next_index_size = current_index_size\n\
    \      while next_index_size >= 1 do\n        if next_value == current_value then\n\
    \          sorted_list[current_index_size] = next_value\n          sorted_list_index_size\
    \ = next_index_size\n          sorted_list_index = next_index\n        else\n\
    \          current_index_size = next_index_size\n        end\n      end\n    end\n\
    \    sorted_list_index_value = sorted_list_index_value + 1\n  end\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ local word = lst[i]\n    local length = #word\n    if length % 2 == 1 then\n\
    \      sorted_lst[sorted_index] = word\n      sorted_index = sorted_index + 1\n\
    \    end\n  end\n  for i = 1, #lst do\n    local word = lst[i]\n    local length\
    \ = #word\n    if length % 2 == 1 then\n      sorted_lst[sorted_index] = word\n\
    \      sorted_index = sorted_index + 1\n    end\n  end\n  table.sort(sorted_lst,\
    \ function(a, b) return #a < #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw5nkn62_.lua:40:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"a\", \"aaa\", \"aaa\"}\nstack traceback:\n\
    \t/tmp/tmpw5nkn62_.lua:40: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_size = #sorted_list\n  local sorted_list_index = 1\n\
    \  while sorted_list_index < sorted_list_size do\n    local current_word = sorted_list[sorted_list_index]\n\
    \    local current_word_size = #current_word\n    local current_word_index = 1\n\
    \    while current_word_index < current_word_size do\n      local next_word =\
    \ sorted_list[sorted_list_index + current_word_index]\n      local next_word_size\
    \ = #next_word\n      local next_word_index = 1\n      while next_word_index <\
    \ next_word_size do\n        if current_word_size == next_word_size then\n   \
    \       if current_word < next_word then\n            sorted_list[sorted_list_index\
    \ + current_word_index] = next_word\n            sorted_list_index = sorted_list_index\
    \ + current_word_index\n          else\n            sorted_list_index = sorted_list_index\
    \ + current_word_index\n          end\n        else\n          if current_word_size\
    \ < next_word_size then\n            sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n            sorted_list_index = sorted_list_index + current_word_index\n\
    \          else\n            sorted_list_index = sorted_list_index + current_word_index\n\
    \          end\n        end\n        next_word_index = next_word_index + 1\n \
    \     end\n      current_word_index = current_word_index + 1\n    end\n    sorted_list_index\
    \ = sorted_list_index + 1\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8yz_oa6d.lua:56:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp8yz_oa6d.lua:56:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ v)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n  return\
    \ sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyars4wza.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpyars4wza.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_keys = {}\n  local sorted_key_count =\
    \ 0\n  for i = 1, #lst do\n    local key = lst[i]\n    sorted_keys[sorted_key_count]\
    \ = key\n    sorted_key_count = sorted_key_count + 1\n  end\n  table.sort(sorted_keys,\
    \ function(a, b)\n    return #a == #b and #a > #b\n  end)\n  for i = 1, #sorted_keys\
    \ do\n    sorted_lst[#sorted_lst + 1] = sorted_keys[i]\n  end\n  return sorted_lst\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp56guex1.lua:35:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpp56guex1.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_len = #sorted_list\n  for i =\
    \ 1, sorted_list_len do\n    for j = 1, sorted_list_len do\n      if sorted_list[i]\
    \ == sorted_list[j] then\n        sorted_list[i] = nil\n      end\n    end\n \
    \ end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf1sjks3v.lua:31:\
    \ expected: {\"aa\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpf1sjks3v.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ if sorted_index == #sorted_lst then\n      table.insert(sorted_lst, lst[i])\n\
    \      sorted_index = i + 1\n    elseif sorted_index == #sorted_lst + 1 then\n\
    \      table.insert(sorted_lst, lst[i])\n      sorted_index = i + 1\n    elseif\
    \ sorted_index == #sorted_lst + 2 then\n      table.insert(sorted_lst, lst[i])\n\
    \      sorted_index = i + 1\n    else\n      if sorted_lst[#sorted_lst - 1] <\
    \ lst[i] then\n        table.insert(sorted_lst, lst[i])\n      else\n        table.insert(sorted_lst,\
    \ sorted_lst[#sorted_lst - 1])\n      end\n    end\n  end\n  return sorted_lst\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsmeuoxsg.lua:41:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpsmeuoxsg.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ v)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n  return\
    \ sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjv81bjqo.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpjv81bjqo.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  local sorted_length = #lst\n\
    \  local sorted_keys = {}\n  local sorted_key_index = 1\n  local sorted_key_length\
    \ = #sorted_keys\n  local sorted_key_value = sorted_keys[sorted_key_index]\n \
    \ while sorted_index < sorted_length do\n    local current_value = lst[sorted_index]\n\
    \    local current_length = #current_value\n    if current_length > 1 then\n \
    \     sorted_keys[sorted_key_index] = current_value\n      sorted_key_index =\
    \ sorted_key_index + 1\n      sorted_key_length = sorted_key_length + 1\n    \
    \  sorted_key_value = sorted_keys[sorted_key_index]\n    end\n    sorted_index\
    \ = sorted_index + 1\n  end\n  while sorted_key_index < sorted_key_length do\n\
    \    sorted_lst[sorted_key_index] = sorted_key_value\n    sorted_key_index = sorted_key_index\
    \ + 1\n  end\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdpc120xj.lua:43:\
    \ expected: {\"aa\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpdpc120xj.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_len = #sorted_list\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len + 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len + 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len + 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len + 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp2a2qlmys.lua:80: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  for i\
    \ = 1, sorted_list_length do\n    local current_word = sorted_list[i]\n    local\
    \ current_word_length = #current_word\n    for j = i + 1, sorted_list_length do\n\
    \      local next_word = sorted_list[j]\n      local next_word_length = #next_word\n\
    \      if next_word_length < current_word_length then\n        sorted_list[j],\
    \ sorted_list[i] = sorted_list[i], sorted_list[j]\n      end\n    end\n  end\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpawdkgeyl.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpawdkgeyl.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      if next_word_size % 2 ~= 0 then\n\
    \        -- If the next word has an odd length, delete it\n        sorted_list[sorted_list_index\
    \ + current_word_index] = nil\n      else\n        -- If the next word has an\
    \ even length, compare the two words and swap them\n        if current_word >\
    \ next_word then\n          sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n        end\n      end\n      current_word_index = current_word_index\
    \ + next_word_size\n    end\n    sorted_list_index = sorted_list_index + current_word_size\n\
    \  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpefy9c_02.lua:44:\
    \ expected: {\"aa\"}\nactual: {\"aa\", 3=\"aaa\"}\nstack traceback:\n\t/tmp/tmpefy9c_02.lua:44:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_len = #lst\n  for i = 1, sorted_list_len\
    \ do\n    local word = lst[i]\n    local word_len = #word\n    if word_len % 2\
    \ ~= 0 then\n      table.insert(sorted_list, word)\n    end\n  end\n  table.sort(sorted_list)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1a49cnyp.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp1a49cnyp.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, v in ipairs(lst) do\n    table.insert(sorted_list,\
    \ v)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvii1_wp7.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpvii1_wp7.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      sorted_list[i] = word[word_size/2]\n\
    \    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdli_vzz6.lua:31:\
    \ expected: {\"AI\", \"asdf\", \"school\"}\nactual: {\"school\", \"AI\", \"asdf\"\
    }\nstack traceback:\n\t/tmp/tmpdli_vzz6.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for i = 1, #lst do\n    local word = lst[i]\n    local\
    \ length = #word\n    if length % 2 == 1 then\n      sorted_lst[#sorted_lst +\
    \ 1] = word\n    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a\
    \ > #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp10_pka_7.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"aaa\", \"a\"}\nstack traceback:\n\t/tmp/tmp10_pka_7.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_len = #sorted_list\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp3rv8xgqi.lua:80: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index <= sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    if current_word_size % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      local next_word_index = 1\n  \
    \    while next_word_index < next_word_size do\n        if current_word_index\
    \ == next_word_index then\n          sorted_list[sorted_list_index + current_word_index]\
    \ = nil\n          sorted_list_index = sorted_list_index + current_word_index\n\
    \        end\n        if next_word_index == current_word_index + 1 then\n    \
    \      sorted_list[sorted_list_index + current_word_index + 1] = nil\n       \
    \   sorted_list_index = sorted_list_index + current_word_index + 1\n        end\n\
    \        next_word_index = next_word_index + 1\n      end\n      current_word_index\
    \ = current_word_index + 1\n    end\n    sorted_list_index = sorted_list_index\
    \ + 1\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxh59p6dp.lua:47:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpxh59p6dp.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    if current_word_size % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ local length = string.len(lst[i])\n    if length % 2 == 1 then\n      sorted_lst[sorted_index]\
    \ = lst[i]\n      sorted_index = sorted_index + 1\n    end\n  end\n  table.sort(sorted_lst,\
    \ function(a, b) return string.len(a) > string.len(b) end)\n  return sorted_lst\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_b9xzeok.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"aaa\", \"a\"}\nstack traceback:\n\t/tmp/tmp_b9xzeok.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j], sorted_list[i] = sorted_list[i],\
    \ sorted_list[j]\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyfx9rsgy.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpyfx9rsgy.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = {}\n  for i = 1, #lst do\n  \
    \  sorted_index[lst[i]] = i\n  end\n  for i = 1, #lst do\n    if sorted_index[lst[i]]\
    \ then\n      table.insert(sorted_lst, lst[i])\n      sorted_index[lst[i]] = nil\n\
    \    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a < #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2uzb0t5q.lua:33:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp2uzb0t5q.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, str in ipairs(lst) do\n    table.insert(sorted_list,\
    \ str)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg2x9njjw.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpg2x9njjw.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      if next_word_size == current_word_size\
    \ then\n        sorted_list[sorted_list_index + current_word_index] = next_word\n\
    \      else\n        local next_word_index = current_word_index + next_word_size\
    \ - 1\n        if next_word_index > sorted_list_index then\n          sorted_list[sorted_list_index\
    \ + current_word_index] = next_word\n        end\n      end\n      current_word_index\
    \ = current_word_index + 1\n    end\n    sorted_list_index = sorted_list_index\
    \ + 1\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplnixq_2j.lua:43:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmplnixq_2j.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = 0\n  for _, word in ipairs(lst)\
    \ do\n    sorted_list_length = sorted_list_length + #word\n    sorted_list[#sorted_list\
    \ + 1] = word\n  end\n  table.sort(sorted_list, function(a, b) return #a < #b\
    \ end)\n  local sorted_list_index = 1\n  for _, word in ipairs(lst) do\n    sorted_list[sorted_list_index]\
    \ = word\n    sorted_list_index = sorted_list_index + 1\n  end\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplfmo0_ux.lua:33:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmplfmo0_ux.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ v)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n  return\
    \ sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9lbesztj.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp9lbesztj.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    local current_word_index = 1\n    while current_word_index\
    \ < current_word_length do\n      local next_word = sorted_list[sorted_list_index\
    \ + current_word_index]\n      local next_word_length = #next_word\n      if next_word_length\
    \ < current_word_length then\n        sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n        sorted_list_index = sorted_list_index + current_word_index\n\
    \      else\n        local next_word_index = current_word_index + next_word_length\
    \ - 1\n        local next_word_value = next_word[next_word_index]\n        local\
    \ next_word_value_length = #next_word_value\n        if next_word_value_length\
    \ < current_word_length then\n          sorted_list[sorted_list_index + current_word_index]\
    \ = next_word_value\n          sorted_list_index = sorted_list_index + current_word_index\n\
    \        else\n          local next_word_value_index = current_word_index + next_word_value_length\
    \ - 1\n          local next_word_value_value = next_word_value[next_word_value_index]\n\
    \          local next_word_value_value_length = #next_word_value_value\n     \
    \     if next_word_value_value_length < current_word_length then\n           \
    \ sorted_list[sorted_list_index + current_word_index] = next_word_value_value\n\
    \            sorted_list_index = sorted_list_index + current_word_index\n    \
    \      else\n            local next_word_value_index2 = current_word_index + next_word_value_value_length\
    \ - 1\n            local next_word_value_value2 = next_word_value[next_word_value_index2]\n\
    \            local next_word_value_value2_length = #next_word_value_value2\n \
    \           if next_word_value_value2_length < current_word_length then\n    \
    \          sorted_list[sorted_list_index + current_word_index] = next_word_value_value2\n\
    \              sorted_list_index = sorted_list_index + current_word_index\n  \
    \          else\n              local next_word_value_index3 = current_word_index\
    \ + next_word_value_value_length - 1\n              local next_word_value_value3\
    \ = next_word_value[next_word_value_index3]\n              local next_word_value_value3_length\
    \ = #next_word_value_value3\n              if next_word_value_value3_length <\
    \ current_word_length then\n                sorted_list[sorted_list_index + current_word_index]\
    \ = next_word_value_value3\n                sorted_list_index = sorted_list_index\
    \ + current_word_index\n              else\n                local next_word_value_index4\
    \ = current_word_index + next_word_value_value_length - 1\n                local\
    \ next_word_value_value4 = next_word_value[next_word_value_index4]\n         \
    \       local next_word_value_value4_length = #\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp3hid_758.lua:60: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j] = nil\n      elseif next_word_size\
    \ > current_word_size then\n        sorted_list[i] = current_word\n        sorted_list_size\
    \ = j - 1\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpebt9dvnh.lua:37:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpebt9dvnh.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_keys = {}\n  local sorted_vals = {}\n\
    \  local sorted_key\n  local sorted_val\n  for _, word in ipairs(lst) do\n   \
    \ sorted_key = word:len()\n    sorted_val = word\n    if sorted_keys[sorted_key]\
    \ == nil then\n      sorted_keys[sorted_key] = true\n      sorted_lst[#sorted_lst\
    \ + 1] = sorted_val\n    end\n  end\n  for _, sorted_key in ipairs(sorted_keys)\
    \ do\n    sorted_val = sorted_lst[#sorted_lst + 1]\n    sorted_lst[#sorted_lst\
    \ + 1] = sorted_val\n  end\n  return sorted_lst\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfs_uxn_x.lua:38:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpfs_uxn_x.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = {}\n  local sorted_lengths =\
    \ {}\n  for i = 1, #lst do\n    local length = #lst[i]\n    sorted_lengths[length]\
    \ = length\n    sorted_index[length] = i\n  end\n  table.sort(sorted_lengths,\
    \ function(a, b) return a < b end)\n  for i = 1, #sorted_lengths do\n    sorted_lst[i]\
    \ = lst[sorted_index[sorted_lengths[i]]]\n  end\n  return sorted_lst\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6vp_2agw.lua:33:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp6vp_2agw.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j] = nil\n      elseif next_word_size\
    \ > current_word_size then\n        sorted_list[i] = current_word\n        sorted_list[j]\
    \ = next_word\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy4yopzot.lua:37:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpy4yopzot.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  for i\
    \ = 1, sorted_list_length do\n    local current_word = sorted_list[i]\n    local\
    \ current_word_length = #current_word\n    for j = i + 1, sorted_list_length do\n\
    \      local next_word = sorted_list[j]\n      local next_word_length = #next_word\n\
    \      if current_word_length == next_word_length then\n        sorted_list[j]\
    \ = nil\n      elseif current_word_length > next_word_length then\n        sorted_list[j\
    \ + 1] = current_word\n        sorted_list[j] = nil\n      else\n        sorted_list[j\
    \ + 1] = next_word\n      end\n    end\n  end\n  return sorted_list\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgqn42hw7.lua:19:\
    \ attempt to get length of local 'current_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmpgqn42hw7.lua:39: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        if current_word < next_word then\n         \
    \ table.insert(sorted_list, current_word)\n          table.remove(sorted_list,\
    \ j)\n        end\n      else\n        if current_word_size > next_word_size then\n\
    \          table.insert(sorted_list, current_word)\n          table.remove(sorted_list,\
    \ j)\n        end\n      end\n    end\n  end\n  return sorted_list\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqrt8gqib.lua:42:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"aaa\", \"aaa\"}\nstack traceback:\n\t\
    /tmp/tmpqrt8gqib.lua:42: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ local word = lst[i]\n    local length = #word\n    if length % 2 == 1 then\n\
    \      sorted_lst[sorted_index] = word\n      sorted_index = sorted_index + 1\n\
    \    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a < #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpahlrll__.lua:32:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpahlrll__.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        if current_word < next_word then\n         \
    \ table.insert(sorted_list, current_word)\n          table.insert(sorted_list,\
    \ next_word)\n        end\n      else\n        if current_word_size > next_word_size\
    \ then\n          table.insert(sorted_list, current_word)\n        end\n     \
    \ end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpznc5f7wb.lua:41:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\", \"aa\"}\nstack traceback:\n\
    \t/tmp/tmpznc5f7wb.lua:41: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = 0\n  for _, word in ipairs(lst)\
    \ do\n    sorted_list[sorted_list_length] = word\n    sorted_list_length = sorted_list_length\
    \ + 1\n  end\n  table.sort(sorted_list, function(a, b) return #a == #b end)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9xi3y77t.lua:28:\
    \ expected: {\"aa\"}\nactual: {0=\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t\
    /tmp/tmp9xi3y77t.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_len = #lst\n  for i = 1, sorted_list_len\
    \ do\n    local word = lst[i]\n    local word_len = #word\n    if word_len % 2\
    \ ~= 0 then\n      table.insert(sorted_list, word)\n    end\n  end\n  table.sort(sorted_list,\
    \ function(a, b) return #a < #b end)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxgq_z5xg.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpxgq_z5xg.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = #sorted_list, 1, -1 do\n    local j = i\n\
    \    while j > 0 and sorted_list[j - 1] == sorted_list[j] do\n      table.remove(sorted_list,\
    \ j)\n      j = j - 1\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxuc1q_1r.lua:29:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpxuc1q_1r.lua:29:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, word in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ word)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpety2aytd.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpety2aytd.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, word in ipairs(lst) do\n    sorted_list[#sorted_list\
    \ + 1] = word\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_qdzp36t.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp_qdzp36t.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      sorted_list[i - 1] = word\n \
    \   end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpojl1v9m9.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\", \"aaa\"}\nstack traceback:\n\t\
    /tmp/tmpojl1v9m9.lua:30: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        if current_word < next_word then\n         \
    \ table.insert(sorted_list, current_word)\n          table.insert(sorted_list,\
    \ next_word)\n          break\n        end\n      elseif current_word_size > next_word_size\
    \ then\n        break\n      end\n    end\n  end\n  return sorted_list\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpk2hbpk2r.lua:40:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpk2hbpk2r.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index <= sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    if current_word_size % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, v in ipairs(lst) do\n    table.insert(sorted_list,\
    \ v)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpesvcrg24.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpesvcrg24.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      table.insert(sorted_list, word)\n\
    \    end\n  end\n  table.sort(sorted_list, function(a, b) return #a < #b end)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_orvsmb_.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"a\", \"aa\", \"aaa\", \"aaa\"}\nstack\
    \ traceback:\n\t/tmp/tmp_orvsmb_.lua:31: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = {}\n  local sorted_index_count\
    \ = 0\n  for i = 1, #lst do\n    sorted_index[#sorted_index + 1] = i\n  end\n\
    \  table.sort(sorted_index, function(a, b) return sorted_index[a] < sorted_index[b]\
    \ end)\n  for i = 1, #lst do\n    if sorted_index[i] ~= i then\n      sorted_lst[sorted_index_count]\
    \ = lst[i]\n      sorted_index_count = sorted_index_count + 1\n    end\n  end\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt3u3ncju.lua:34:\
    \ expected: {\"aa\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpt3u3ncju.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, item in ipairs(lst) do\n    table.insert(sorted_list,\
    \ item)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpggc6jjjp.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpggc6jjjp.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for i = 1, #lst do\n    local word = lst[i]\n    local\
    \ word_length = #word\n    if word_length % 2 == 1 then\n      sorted_lst[#sorted_lst\
    \ + 1] = word\n    end\n  end\n  table.sort(sorted_lst, function(a, b) return\
    \ #a == #b end)\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkx_kp4kb.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpkx_kp4kb.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 ~= 0 then\n      sorted_list[i] = word\n    end\n\
    \  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqpjsgiu5.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpqpjsgiu5.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = 0\n  local sorted_list_index\
    \ = 0\n  local sorted_list_value = nil\n  local sorted_list_value = nil\n  local\
    \ sorted_list_value = nil\n  for _, value in ipairs(lst) do\n    sorted_list_length\
    \ = sorted_list_length + 1\n    sorted_list_value = sorted_list_value .. value\n\
    \  end\n  sorted_list[#sorted_list+1] = sorted_list_value\n  for _, value in ipairs(lst)\
    \ do\n    if sorted_list_length == sorted_list_index then\n      sorted_list[#sorted_list+1]\
    \ = sorted_list_value .. value\n      sorted_list_index = sorted_list_index +\
    \ 1\n      sorted_list_length = 0\n      sorted_list_value = nil\n      sorted_list_value\
    \ = nil\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_a3ucjt8.lua:23:\
    \ attempt to concatenate local 'sorted_list_value' (a nil value)\nstack traceback:\n\
    \t/tmp/tmp_a3ucjt8.lua:41: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j], sorted_list[i] = sorted_list[i],\
    \ sorted_list[j]\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfd9s4u5n.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpfd9s4u5n.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_len = #sorted_list\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len + 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len + 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len + 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_len + 1\n  local sorted_list_len\
    \ = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len + 1\n  local\
    \ sorted_list_len = sorted_list_len - 1\n  local sorted_list_len = sorted_list_len\
    \ + 1\n  local sorted_list_len = sorted_list_len - 1\n  local sorted_list_len\
    \ = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len - 1\n  local\
    \ sorted_list_len = sorted_list_len + 1\n  local sorted_list_len = sorted_list_len\
    \ - 1\n  local sorted_list_len = sorted_list_\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvqt5q67f.lua:80: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j] = nil\n      elseif next_word_size\
    \ > current_word_size then\n        sorted_list[i] = current_word\n        sorted_list_size\
    \ = j\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplf2wcq7g.lua:37:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmplf2wcq7g.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    local current_word_index = 1\n    while current_word_index\
    \ < current_word_length do\n      local next_word = sorted_list[sorted_list_index\
    \ + current_word_index]\n      local next_word_length = #next_word\n      if next_word_length\
    \ < current_word_length then\n        sorted_list[sorted_list_index + current_word_index]\
    \ = nil\n      else\n        local next_word_index = current_word_index + next_word_length\n\
    \        local next_word_value = next_word\n        sorted_list[sorted_list_index\
    \ + current_word_index] = next_word_value\n        sorted_list_index = sorted_list_index\
    \ + next_word_length\n      end\n      current_word_index = current_word_index\
    \ + next_word_length\n    end\n    sorted_list_index = sorted_list_index + current_word_length\n\
    \  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj5ki05_i.lua:43:\
    \ expected: {\"aa\"}\nactual: {\"aa\", 3=\"aaa\"}\nstack traceback:\n\t/tmp/tmpj5ki05_i.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j] = nil\n      elseif current_word_size\
    \ > next_word_size then\n        sorted_list[i] = nil\n      else\n        sorted_list[j],\
    \ sorted_list[i] = sorted_list[i], sorted_list[j]\n      end\n    end\n  end\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph8ik7snm.lua:22:\
    \ attempt to get length of local 'next_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmph8ik7snm.lua:38: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    if current_word_length % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ local word = lst[i]\n    local length = #word\n    if length % 2 == 1 then\n\
    \      sorted_lst[sorted_index] = word\n      sorted_index = sorted_index + 1\n\
    \    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a < #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf0qc4m6p.lua:32:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpf0qc4m6p.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_index_size = 1\n  local sorted_list_index_max = #sorted_list\n\
    \  local sorted_list_index_max_size = 1\n  local sorted_list_index_max_value =\
    \ sorted_list_index_max\n  local sorted_list_index_max_value_max = sorted_list_index_max\n\
    \  local sorted_list_index_max_value_min = sorted_list_index_max\n  local sorted_list_index_max_value_min_size\
    \ = sorted_list_index_max_size\n  local sorted_list_index_max_value_min_value\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max =\
    \ sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_size\
    \ = sorted_list_index_max_size\n  local sorted_list_index_max_value_min_value_max_value\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max_size\
    \ = sorted_list_index_max_size\n  local sorted_list_index_max_value_min_value_max_value_max_value\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max_value_max\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_size\
    \ = sorted_list_index_max_size\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value_max\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value_max_size\
    \ = sorted_list_index_max_size\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value_max_value\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value_max_value_max\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value_max_value_max_size\
    \ = sorted_list_index_max_size\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value_max_value_max_value\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value_max_value_max_value_max_size\
    \ = sorted_list_index_max_size\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value_max_value_max_value_max_value\
    \ = sorted_list_index_max\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_value_max_value_max_value_max_value_max_size\
    \ = sorted_list_index_max_size\n  local sorted_list_index_max_value_min_value_max_value_max_value_max_\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpe9ntgj9k.lua:58: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_length = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index <= sorted_list_length do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_length = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index <= current_word_length\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_length = #next_word\n      if next_word_length == current_word_length\
    \ then\n        sorted_list[sorted_list_index + current_word_index] = nil\n  \
    \    else\n        local next_word_index = 1\n        while next_word_index <=\
    \ next_word_length do\n          if next_word_index == current_word_index then\n\
    \            sorted_list[sorted_list_index + current_word_index] = next_word\n\
    \          else\n            sorted_list[sorted_list_index + current_word_index\
    \ + 1] = next_word\n          end\n          next_word_index = next_word_index\
    \ + 1\n        end\n      end\n      current_word_index = current_word_index +\
    \ 1\n    end\n    sorted_list_index = sorted_list_index + 1\n  end\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptntbpqcg.lua:26:\
    \ attempt to get length of local 'next_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmptntbpqcg.lua:50: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      table.insert(sorted_list, word)\n\
    \    end\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplksxctp6.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"a\", \"aa\", \"aaa\", \"aaa\"}\nstack\
    \ traceback:\n\t/tmp/tmplksxctp6.lua:31: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  for i\
    \ = 1, sorted_list_length do\n    local current_word = sorted_list[i]\n    local\
    \ current_word_length = #current_word\n    for j = i + 1, sorted_list_length do\n\
    \      local next_word = sorted_list[j]\n      local next_word_length = #next_word\n\
    \      if next_word_length < current_word_length then\n        sorted_list[j],\
    \ sorted_list[i] = sorted_list[i], sorted_list[j]\n      end\n    end\n  end\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpze0nqh27.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpze0nqh27.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, word in ipairs(lst) do\n    table.insert(sorted_list,\
    \ word)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprtl44n7s.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmprtl44n7s.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      sorted_list[i - 1] = word\n \
    \     sorted_list[i - 1] = word\n    end\n  end\n  return sorted_list\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppw2zkk8e.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\", \"aaa\"}\nstack traceback:\n\t\
    /tmp/tmppw2zkk8e.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ if sorted_index == #sorted_lst then\n      table.insert(sorted_lst, lst[i])\n\
    \      sorted_index = sorted_index + 1\n    elseif sorted_index ~= #sorted_lst\
    \ then\n      if sorted_index == 1 then\n        table.insert(sorted_lst, lst[i])\n\
    \      else\n        local first_word = sorted_lst[#sorted_lst]\n        local\
    \ second_word = lst[i]\n        if second_word < first_word then\n          table.insert(sorted_lst,\
    \ second_word)\n        else\n          table.insert(sorted_lst, first_word)\n\
    \        end\n      end\n    end\n  end\n  return sorted_lst\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpurrcrcdj.lua:41:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpurrcrcdj.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    local current_word_index = 1\n    while current_word_index\
    \ < current_word_length do\n      local next_word = sorted_list[sorted_list_index\
    \ + current_word_index]\n      local next_word_length = #next_word\n      if next_word_length\
    \ == current_word_length then\n        sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n      else\n        local next_word_index = 1\n        while next_word_index\
    \ < next_word_length do\n          local next_next_word = sorted_list[sorted_list_index\
    \ + current_word_index + next_word_index]\n          local next_next_word_length\
    \ = #next_next_word\n          if next_next_word_length == next_word_length then\n\
    \            sorted_list[sorted_list_index + current_word_index + next_word_index]\
    \ = next_next_word\n          else\n            local next_next_word_index = 1\n\
    \            while next_next_word_index < next_next_word_length do\n         \
    \     local next_next_next_word = sorted_list[sorted_list_index + current_word_index\
    \ + next_word_index + next_next_word_index]\n              local next_next_next_word_length\
    \ = #next_next_next_word\n              if next_next_next_word_length == next_next_word_length\
    \ then\n                sorted_list[sorted_list_index + current_word_index + next_word_index\
    \ + next_next_word_index] = next_next_next_word\n              else\n        \
    \        next_next_word_index = next_next_word_index + 1\n              end\n\
    \            end\n          end\n          next_word_index = next_word_index +\
    \ 1\n        end\n      end\n      current_word_index = current_word_index + 1\n\
    \    end\n    sorted_list_index = sorted_list_index + 1\n  end\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpha8ayr92.lua:59:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpha8ayr92.lua:59:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    if current_word_size % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  local sorted_value = lst[1]\n\
    \  for i = 2, #lst do\n    if sorted_value == lst[i] then\n      sorted_index\
    \ = sorted_index + 1\n    else\n      table.insert(sorted_lst, sorted_value)\n\
    \      sorted_index = sorted_index + 1\n      sorted_value = lst[i]\n    end\n\
    \  end\n  table.insert(sorted_lst, sorted_value)\n  return sorted_lst\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsw0bpdy7.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpsw0bpdy7.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      sorted_list[i] = word\n    end\n\
    \  end\n  table.sort(sorted_list, function(a, b) return #a < #b end)\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbz4jyxfp.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpbz4jyxfp.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      if next_word_size == current_word_size\
    \ then\n        sorted_list[sorted_list_index + current_word_index] = next_word\n\
    \      else\n        local next_word_index = current_word_index + next_word_size\
    \ - 1\n        local next_word_value = next_word[next_word_index]\n        local\
    \ next_word_value = next_word_value:lower()\n        local next_word_value = next_word_value:gsub(\"\
    [^a-z]\", \"\")\n        if next_word_value == \"\" then\n          sorted_list[sorted_list_index\
    \ + current_word_index] = next_word\n        end\n      end\n      current_word_index\
    \ = next_word_index + 1\n    end\n    sorted_list_index = sorted_list_index +\
    \ 1\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplud8heys.lua:30:\
    \ attempt to index local 'next_word_value' (a nil value)\nstack traceback:\n\t\
    /tmp/tmplud8heys.lua:46: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = 1, #sorted_list do\n    local j = i\n  \
    \  while j > 0 and sorted_list[j - 1] == sorted_list[j] do\n      sorted_list[j]\
    \ = nil\n      j = j - 1\n    end\n  end\n  table.sort(sorted_list)\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4xmj1o3k.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp4xmj1o3k.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, word in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ word)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_tw4lcnc.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp_tw4lcnc.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_len = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_len = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_len = #lst\n  local sorted_list_index = 1\n  local sorted_list_len\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_len = #lst\n  local\
    \ sorted_list_index = 1\n  local sorted_list_len = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_len = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_len = #lst\n  local sorted_list_index = 1\n  local sorted_list_len\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_len = #lst\n  local\
    \ sorted_list_index = 1\n  local sorted_list_len = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_len = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_len = #lst\n  local sorted_list_index = 1\n  local sorted_list_len\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_len = #lst\n  local\
    \ sorted_list_index = 1\n  local sorted_list_len = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_len = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_len = #lst\n  local sorted_list_index = 1\n  local sorted_list_len\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_len = #lst\n  local\
    \ sorted_list_index = 1\n  local sorted_list_len = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_len = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_len = #lst\n  local sorted_list_index = 1\n  local sorted_list_len\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_len = #lst\n  local\
    \ sorted_list_index = 1\n  local sorted_list_len = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_len = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_len = #lst\n  local sorted_list_index = 1\n  local sorted_list_len\
    \ = #lst\n  local sorted_list_index = 1\n  local sorted_list_len = #lst\n  local\
    \ sorted_list_index = 1\n  local sorted_list_len = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_len = #lst\n  local sorted_list_index = 1\n  local\
    \ sorted_list_len = #lst\n  local sorted_list_index = 1\n  local sorted_list_len\
    \ = #lst\n  local \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpxumj5sld.lua:97: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  local sorted_list_value = sorted_list[sorted_list_index]\n\
    \  while sorted_list_index < sorted_list_length do\n    local next_value = sorted_list[sorted_list_index]\n\
    \    local next_length = #next_value\n    if next_length > 1 then\n      local\
    \ next_index = 1\n      while next_index < next_length do\n        local next_value\
    \ = sorted_list[sorted_list_index + next_index]\n        local next_length = #next_value\n\
    \        if next_length > 1 then\n          local next_index = 1\n          while\
    \ next_index < next_length do\n            local next_value = sorted_list[sorted_list_index\
    \ + next_index]\n            local next_length = #next_value\n            if next_length\
    \ > 1 then\n              local next_index = 1\n              while next_index\
    \ < next_length do\n                local next_value = sorted_list[sorted_list_index\
    \ + next_index]\n                local next_length = #next_value\n           \
    \     if next_length > 1 then\n                  local next_index = 1\n      \
    \            while next_index < next_length do\n                    local next_value\
    \ = sorted_list[sorted_list_index + next_index]\n                    local next_length\
    \ = #next_value\n                    if next_length > 1 then\n               \
    \       local next_index = 1\n                      while next_index < next_length\
    \ do\n                        local next_value = sorted_list[sorted_list_index\
    \ + next_index]\n                        local next_length = #next_value\n   \
    \                     if next_length > 1 then\n                          local\
    \ next_index = 1\n                          while next_index < next_length do\n\
    \                            local next_value = sorted_list[sorted_list_index\
    \ + next_index]\n                            local next_length = #next_value\n\
    \                            if next_length > 1 then\n                       \
    \       local next_index = 1\n                              while next_index <\
    \ next_length do\n                                local next_value = sorted_list[sorted_list_index\
    \ + next_index]\n                                local next_length = #next_value\n\
    \                                if next_length > 1 then\n                   \
    \               local next_index = 1\n                                  while\
    \ next_index < next_length do\n                                    local next_value\
    \ = sorted_list[sorted_list_index + next_index]\n                            \
    \        local next_length = #next_value\n                                   \
    \ if next_length > 1 then\n                                      local next_index\
    \ = 1\n                                      while next_index < next_length do\n\
    \                                        local next_value = sorted_list[sorted_list_index\
    \ + next_index]\n                                        local next_length = #next_value\n\
    \                                        if next_length > 1 then\n           \
    \                               local next_index = 1\n                       \
    \                   while next_index < next_length do\n                      \
    \                      local next_value = sorted_list[sorted_list_index + next_index]\n\
    \                                            local next_length = #next_value\n\
    \                                            if next_length > 1 then\n       \
    \                                       local next_index = 1\n               \
    \                               while next_index < next_length do\n          \
    \                                      local next_value = sorted_list[sorted_list_index\
    \ + next_index]\n                                                local next_length\
    \ = #next_value\n                                                if next_length\
    \ > 1 then\n                                                  \nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpkhceiglm.lua:92: 'end' expected (to close 'if' at line 77)\
    \ near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j], current_word = current_word,\
    \ next_word\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfw1gwbkx.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpfw1gwbkx.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  for i = 1, #lst do\n    local word = sorted_list[i]\n\
    \    local word_length = #word\n    local j = 1\n    while j <= #sorted_list and\
    \ word_length < sorted_list[j - 1] do\n      sorted_list[i - 1] = sorted_list[j\
    \ - 1]\n      i = i - 1\n      j = j + 1\n    end\n    sorted_list[i - 1] = word\n\
    \  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppj44tf6n.lua:20:\
    \ attempt to compare number with nil\nstack traceback:\n\t/tmp/tmppj44tf6n.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    if current_word_size % 2 == 1 then\n      -- If the current word has an odd\
    \ length, delete it\n      sorted_list[sorted_list_index] = nil\n      sorted_list_size\
    \ = sorted_list_size - 1\n    else\n      -- If the current word has an even length,\
    \ sort it alphabetically\n      table.insert(sorted_list, current_word)\n    end\n\
    \    sorted_list_index = sorted_list_index + 1\n  end\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb4fqdk22.lua:37:\
    \ expected: {\"aa\"}\nactual: {\"aa\", 3=\"aaa\", 4=\"aa\"}\nstack traceback:\n\
    \t/tmp/tmpb4fqdk22.lua:37: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ v)\n  end\n  table.sort(sorted_lst, function(a, b) return #a == #b end)\n  return\
    \ sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm7hjeqno.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpm7hjeqno.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j] = nil\n      elseif next_word_size\
    \ > current_word_size then\n        sorted_list[i] = current_word\n        sorted_list_size\
    \ = j\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbxl08yk1.lua:37:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpbxl08yk1.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_value = sorted_list[sorted_list_index]\n  while sorted_list_index\
    \ < sorted_list_size do\n    local current_value = sorted_list[sorted_list_index]\n\
    \    local current_index = sorted_list_index\n    while current_index > 1 do\n\
    \      if current_value == sorted_list[current_index - 2] then\n        sorted_list[current_index]\
    \ = sorted_list[current_index - 1]\n        current_index = current_index - 1\n\
    \      else\n        break\n      end\n    end\n    sorted_list[current_index]\
    \ = current_value\n    sorted_list_index = sorted_list_index + 1\n  end\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzm3ewyt4.lua:39:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpzm3ewyt4.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  for i = 1, sorted_list_length\
    \ do\n    local word = lst[i]\n    local word_length = #word\n    if word_length\
    \ % 2 == 1 then\n      table.insert(sorted_list, word)\n    end\n  end\n  table.sort(sorted_list)\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_3acmfbd.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp_3acmfbd.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    if current_word_length % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j], sorted_list[i] = sorted_list[i],\
    \ sorted_list[j]\n      elseif current_word_size > next_word_size then\n     \
    \   sorted_list[j], sorted_list[i + 1] = sorted_list[i + 1], sorted_list[j]\n\
    \      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptf6ubsmf.lua:36:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmptf6ubsmf.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      if next_word_size == current_word_size\
    \ then\n        sorted_list[sorted_list_index + current_word_index] = next_word\n\
    \      else\n        local next_word_index = current_word_index + next_word_size\n\
    \        local next_word_value = next_word\n        sorted_list[sorted_list_index\
    \ + current_word_index] = next_word_value\n        sorted_list_index = sorted_list_index\
    \ + next_word_size\n      end\n      current_word_index = current_word_index +\
    \ next_word_size\n    end\n    sorted_list_index = sorted_list_index + current_word_size\n\
    \  end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgss1ywkh.lua:43:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpgss1ywkh.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if next_word_size\
    \ == current_word_size then\n        sorted_list[j], sorted_list[i] = sorted_list[i],\
    \ sorted_list[j]\n      elseif next_word_size > current_word_size then\n     \
    \   sorted_list[j], sorted_list[i + 1] = sorted_list[i + 1], sorted_list[j]\n\
    \      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa9cp1exy.lua:36:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"aaa\", \"a\"}\nstack traceback:\n\t/tmp/tmpa9cp1exy.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j] = nil\n      elseif current_word_size\
    \ > next_word_size then\n        sorted_list[j + 1] = nil\n      else\n      \
    \  sorted_list[i] = nil\n      end\n    end\n  end\n  return sorted_list\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpscezlm89.lua:22:\
    \ attempt to get length of local 'next_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmpscezlm89.lua:38: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        if current_word < next_word then\n         \
    \ table.insert(sorted_list, current_word)\n          sorted_list_size = sorted_list_size\
    \ - 1\n        end\n      else\n        if current_word_size > next_word_size\
    \ then\n          table.insert(sorted_list, next_word)\n          sorted_list_size\
    \ = sorted_list_size - 1\n        end\n      end\n    end\n  end\n  return sorted_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7c5s0z_9.lua:42:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\", \"a\"}\nstack traceback:\n\
    \t/tmp/tmp7c5s0z_9.lua:42: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_value = lst[1]\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = sorted_list_value\n  local sorted_list_value = sorted_list_value\n\
    \  local sorted_list_value = \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfey9ay3w.lua:73: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    local current_word_index = 1\n    while current_word_index\
    \ < current_word_length do\n      local next_word = sorted_list[sorted_list_index\
    \ + current_word_index]\n      local next_word_length = #next_word\n      if next_word_length\
    \ < current_word_length then\n        sorted_list[sorted_list_index + current_word_index]\
    \ = next_word\n      else\n        sorted_list_index = sorted_list_index + current_word_index\n\
    \      end\n      current_word_index = current_word_index + next_word_length\n\
    \    end\n    sorted_list_index = sorted_list_index + current_word_length\n  end\n\
    \  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptf_n83bm.lua:40:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmptf_n83bm.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        if current_word < next_word then\n         \
    \ table.insert(sorted_list, current_word)\n          table.insert(sorted_list,\
    \ next_word)\n          break\n        end\n      else\n        if current_word_size\
    \ > next_word_size then\n          table.insert(sorted_list, next_word)\n    \
    \      break\n        end\n      end\n    end\n  end\n  return sorted_list\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph1pzgomp.lua:43:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\", \"a\"}\nstack traceback:\n\
    \t/tmp/tmph1pzgomp.lua:43: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  local sorted_length = 1\n\
    \  for i = 1, #lst do\n    local length = #lst[i]\n    if sorted_length == length\
    \ then\n      sorted_lst[sorted_index] = lst[i]\n      sorted_index = sorted_index\
    \ + 1\n      sorted_length = length\n    else\n      sorted_length = length\n\
    \    end\n  end\n  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpobn7_ewo.lua:34:\
    \ expected: {\"aa\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpobn7_ewo.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, v in ipairs(lst) do\n    table.insert(sorted_list,\
    \ v)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0300hovu.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp0300hovu.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index <= sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index <= current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      if next_word_size % 2 ~= 0 then\n\
    \        sorted_list[sorted_list_index + current_word_index] = next_word\n   \
    \   end\n      current_word_index = current_word_index + next_word_size\n    end\n\
    \    sorted_list_index = sorted_list_index + current_word_size\n  end\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46hmw62x.lua:24:\
    \ attempt to get length of local 'next_word' (a nil value)\nstack traceback:\n\
    \t/tmp/tmp46hmw62x.lua:38: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  for _, word in ipairs(lst) do\n    table.insert(sorted_list,\
    \ word)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplo3mzmjn.lua:26:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmplo3mzmjn.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for i = 1, #lst do\n   \
    \ local word = lst[i]\n    local length = #word\n    if length % 2 == 1 then\n\
    \      sorted_lst[sorted_index] = word\n      sorted_index = sorted_index + 1\n\
    \    end\n  end\n  table.sort(sorted_lst, function(a, b) return #a > #b end)\n\
    \  return sorted_lst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg16qdk8b.lua:32:\
    \ expected: {\"aa\"}\nactual: {\"aaa\", \"a\"}\nstack traceback:\n\t/tmp/tmpg16qdk8b.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = { }\n  local sorted_list_length = #lst\n  local sorted_list_index\
    \ = 1\n  local sorted_list_value = lst[1]\n  local sorted_list_value_index = 1\n\
    \  local sorted_list_value_length = #sorted_list_value\n  local sorted_list_value_length_index\
    \ = 1\n  local sorted_list_value_length_sum = 0\n  local sorted_list_value_length_sum_temp\
    \ = 0\n  local sorted_list_value_length_sum_temp_index = 1\n  local sorted_list_value_length_sum_temp_value\
    \ = 1\n  local sorted_list_value_length_sum_temp_index2 = 1\n  local sorted_list_value_length_sum_temp_value2\
    \ = 1\n  local sorted_list_value_length_sum_temp_index3 = 1\n  local sorted_list_value_length_sum_temp_value3\
    \ = 1\n  local sorted_list_value_length_sum_temp_index4 = 1\n  local sorted_list_value_length_sum_temp_value4\
    \ = 1\n  local sorted_list_value_length_sum_temp_index5 = 1\n  local sorted_list_value_length_sum_temp_value5\
    \ = 1\n  local sorted_list_value_length_sum_temp_index6 = 1\n  local sorted_list_value_length_sum_temp_value6\
    \ = 1\n  local sorted_list_value_length_sum_temp_index7 = 1\n  local sorted_list_value_length_sum_temp_value7\
    \ = 1\n  local sorted_list_value_length_sum_temp_index8 = 1\n  local sorted_list_value_length_sum_temp_value8\
    \ = 1\n  local sorted_list_value_length_sum_temp_index9 = 1\n  local sorted_list_value_length_sum_temp_value9\
    \ = 1\n  local sorted_list_value_length_sum_temp_index10 = 1\n  local sorted_list_value_length_sum_temp_value10\
    \ = 1\n  local sorted_list_value_length_sum_temp_index11 = 1\n  local sorted_list_value_length_sum_temp_value11\
    \ = 1\n  local sorted_list_value_length_sum_temp_index12 = 1\n  local sorted_list_value_length_sum_temp_value12\
    \ = 1\n  local sorted_list_value_length_sum_temp_index13 = 1\n  local sorted_list_value_length_sum_temp_value13\
    \ = 1\n  local sorted_list_value_length_sum_temp_index14 = 1\n  local sorted_list_value_length_sum_temp_value14\
    \ = 1\n  local sorted_list_value_length_sum_temp_index15 = 1\n  local sorted_list_value_length_sum_temp_value15\
    \ = 1\n  local sorted_list_value_length_sum_temp_index16 = 1\n  local sorted_list_value_length_sum_temp_value16\
    \ = 1\n  local sorted_list_value_length_sum_temp_index17 = 1\n  local sorted_list_value_length_sum_temp_value17\
    \ = 1\n  local sorted_list_value_length_sum_temp_index18 = 1\n  local sorted_list_value_length_sum_temp_value18\
    \ = 1\n  local sorted_list_value_\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp790gy131.lua:74: 'end' expected (to close 'function' at line\
    \ 14) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      sorted_list[i] = word\n    end\n\
    \  end\n  table.sort(sorted_list)\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpo47e6_ij.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aa\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpo47e6_ij.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_lst = {}\n  local sorted_index = 1\n  for _, item in ipairs(lst)\
    \ do\n    local length = #item\n    if length % 2 == 1 then\n      sorted_lst[sorted_index]\
    \ = item\n      sorted_index = sorted_index + 1\n    end\n  end\n  return sorted_lst\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0kgiyapn.lua:30:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmp0kgiyapn.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index <= sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    if current_word_size % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_length = #sorted_list\n  local\
    \ sorted_list_index = 1\n  while sorted_list_index < sorted_list_length do\n \
    \   local current_word = sorted_list[sorted_list_index]\n    local current_word_length\
    \ = #current_word\n    if current_word_length % 2 == 1 then\n      sorted_list[sorted_list_index]\
    \ = current_word\n      sorted_list_index = sorted_list_index + 1\n    end\n \
    \ end\n  return sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local word = sorted_list[i]\n    local word_size\
    \ = #word\n    if word_size % 2 == 1 then\n      sorted_list[i - 1] = word\n \
    \     sorted_list[i - 1] = word\n    end\n  end\n  return sorted_list\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjatdxzm9.lua:31:\
    \ expected: {\"aa\"}\nactual: {\"a\", \"aaa\", \"aaa\"}\nstack traceback:\n\t\
    /tmp/tmpjatdxzm9.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  local sorted_list_index_size = #sorted_list\n  local sorted_list_index_value\
    \ = 1\n  while sorted_list_index_value < sorted_list_index_size do\n    local\
    \ current_value = sorted_list[sorted_list_index_value]\n    local current_size\
    \ = #current_value\n    local current_index = sorted_list_index\n    while current_index\
    \ < sorted_list_index_size do\n      local next_value = sorted_list[current_index]\n\
    \      local next_size = #next_value\n      if next_size > current_size then\n\
    \        sorted_list[current_index] = next_value\n        current_size = next_size\n\
    \      else\n        local next_index = current_index + 1\n        while next_index\
    \ < sorted_list_index_size do\n          local next_next_value = sorted_list[next_index]\n\
    \          local next_next_size = #next_next_value\n          if next_next_size\
    \ > current_size then\n            sorted_list[current_index] = next_next_value\n\
    \            current_size = next_next_size\n          else\n            local\
    \ next_next_index = next_index + 1\n            while next_next_index < sorted_list_index_size\
    \ do\n              local next_next_next_value = sorted_list[next_next_index]\n\
    \              local next_next_next_size = #next_next_next_value\n           \
    \   if next_next_next_size > current_size then\n                sorted_list[current_index]\
    \ = next_next_next_value\n                current_size = next_next_next_size\n\
    \              else\n                local next_next_next_index = next_next_index\
    \ + 1\n                while next_next_next_index < sorted_list_index_size do\n\
    \                  local next_next_next_next_value = sorted_list[next_next_next_index]\n\
    \                  local next_next_next_next_size = #next_next_next_next_value\n\
    \                  if next_next_next_next_size > current_size then\n         \
    \           sorted_list[current_index] = next_next_next_next_value\n         \
    \           current_size = next_next_next_next_size\n                  else\n\
    \                    local next_next_next_next_index = next_next_next_index +\
    \ 1\n                    while next_next_next_next_index < sorted_list_index_size\
    \ do\n                      local next_next_next_next_next_value = sorted_list[next_next_next_next_index]\n\
    \                      local next_next_next_next_next_size = #next_next_next_next_next_value\n\
    \                      if next_next_next_next_next_size > current_size then\n\
    \                        sorted_list[current_index] = next_next_next_next_next_value\n\
    \                        current_size = next_next_next_next_next_size\n      \
    \                else\n                        local next_next_next_next_next_index\
    \ = next_next_next_next_index + 1\n                        while next_next_next_next_next_index\
    \ < sorted_list_index_size do\n                          local next_next_next_next_next_next_value\
    \ = sorted_list[next_next_next_next_next_index]\n                          local\
    \ next_next_next_next_next_next_size = #next_next_next_next_next_next_value\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n\
    \    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school',\
    \ 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d',\
    \ 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}),\
    \ {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI',\
    \ 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}),\
    \ {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd',\
    \ 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp59hw_ltp.lua:80: 'end' expected (to close 'while' at line\
    \ 64) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j], current_word = current_word,\
    \ next_word\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsmnptapl.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpsmnptapl.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  local sorted_list_index\
    \ = 1\n  while sorted_list_index < sorted_list_size do\n    local current_word\
    \ = sorted_list[sorted_list_index]\n    local current_word_size = #current_word\n\
    \    local current_word_index = 1\n    while current_word_index < current_word_size\
    \ do\n      local next_word = sorted_list[sorted_list_index + current_word_index]\n\
    \      local next_word_size = #next_word\n      if next_word_size % 2 ~= 0 then\n\
    \        sorted_list[sorted_list_index + current_word_index] = next_word\n   \
    \   end\n      current_word_index = current_word_index + next_word_size\n    end\n\
    \    sorted_list_index = sorted_list_index + current_word_size\n  end\n  return\
    \ sorted_list\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}),\
    \ {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI',\
    \ 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n\
    \    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n\
    \    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a',\
    \ 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb',\
    \ 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprjzap8jm.lua:38:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmprjzap8jm.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Write a function that accepts a list of strings as a parameter,\n--\
    \ deletes the strings that have odd lengths from it,\n-- and returns the resulted\
    \ list with a sorted order,\n-- The list is always a list of strings and never\
    \ an array of numbers,\n-- and it may contain duplicates.\n-- The order of the\
    \ list should be ascending by length of each word, and you\n-- should return the\
    \ list sorted by that rule.\n-- If two words have the same length, sort the list\
    \ alphabetically.\n-- The function should return a list of strings in sorted order.\n\
    -- You may assume that all words will have the same length.\n-- For example:\n\
    -- assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n-- assert list_sort([\"\
    ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlocal function sorted_list_sum(lst)\n\
    \  local sorted_list = lst\n  local sorted_list_size = #sorted_list\n  for i =\
    \ 1, sorted_list_size do\n    local current_word = sorted_list[i]\n    local current_word_size\
    \ = #current_word\n    for j = i + 1, sorted_list_size do\n      local next_word\
    \ = sorted_list[j]\n      local next_word_size = #next_word\n      if current_word_size\
    \ == next_word_size then\n        sorted_list[j], sorted_list[i] = sorted_list[i],\
    \ sorted_list[j]\n      end\n    end\n  end\n  return sorted_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa',\
    \ 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf',\
    \ 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c',\
    \ 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd',\
    \ 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n\
    \    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa',\
    \ 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc16bi7zw.lua:34:\
    \ expected: {\"aa\"}\nactual: {\"aa\", \"a\", \"aaa\"}\nstack traceback:\n\t/tmp/tmpc16bi7zw.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
