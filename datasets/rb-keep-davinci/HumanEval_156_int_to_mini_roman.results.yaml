name: HumanEval_156_int_to_mini_roman
language: ruby
results:
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = ''\n  roman_numeral << 'm' * (number / 1000)\n  roman_numeral << 'd' * (number\
    \ % 1000 / 500)\n  roman_numeral << 'c' * (number % 500 / 100)\n  roman_numeral\
    \ << 'l' * (number % 100 / 50)\n  roman_numeral << 'x' * (number % 50 / 10)\n\
    \  roman_numeral << 'v' * (number % 10 / 5)\n  roman_numeral << 'i' * (number\
    \ % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmprbeg7txe\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmprbeg7txe.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003133 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    319.18 tests/s, 319.18 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp25nevzbp\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp25nevzbp.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.019896 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    50.26 tests/s, 50.26 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |divisor|\n    quotient, modulus\
    \ = number.divmod(divisor)\n    result << roman_numerals[divisor] * quotient\n\
    \    number = modulus\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmprwp4h8zs\n\
    Started\n.\nFinished in 0.000271 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3690.04 tests/s, 51660.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizxb5wlh\n\
    Started\n.\nFinished in 0.000277 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3610.11 tests/s, 50541.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = \"\"\n  roman_numerals.each do |key, value|\n    while number >= key\n   \
    \   result << value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwpz8l7zy\n\
    Started\n.\nFinished in 0.003804 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    262.88 tests/s, 3680.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  roman_numerals.keys.reverse.each_with_object('')\
    \ do |key, result|\n    while number >= key\n      result << roman_numerals[key]\n\
    \      number -= key\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpya3vma49\n\
    Started\n.\nFinished in 0.000256 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3906.25 tests/s, 54687.50 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpc7yn8te3\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpc7yn8te3.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.00323 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    309.60 tests/s, 309.60 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmph66j6m0k\n\
    Started\n.\nFinished in 0.000241 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4149.38 tests/s, 58091.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1he7_bs9\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1he7_bs9.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.022826 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    43.81 tests/s, 43.81 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_o8fb1gs\n\
    Started\n.\nFinished in 0.000276 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3623.19 tests/s, 50724.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5h67i2ch\n\
    Started\n.\nFinished in 0.000252 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3968.25 tests/s, 55555.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8v6tpam_\n\
    Started\n.\nFinished in 0.000278 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3597.12 tests/s, 50359.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpit5mwi_l\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpit5mwi_l.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003098 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    322.79 tests/s, 322.79 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuyudm0ct\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuyudm0ct.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.011476 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    87.14 tests/s, 87.14 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpsvihr07w\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpsvihr07w.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003181 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    314.37 tests/s, 314.37 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n\
    \      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6mawy1xi\n\
    Started\n.\nFinished in 0.000268 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3731.34 tests/s, 52238.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1bm2im5f\n\
    Started\n.\nFinished in 0.000245 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4081.63 tests/s, 57142.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfapfioyx\n\
    Started\n.\nFinished in 0.000276 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3623.19 tests/s, 50724.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmptch2t8tu\n\
    Started\n.\nFinished in 0.000243 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4115.23 tests/s, 57613.17 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbzws16xm\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbzws16xm.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003157 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    316.76 tests/s, 316.76 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1artx7wi\n\
    Started\n.\nFinished in 0.000259 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3861.00 tests/s, 54054.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6rouaxil\n\
    Started\n.\nFinished in 0.00029 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3448.28 tests/s, 48275.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn4uf0zh_\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn4uf0zh_.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003064 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    326.37 tests/s, 326.37 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object(\"\
    \") do |(arabic, roman), result|\n    while number >= arabic\n      result <<\
    \ roman\n      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate\
    \ = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1uss4ico\n\
    Started\n.\nFinished in 0.000255 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3921.57 tests/s, 54901.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqbm5fwiw\n\
    Started\n.\nFinished in 0.000278 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3597.12 tests/s, 50359.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxzw1s9d4\n\
    Started\n.\nFinished in 0.000238 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4201.68 tests/s, 58823.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1vj283f_\n\
    Started\n.\nFinished in 0.000255 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3921.57 tests/s, 54901.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp67nip7d7\n\
    Started\n.\nFinished in 0.000262 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3816.79 tests/s, 53435.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpg9o9w3iz\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpg9o9w3iz.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003761 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    265.89 tests/s, 265.89 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp822ijlmi\n\
    Started\n.\nFinished in 0.000268 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3731.34 tests/s, 52238.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1a2dlanx\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1a2dlanx.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003398 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    294.29 tests/s, 294.29 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpldresnfc\n\
    Started\n.\nFinished in 0.000271 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3690.04 tests/s, 51660.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpnwfpp985\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpnwfpp985.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.00401 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    249.38 tests/s, 249.38 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1qt7tywf\n\
    Started\n.\nFinished in 0.000267 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3745.32 tests/s, 52434.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3w8rnrnf\n\
    Started\n.\nFinished in 0.000241 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4149.38 tests/s, 58091.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpgjxzygzk\n\
    Started\n.\nFinished in 0.000235 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4255.32 tests/s, 59574.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1fyqdbdt\n\
    Started\n.\nFinished in 0.000253 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3952.57 tests/s, 55335.97 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  roman_numerals.keys.reverse.each_with_object(\"\
    \") do |key, roman|\n    roman << roman_numerals[key] * (number / key)\n    number\
    \ %= key\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphdzzja7s\n\
    Started\n.\nFinished in 0.000291 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3436.43 tests/s, 48109.97 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpua2ioe2c\n\
    Started\n.\nFinished in 0.000247 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4048.58 tests/s, 56680.16 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp588xf6x4\n\
    Started\n.\nFinished in 0.000266 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3759.40 tests/s, 52631.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpgkpzc6y5\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpgkpzc6y5.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003135 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    318.98 tests/s, 318.98 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |k, v|\n    (number / k).times { result << v;\
    \ number -= k }\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0_o3w3ni\n\
    Started\n.\nFinished in 0.000844 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1184.83 tests/s, 16587.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral\
    \ = ''\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number\
    \ / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpkwx6yox4\n\
    Started\n.\nFinished in 0.000288 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3472.22 tests/s, 48611.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpsql0rhdb\n\
    Started\n.\nFinished in 0.000252 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3968.25 tests/s, 55555.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral\
    \ = ''\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number\
    \ / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp37z3l3lm\n\
    Started\n.\nFinished in 0.000268 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3731.34 tests/s, 52238.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpftsv94ws\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpftsv94ws.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.0031 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    322.58 tests/s, 322.58 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6kcnf5ga\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6kcnf5ga.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003376 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    296.21 tests/s, 296.21 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpobl6yzis\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpobl6yzis.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003156 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    316.86 tests/s, 316.86 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n\
    \      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp75p3rm84\n\
    Started\n.\nFinished in 0.000341 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2932.55 tests/s, 41055.72 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfefij1cb\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfefij1cb.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003086 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    324.04 tests/s, 324.04 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8279tyy5\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8279tyy5.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.015886 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    62.95 tests/s, 62.95 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7qlenw2i\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7qlenw2i.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.011728 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    85.27 tests/s, 85.27 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzxc2jsxp\n\
    Started\n.\nFinished in 0.000827 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1209.19 tests/s, 16928.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp9dohjuln\n\
    Started\n.\nFinished in 0.000251 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3984.06 tests/s, 55776.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_mpschep\n\
    Started\n.\nFinished in 0.000606 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1650.17 tests/s, 23102.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpnolahtp4\n\
    Started\n.\nFinished in 0.000288 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3472.22 tests/s, 48611.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbeqen8lj\n\
    Started\n.\nFinished in 0.000246 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4065.04 tests/s, 56910.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number / key > 0\n      return value * (number / key)\
    \ + int_to_mini_roman(number % key)\n    end\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40\n\
    Started\nE\n===============================================================================\n\
    Error: test_int_to_mini_roman(TestHumanEval): TypeError: no implicit conversion\
    \ of Hash into String\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40.rb:26:in\
    \ `+'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40.rb:26:in `block\
    \ in int_to_mini_roman'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40.rb:24:in\
    \ `each'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40.rb:24:in\
    \ `int_to_mini_roman'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40.rb:26:in\
    \ `block in int_to_mini_roman'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40.rb:24:in\
    \ `each'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40.rb:24:in\
    \ `int_to_mini_roman'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40.rb:34:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpii660b40.rb:34:in\
    \ `test_int_to_mini_roman'\n     31: class TestHumanEval < Test::Unit::TestCase\n\
    \     32:   def test_int_to_mini_roman\n     33:     candidate = method(:int_to_mini_roman)\n\
    \  => 34:     assert_equal(\"xix\", candidate.call(19))\n     35:     assert_equal(\"\
    clii\", candidate.call(152))\n     36:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     37:     assert_equal(\"cdxxvi\", candidate.call(426))\n===============================================================================\n\
    \nFinished in 0.000714 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    1400.56 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpawe3cv9f\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpawe3cv9f.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003305 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    302.57 tests/s, 302.57 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = \"\"\n  roman << \"m\" * (number / 1000)\n  roman << \"d\" * (number % 1000\
    \ / 500)\n  roman << \"c\" * (number % 500 / 100)\n  roman << \"l\" * (number\
    \ % 100 / 50)\n  roman << \"x\" * (number % 50 / 10)\n  roman << \"v\" * (number\
    \ % 10 / 5)\n  roman << \"i\" * (number % 5 / 1)\n  roman\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe106lf69\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe106lf69.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003088 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    323.83 tests/s, 323.83 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp06e7e30i\n\
    Started\n.\nFinished in 0.000264 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3787.88 tests/s, 53030.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf7d3z45v\n\
    Started\n.\nFinished in 0.000313 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3194.89 tests/s, 44728.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjqdgi8rd\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjqdgi8rd.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.010378 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    96.36 tests/s, 96.36 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp98oob0fy\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp98oob0fy.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.00363 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    275.48 tests/s, 275.48 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpltif5o52\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpltif5o52.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.00321 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    311.53 tests/s, 311.53 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7iunpffm\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7iunpffm.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003671 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    272.41 tests/s, 272.41 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_string\
    \ = ''\n  roman_numerals.each do |key, value|\n    roman_string << value * (number\
    \ / key)\n    number = number % key\n  end\n  roman_string\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpy16neips\n\
    Started\n.\nFinished in 0.000286 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3496.50 tests/s, 48951.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpd5gco42o\n\
    Started\n.\nFinished in 0.000263 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3802.28 tests/s, 53231.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpniui8gcz\n\
    Started\n.\nFinished in 0.000701 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1426.53 tests/s, 19971.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  output\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ output << value\n      number -= key\n    end\n  end\n  output\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpv1rc9hb9\n\
    Started\n.\nFinished in 0.00029 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3448.28 tests/s, 48275.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpznztapob\n\
    Started\n.\nFinished in 0.00026 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3846.15 tests/s, 53846.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5joo7n_6\n\
    Started\n.\nFinished in 0.000246 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4065.04 tests/s, 56910.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm11o0key\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm11o0key.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003482 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    287.19 tests/s, 287.19 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpgcv2m317\n\
    Started\n.\nFinished in 0.000273 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3663.00 tests/s, 51282.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpks9dsact\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpks9dsact.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.037587 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    26.60 tests/s, 26.60 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp11eu2rqx\n\
    Started\n.\nFinished in 0.000249 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4016.06 tests/s, 56224.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5c_vjbl2\n\
    Started\n.\nFinished in 0.000332 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3012.05 tests/s, 42168.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf29jhnd1\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf29jhnd1.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.012416 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    80.54 tests/s, 80.54 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq_qj4okw\n\
    Started\n.\nFinished in 0.000246 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4065.04 tests/s, 56910.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaxomqf35\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaxomqf35.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.006182 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    161.76 tests/s, 161.76 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5u4uz4f2\n\
    Started\n.\nFinished in 0.000266 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3759.40 tests/s, 52631.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral += \"m\" * (number / 1000)\n  roman_numeral += \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral += \"c\" * (number % 500 / 100)\n \
    \ roman_numeral += \"l\" * (number % 100 / 50)\n  roman_numeral += \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral += \"v\" * (number % 10 / 5)\n  roman_numeral +=\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpo7ojdhcq\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpo7ojdhcq.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003062 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    326.58 tests/s, 326.58 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqqjxojr1\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqqjxojr1.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003165 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    315.96 tests/s, 315.96 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt3uhddzu\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt3uhddzu.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003391 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    294.90 tests/s, 294.90 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx6yvf44u\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx6yvf44u.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.0037 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    270.27 tests/s, 270.27 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpmsma2x__\n\
    Started\n.\nFinished in 0.000284 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3521.13 tests/s, 49295.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral += \"m\" * (number / 1000)\n  roman_numeral += \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral += \"c\" * (number % 500 / 100)\n \
    \ roman_numeral += \"l\" * (number % 100 / 50)\n  roman_numeral += \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral += \"v\" * (number % 10 / 5)\n  roman_numeral +=\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpls1x9ft7\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpls1x9ft7.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.004404 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    227.07 tests/s, 227.07 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpmripftn7\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpmripftn7.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003154 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    317.06 tests/s, 317.06 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfklfpvz8\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfklfpvz8.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003362 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    297.44 tests/s, 297.44 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n\
    \      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp53m2vbrl\n\
    Started\n.\nFinished in 0.000265 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3773.58 tests/s, 52830.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4k7qca_c\n\
    Started\n.\nFinished in 0.000308 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3246.75 tests/s, 45454.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number / key > 0\n      return value * (number / key)\
    \ + int_to_mini_roman(number % key)\n    end\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq\n\
    Started\nE\n===============================================================================\n\
    Error: test_int_to_mini_roman(TestHumanEval): TypeError: no implicit conversion\
    \ of Hash into String\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq.rb:26:in\
    \ `+'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq.rb:26:in `block\
    \ in int_to_mini_roman'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq.rb:24:in\
    \ `each'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq.rb:24:in\
    \ `int_to_mini_roman'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq.rb:26:in\
    \ `block in int_to_mini_roman'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq.rb:24:in\
    \ `each'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq.rb:24:in\
    \ `int_to_mini_roman'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq.rb:34:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxhro0euq.rb:34:in\
    \ `test_int_to_mini_roman'\n     31: class TestHumanEval < Test::Unit::TestCase\n\
    \     32:   def test_int_to_mini_roman\n     33:     candidate = method(:int_to_mini_roman)\n\
    \  => 34:     assert_equal(\"xix\", candidate.call(19))\n     35:     assert_equal(\"\
    clii\", candidate.call(152))\n     36:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     37:     assert_equal(\"cdxxvi\", candidate.call(426))\n===============================================================================\n\
    \nFinished in 0.000692 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    1445.09 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq5opd7rg\n\
    Started\n.\nFinished in 0.00025 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4000.00 tests/s, 56000.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpilq4arpk\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpilq4arpk.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003136 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    318.88 tests/s, 318.88 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpkvgk63v_\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpkvgk63v_.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.009047 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    110.53 tests/s, 110.53 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpeji6x_aq\n\
    Started\n.\nFinished in 0.000278 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3597.12 tests/s, 50359.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4u97ekp8\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4u97ekp8.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003192 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    313.28 tests/s, 313.28 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpehaotq2y\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpehaotq2y.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.011346 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    88.14 tests/s, 88.14 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqwpug79a\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqwpug79a.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.013535 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    73.88 tests/s, 73.88 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpft_6tpdm\n\
    Started\n.\nFinished in 0.000285 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3508.77 tests/s, 49122.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpc61s50qb\n\
    Started\n.\nFinished in 0.000246 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4065.04 tests/s, 56910.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3i1vbzn0\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3i1vbzn0.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003244 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    308.26 tests/s, 308.26 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe92g0v_f\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe92g0v_f.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003444 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    290.36 tests/s, 290.36 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp81o28neg\n\
    Started\n.\nFinished in 0.000264 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3787.88 tests/s, 53030.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = ''\n  roman = roman + 'm' * (number / 1000)\n  roman = roman + 'd' * (number\
    \ % 1000 / 500)\n  roman = roman + 'c' * (number % 500 / 100)\n  roman = roman\
    \ + 'l' * (number % 100 / 50)\n  roman = roman + 'x' * (number % 50 / 10)\n  roman\
    \ = roman + 'v' * (number % 10 / 5)\n  roman = roman + 'i' * (number % 5 / 1)\n\
    \  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaz1h9kvb\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaz1h9kvb.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.009875 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    101.27 tests/s, 101.27 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe7b65jod\n\
    Started\n.\nFinished in 0.000281 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3558.72 tests/s, 49822.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdjl4g1yi\n\
    Started\n.\nFinished in 0.000245 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4081.63 tests/s, 57142.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number / key > 0\n      return value * (number / key)\
    \ + int_to_mini_roman(number % key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwisgrx0e\n\
    Started\n.\nFinished in 0.000309 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3236.25 tests/s, 45307.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_h0av33r\n\
    Started\n.\nFinished in 0.000339 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2949.85 tests/s, 41297.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Write\
    \ your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzvzge7o0\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzvzge7o0.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.016803 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    59.51 tests/s, 59.51 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1dpvcufk\n\
    Started\n.\nFinished in 0.000273 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3663.00 tests/s, 51282.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm68f3ycy\n\
    Started\n.\nFinished in 0.00027 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3703.70 tests/s, 51851.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplh_oo15g\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplh_oo15g.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.007164 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    139.59 tests/s, 139.59 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpgkcrzgf4\n\
    Started\n.\nFinished in 0.000799 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1251.56 tests/s, 17521.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqpk5ir3_\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqpk5ir3_.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.00373 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    268.10 tests/s, 268.10 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpac9ynmoq\n\
    Started\n.\nFinished in 0.000271 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3690.04 tests/s, 51660.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk3jnwl98\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk3jnwl98.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.029796 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    33.56 tests/s, 33.56 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpstpqw62x\n\
    Started\n.\nFinished in 0.000295 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3389.83 tests/s, 47457.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp79mlutko\n\
    Started\n.\nFinished in 0.000318 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3144.65 tests/s, 44025.16 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = ''\n  roman = roman + 'm' * (number / 1000)\n  roman = roman + 'd' * (number\
    \ % 1000 / 500)\n  roman = roman + 'c' * (number % 500 / 100)\n  roman = roman\
    \ + 'l' * (number % 100 / 50)\n  roman = roman + 'x' * (number % 50 / 10)\n  roman\
    \ = roman + 'v' * (number % 10 / 5)\n  roman = roman + 'i' * (number % 5 / 1)\n\
    \  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpncm69kmu\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpncm69kmu.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003957 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    252.72 tests/s, 252.72 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp30q298we\n\
    Started\n.\nFinished in 0.00026 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3846.15 tests/s, 53846.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ roman_numeral << value\n      number -= key\n    end\n  end\n  roman_numeral\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe4npm7fs\n\
    Started\n.\nFinished in 0.000266 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3759.40 tests/s, 52631.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjnd54j6w\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjnd54j6w.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003686 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    271.30 tests/s, 271.30 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp653cskcf\n\
    Started\n.\nFinished in 0.000244 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4098.36 tests/s, 57377.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppq2kgdbz\n\
    Started\n.\nFinished in 0.000272 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3676.47 tests/s, 51470.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7e_tos53\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7e_tos53.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003226 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    309.98 tests/s, 309.98 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp18h3_mzc\n\
    Started\n.\nFinished in 0.000293 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3412.97 tests/s, 47781.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwbakgtiz\n\
    Started\n.\nFinished in 0.00078 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1282.05 tests/s, 17948.72 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp98dh84al\n\
    Started\n.\nFinished in 0.000248 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4032.26 tests/s, 56451.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1coy2oga\n\
    Started\n.\nFinished in 0.000241 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4149.38 tests/s, 58091.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbztpv12k\n\
    Started\n.\nFinished in 0.000258 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3875.97 tests/s, 54263.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1fpwgbhd\n\
    Started\n.\nFinished in 0.000257 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3891.05 tests/s, 54474.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmprl6mz_2o\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmprl6mz_2o.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003399 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    294.20 tests/s, 294.20 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppx6_l1fc\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppx6_l1fc.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.010565 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    94.65 tests/s, 94.65 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numerals = {\n    1000 => \"m\",\n    900 => \"cm\",\n    500\
    \ => \"d\",\n    400 => \"cd\",\n    100 => \"c\",\n    90 => \"xc\",\n    50\
    \ => \"l\",\n    40 => \"xl\",\n    10 => \"x\",\n    9 => \"ix\",\n    5 => \"\
    v\",\n    4 => \"iv\",\n    1 => \"i\"\n  }\n  roman_numerals.each do |key, value|\n\
    \    roman_numeral << value * (number / key)\n    number = number % key\n  end\n\
    \  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp9sthpb3a\n\
    Started\n.\nFinished in 0.000312 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3205.13 tests/s, 44871.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5g9ba1m8\n\
    Started\n.\nFinished in 0.000255 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3921.57 tests/s, 54901.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp76kh5ffc\n\
    Started\n.\nFinished in 0.000296 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3378.38 tests/s, 47297.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8kswr_df\n\
    Started\n.\nFinished in 0.000255 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3921.57 tests/s, 54901.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3tjjhvbq\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3tjjhvbq.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003517 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    284.33 tests/s, 284.33 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp86hs6afn\n\
    Started\n.\nFinished in 0.000255 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3921.57 tests/s, 54901.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = ''\n  roman = roman + 'm' * (number / 1000)\n  roman = roman + 'd' * (number\
    \ % 1000 / 500)\n  roman = roman + 'c' * (number % 500 / 100)\n  roman = roman\
    \ + 'l' * (number % 100 / 50)\n  roman = roman + 'x' * (number % 50 / 10)\n  roman\
    \ = roman + 'v' * (number % 10 / 5)\n  roman = roman + 'i' * (number % 5 / 1)\n\
    \  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmptr_cbd14\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmptr_cbd14.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003065 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    326.26 tests/s, 326.26 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpop2rhpuw\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpop2rhpuw.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003317 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    301.48 tests/s, 301.48 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmploq1hkis\n\
    Started\n.\nFinished in 0.000256 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3906.25 tests/s, 54687.50 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppgn40x37\n\
    Started\n.\nFinished in 0.000275 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3636.36 tests/s, 50909.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = ''\n  roman << 'm' * (number / 1000)\n  roman << 'd' * (number % 1000 / 500)\n\
    \  roman << 'c' * (number % 500 / 100)\n  roman << 'l' * (number % 100 / 50)\n\
    \  roman << 'x' * (number % 50 / 10)\n  roman << 'v' * (number % 10 / 5)\n  roman\
    \ << 'i' * (number % 5 / 1)\n  roman\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpkcvoohwr\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpkcvoohwr.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003215 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    311.04 tests/s, 311.04 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0_j4ures\n\
    Started\n.\nFinished in 0.000238 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4201.68 tests/s, 58823.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp25qk02af\n\
    Started\n.\nFinished in 0.000262 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3816.79 tests/s, 53435.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp9eb9qzhv\n\
    Started\n.\nFinished in 0.00027 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3703.70 tests/s, 51851.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |k, v|\n    result << v * (number / k)\n    number\
    \ = number % k\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjo8knerf\n\
    Started\n.\nFinished in 0.000264 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3787.88 tests/s, 53030.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphh_ffgjy\n\
    Started\n.\nFinished in 0.000277 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3610.11 tests/s, 50541.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb1xn1ra3\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb1xn1ra3.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.011775 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    84.93 tests/s, 84.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp38rqe7zo\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp38rqe7zo.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003475 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    287.77 tests/s, 287.77 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2se0qg_a\n\
    Started\n.\nFinished in 0.000244 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4098.36 tests/s, 57377.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppv283_zl\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppv283_zl.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003064 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    326.37 tests/s, 326.37 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpij0hs8cc\n\
    Started\n.\nFinished in 0.000266 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3759.40 tests/s, 52631.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6aiaa5ad\n\
    Started\n.\nFinished in 0.000254 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3937.01 tests/s, 55118.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa5enjufe\n\
    Started\n.\nFinished in 0.00026 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3846.15 tests/s, 53846.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzmed2k2e\n\
    Started\n.\nFinished in 0.000269 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3717.47 tests/s, 52044.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral\
    \ = ''\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number\
    \ / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpenobv1ms\n\
    Started\n.\nFinished in 0.00027 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3703.70 tests/s, 51851.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3i3xkhnk\n\
    Started\n.\nFinished in 0.000359 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2785.52 tests/s, 38997.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmps89pb4gr\n\
    Started\n.\nFinished in 0.000344 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2906.98 tests/s, 40697.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numerals = {\n    1000 => \"m\",\n    900 => \"cm\",\n    500\
    \ => \"d\",\n    400 => \"cd\",\n    100 => \"c\",\n    90 => \"xc\",\n    50\
    \ => \"l\",\n    40 => \"xl\",\n    10 => \"x\",\n    9 => \"ix\",\n    5 => \"\
    v\",\n    4 => \"iv\",\n    1 => \"i\"\n  }\n  roman_numerals.each do |key, value|\n\
    \    roman_numeral << value * (number / key)\n    number = number % key\n  end\n\
    \  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbn16retz\n\
    Started\n.\nFinished in 0.00026 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3846.15 tests/s, 53846.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjc3u28om\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjc3u28om.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003645 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    274.35 tests/s, 274.35 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn9w2eq44\n\
    Started\n.\nFinished in 0.00029 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3448.28 tests/s, 48275.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_junudyn\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_junudyn.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.007688 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    130.07 tests/s, 130.07 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  return\
    \ '' if number == 0\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n\
    \    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 =>\
    \ 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4\
    \ => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |k, v|\n    return v +\
    \ int_to_mini_roman(number - k) if number >= k\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3k2ogxck\n\
    Started\n.\nFinished in 0.000276 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3623.19 tests/s, 50724.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpifqk6mc3\n\
    Started\n.\nFinished in 0.000328 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3048.78 tests/s, 42682.93 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt3m92vqa\n\
    Started\n.\nFinished in 0.000241 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4149.38 tests/s, 58091.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this function\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp457y_lp8\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp457y_lp8.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003105 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    322.06 tests/s, 322.06 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5uwk4r26\n\
    Started\n.\nFinished in 0.000281 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3558.72 tests/s, 49822.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqrne6220\n\
    Started\n.\nFinished in 0.000273 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3663.00 tests/s, 51282.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n\
    \      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjbzs67kb\n\
    Started\n.\nFinished in 0.000244 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4098.36 tests/s, 57377.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpkl0iv8gp\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpkl0iv8gp.rb:23:in\
    \ `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n\
    \  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"\
    clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n?  + ?\n===============================================================================\n\
    \nFinished in 0.003127 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    319.80 tests/s, 319.80 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmprj3rfmgn\n\
    Started\n.\nFinished in 0.000274 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3649.64 tests/s, 51094.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp93ns9pa6\n\
    Started\n.\nFinished in 0.000252 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3968.25 tests/s, 55555.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz72r1n1x\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz72r1n1x.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003114 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    321.13 tests/s, 321.13 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numerals = {\n    1000 => \"m\",\n    900 => \"cm\",\n    500\
    \ => \"d\",\n    400 => \"cd\",\n    100 => \"c\",\n    90 => \"xc\",\n    50\
    \ => \"l\",\n    40 => \"xl\",\n    10 => \"x\",\n    9 => \"ix\",\n    5 => \"\
    v\",\n    4 => \"iv\",\n    1 => \"i\"\n  }\n  roman_numerals.each do |key, value|\n\
    \    while number >= key\n      roman_numeral << value\n      number -= key\n\
    \    end\n  end\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpmtbw5eyf\n\
    Started\n.\nFinished in 0.000241 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4149.38 tests/s, 58091.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_xqeva5v\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_xqeva5v.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003125 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    320.00 tests/s, 320.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpevklrp8i\n\
    Started\n.\nFinished in 0.000741 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1349.53 tests/s, 18893.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpva2ly0ud\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpva2ly0ud.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.00696 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    143.68 tests/s, 143.68 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpybm_869i\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpybm_869i.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.006566 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    152.30 tests/s, 152.30 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf9slaovg\n\
    Started\n.\nFinished in 0.00026 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3846.15 tests/s, 53846.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpskq8v3kw\n\
    Started\n.\nFinished in 0.000259 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3861.00 tests/s, 54054.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqnzsdknl\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqnzsdknl.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.024717 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    40.46 tests/s, 40.46 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2cxtd2ga\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2cxtd2ga.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003445 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    290.28 tests/s, 290.28 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw2g41ao7\n\
    Started\n.\nFinished in 0.004349 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    229.94 tests/s, 3219.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3tc2m4ct\n\
    Started\n.\nFinished in 0.000249 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4016.06 tests/s, 56224.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpicaf3tw1\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpicaf3tw1.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.00349 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    286.53 tests/s, 286.53 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp29p44q4t\n\
    Started\n.\nFinished in 0.00025 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4000.00 tests/s, 56000.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpj6a0fcn0\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpj6a0fcn0.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003399 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    294.20 tests/s, 294.20 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement the method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_4ef16wu\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_4ef16wu.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.005786 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    172.83 tests/s, 172.83 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    'M' => 1000,\n    'CM' => 900,\n    'D' => 500,\n    'CD' => 400,\n\
    \    'C' => 100,\n    'XC' => 90,\n    'L' => 50,\n    'XL' => 40,\n    'X' =>\
    \ 10,\n    'IX' => 9,\n    'V' => 5,\n    'IV' => 4,\n    'I' => 1\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= value\n      return key + int_to_mini_roman(number\
    \ - value)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa6cpx7pr\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa6cpx7pr.rb:35:in\
    \ `test_int_to_mini_roman'\n     32: class TestHumanEval < Test::Unit::TestCase\n\
    \     33:   def test_int_to_mini_roman\n     34:     candidate = method(:int_to_mini_roman)\n\
    \  => 35:     assert_equal(\"xix\", candidate.call(19))\n     36:     assert_equal(\"\
    clii\", candidate.call(152))\n     37:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     38:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<\"XIX\">\n===============================================================================\n\
    \nFinished in 0.002978 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    335.80 tests/s, 335.80 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp947tstlm\n\
    Started\n.\nFinished in 0.000234 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4273.50 tests/s, 59829.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp53_uu_ai\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp53_uu_ai.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.004037 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    247.71 tests/s, 247.71 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm5dnwq6v\n\
    Started\n.\nFinished in 0.000265 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3773.58 tests/s, 52830.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq6it_21o\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq6it_21o.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.002943 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    339.79 tests/s, 339.79 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuy_qeatl\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuy_qeatl.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003102 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    322.37 tests/s, 322.37 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1crauamo\n\
    Started\n.\nFinished in 0.00026 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3846.15 tests/s, 53846.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfera5p_l\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfera5p_l.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003043 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    328.62 tests/s, 328.62 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbxxp2gi0\n\
    Started\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbxxp2gi0.rb:15:in\
    \ `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n\
    \     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n\
    \  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"\
    clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n\
    \     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected\
    \ but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n? ??  ?? \n===============================================================================\n\
    \nFinished in 0.003173 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    315.16 tests/s, 315.16 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
