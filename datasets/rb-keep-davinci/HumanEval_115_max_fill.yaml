name: HumanEval_115_max_fill
language: ruby
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# Input: \n# grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n# bucket_capacity :\
  \ 1\n# Output: 6\n# Example 2:\n# Input: \n# grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]]\n# bucket_capacity : 2\n# Output: 5\n# Example 3:\n# Input: \n# grid\
  \ : [[0,0,0], [0,0,0]]\n# bucket_capacity : 5\n# Output: 0\n# Constraints:\n# *\
  \ all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
  \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid,\
  \ capacity)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n\
  \    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0,\
  \ candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], 9))\n  end\nend\n"
completions: ["  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  return 0 if grid.empty?\n  return 0 if grid[0].empty?\n\
    \  return 0 if capacity <= 0\n  #puts \"grid=#{grid.inspect}, capacity=#{capacity}\"\
    \n  #puts \"grid.size=#{grid.size}, grid[0].size=#{grid[0].size}\"\n  max_fill\
    \ = 0\n  (0...grid.size).each do |i|\n    (0...grid[0].size).each do |j|\n   \
    \   max_fill = [max_fill, grid[i][j]].max\n    end\n  end\n  #puts \"max_fill=#{max_fill}\"\
    \n  return 0 if max_fill == 0\n  return max_fill if capacity >= max_fill\n  #puts\
    \ \"capacity=#{capacity}\"\n  (1..max_fill).each do |fill|\n    #puts \"fill=#{fill}\"\
    \n    (0...grid.size).each do |i|\n      (0...grid[0].size).each do |j|\n    \
    \    #puts \"i=#{i}, j=#{j}\"\n        if grid[i][j] >= fill\n          grid[i][j]\
    \ -= fill\n          #puts \"grid[#{i}][#{j}] = #{grid[i][j]}\"\n        end\n\
    \      end\n    end\n  end\n  #puts \"grid=#{grid.inspect}\"\n  max_fill(grid,\
    \ capacity)\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.reduce(0)\
    \ { |sum, x| sum + x } if row.reduce(0) { |sum, x| sum + x } > max_fill\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n  return\
    \ 0 if grid.first.empty?\n  return 0 if capacity <= 0\n  #puts \"grid=#{grid.inspect},\
    \ capacity=#{capacity}\"\n  rows = grid.size\n  cols = grid.first.size\n  #puts\
    \ \"rows=#{rows}, cols=#{cols}\"\n  max_fill = 0\n  (0...rows).each do |row|\n\
    \    (0...cols).each do |col|\n      if grid[row][col] == 1\n        #puts \"\
    row=#{row}, col=#{col}\"\n        fill = fill_from_well(grid, row, col, capacity)\n\
    \        #puts \"fill=#{fill}\"\n        max_fill = fill if fill > max_fill\n\
    \      end\n    end\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  # fill each well with the bucket\n\
    \  # return the number of times we had to lower the bucket\n  # we can lower the\
    \ bucket as many times as the number of wells\n  # we can lower the bucket as\
    \ many times as the number of wells\n  # we can lower the bucket as many times\
    \ as the number of wells\n  # we can lower the bucket as many times as the number\
    \ of wells\n  # we can lower the bucket as many times as the number of wells\n\
    \  # we can lower the bucket as many times as the number of wells\n  # we can\
    \ lower the bucket as many times as the number of wells\n  # we can lower the\
    \ bucket as many times as the number of wells\n  # we can lower the bucket as\
    \ many times as the number of wells\n  # we can lower the bucket as many times\
    \ as the number of wells\n  # we can lower the bucket as many times as the number\
    \ of wells\n  # we can lower the bucket as many times as the number of wells\n\
    \  # we can lower the bucket as many times as the number of wells\n  # we can\
    \ lower the bucket as many times as the number of wells\n  # we can lower the\
    \ bucket as many times as the number of wells\n  # we can lower the bucket as\
    \ many times as the number of wells\n  # we can lower the bucket as many times\
    \ as the number of wells\n  # we can lower the bucket as many times as the number\
    \ of wells\n  # we can lower the bucket as many times as the number of wells\n\
    \  # we can lower the bucket as many times as the number of wells\n  # we can\
    \ lower the bucket as many times as the number of wells\n  # we can lower the\
    \ bucket as many times as the number of wells\n  # we can lower the bucket as\
    \ many times as the number of wells\n  # we can lower the bucket as many times\
    \ as the number of wells\n  # we can lower the bucket as many times as the number\
    \ of wells\n  # we can lower the bucket as many times as the number of wells\n\
    \  # we can lower the bucket as many times as the number of wells\n  # we can\
    \ lower the bucket as many times as the number of wells\n  # we can lower the\
    \ bucket as many times as the number of wells\n  # we can lower the bucket as\
    \ many times as the number of wells\n  # we can lower the bucket as", "  max_fill\
    \ = 0\n  grid.each do |row|\n    row.each do |well|\n      max_fill = [max_fill,\
    \ well].max\n    end\n  end\n  max_fill = [max_fill, capacity].min\n  return max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n\
    \  return 0 if grid[0].empty?\n  rows = grid.size\n  cols = grid[0].size\n  max_fill\
    \ = 0\n  (0...rows).each do |i|\n    (0...cols).each do |j|\n      max_fill =\
    \ [max_fill, grid[i][j]].max\n    end\n  end\n  max_fill\nend", "  max_fill =\
    \ 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill > capacity ? capacity : max_fill\nend", "  # find the max height\
    \ of the grid\n  max_height = 0\n  grid.each do |row|\n    max_height = [max_height,\
    \ row.max].max\n  end\n  # fill the grid from the top down\n  # each row is filled\
    \ to the max height\n  # if the row is already filled to the max height,\n  #\
    \ then it is skipped\n  # the number of times the bucket is lowered is the number\
    \ of rows\n  # that are filled\n  num_times_lowered = 0\n  max_height.times do\
    \ |height|\n    grid.each do |row|\n      if row.max >= height + 1\n        num_times_lowered\
    \ += 1\n      end\n    end\n  end\n  num_times_lowered\nend", "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\n\
    end", "  # find the max fill for each row\n  # then find the max fill for the\
    \ whole grid\n  # then find the number of times we need to fill the buckets\n\
    \  # to fill the grid\n  #\n  # max_fill(grid, capacity) = max(max_fill(row, capacity))\n\
    \  #\n  # max_fill(row, capacity) = max(max_fill(row[0..i], capacity), max_fill(row[i+1..-1],\
    \ capacity))\n  #\n  # max_fill(row, capacity) = max(max_fill(row[0..i], capacity),\
    \ max_fill(row[i+1..-1], capacity))\n  #\n  # max_fill(row, capacity) = max(max_fill(row[0..i],\
    \ capacity), max_fill(row[i+1..-1], capacity))\n  #\n  # max_fill(row, capacity)\
    \ = max(max_fill(row[0..i], capacity), max_fill(row[i+1..-1], capacity))\n  #\n\
    \  # max_fill(row, capacity) = max(max_fill(row[0..i], capacity), max_fill(row[i+1..-1],\
    \ capacity))\n  #\n  # max_fill(row, capacity) = max(max_fill(row[0..i], capacity),\
    \ max_fill(row[i+1..-1], capacity))\n  #\n  # max_fill(row, capacity) = max(max_fill(row[0..i],\
    \ capacity), max_fill(row[i+1..-1], capacity))\n  #\n  # max_fill(row, capacity)\
    \ = max(max_fill(row[0..i], capacity), max_fill(row[i+1..-1], capacity))\n  #\n\
    \  # max_fill(row, capacity) = max(max_fill(row[0..i], capacity), max_fill(row[i+1..-1],\
    \ capacity))\n  #\n  # max_fill(row, capacity) = max(max_fill(row[0..i], capacity),\
    \ max_fill(row[i+1..-1], capacity))\n  #", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill > capacity\
    \ ? capacity : max_fill\nend", "  return 0 if grid.empty?\n  return 0 if grid.all?\
    \ { |row| row.all? { |cell| cell == 0 } }\n  max_fill_helper(grid, capacity, 0,\
    \ 0)\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1)\
    \ if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  # find the max fill\
    \ for each row\n  # then find the max of those\n  # then find the max of that\
    \ and the capacity\n  # then find the max of that and the sum of the row\n  #\
    \ then find the max of that and the sum of the row\n  # then find the max of that\
    \ and the sum of the row\n  # then find the max of that and the sum of the row\n\
    \  # then find the max of that and the sum of the row\n  # then find the max of\
    \ that and the sum of the row\n  # then find the max of that and the sum of the\
    \ row\n  # then find the max of that and the sum of the row\n  # then find the\
    \ max of that and the sum of the row\n  # then find the max of that and the sum\
    \ of the row\n  # then find the max of that and the sum of the row\n  # then find\
    \ the max of that and the sum of the row\n  # then find the max of that and the\
    \ sum of the row\n  # then find the max of that and the sum of the row\n  # then\
    \ find the max of that and the sum of the row\n  # then find the max of that and\
    \ the sum of the row\n  # then find the max of that and the sum of the row\n \
    \ # then find the max of that and the sum of the row\n  # then find the max of\
    \ that and the sum of the row\n  # then find the max of that and the sum of the\
    \ row\n  # then find the max of that and the sum of the row\n  # then find the\
    \ max of that and the sum of the row\n  # then find the max of that and the sum\
    \ of the row\n  # then find the max of that and the sum of the row\n  # then find\
    \ the max of that and the sum of the row\n  # then find the max of that and the\
    \ sum of the row\n  # then find the max of that and the sum of the row\n  # then\
    \ find the max of that and the sum of the row\n  # then find the max of that and\
    \ the sum of the row\n  # then find the max of that and the sum of the row\n \
    \ # then find the max of that and the sum of the row\n  # then find the max of\
    \ that and the sum of the row\n", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    row.each do |cell|\n\
    \      max_fill += cell\n    end\n  end\n  max_fill / capacity\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.max if row.max > max_fill\n  end\n  max_fill\nend", "  # fill the first\
    \ row\n  fill = 0\n  grid[0].each do |well|\n    fill += 1 if well == 1\n  end\n\
    \  # fill the rest of the rows\n  (1...grid.length).each do |row|\n    grid[row].each_with_index\
    \ do |well, col|\n      if well == 1\n        if grid[row - 1][col] == 1\n   \
    \       # fill from the previous row\n          grid[row - 1][col] = 0\n     \
    \   else\n          # fill from the bucket\n          fill += 1\n        end\n\
    \      end\n    end\n  end\n  fill\nend", "  grid.map { |row| row.reduce(:+) /\
    \ capacity }.reduce(:+)\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill > capacity ? capacity : max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\n\
    end", "  # find the max height of the grid\n  max_height = 0\n  grid.each do |row|\n\
    \    max_height = [max_height, row.max].max\n  end\n  # fill the grid from the\
    \ max height down to 0\n  count = 0\n  (max_height).downto(0) do |height|\n  \
    \  grid.each do |row|\n      row.each do |cell|\n        if cell >= height\n \
    \         count += 1\n        end\n      end\n    end\n  end\n  count\nend", " \
    \ return 0 if grid.empty?\n  return 0 if grid.all? { |row| row.all? { |cell| cell\
    \ == 0 } }\n  max_fill_helper(grid, capacity, 0, 0)\nend", "  # find max row\n\
    \  max_row = grid.max_by(&:sum)\n  # find max column\n  max_col = grid.transpose.max_by(&:sum)\n\
    \  # find max row index\n  max_row_index = grid.index(max_row)\n  # find max column\
    \ index\n  max_col_index = grid.transpose.index(max_col)\n  # find max row sum\n\
    \  max_row_sum = max_row.sum\n  # find max column sum\n  max_col_sum = max_col.sum\n\
    \  # find max sum\n  max_sum = [max_row_sum, max_col_sum].max\n  # find max sum\
    \ index\n  max_sum_index = [max_row_index, max_col_index].max\n  # find max sum\
    \ count\n  max_sum_count = max_sum / capacity\n  # find max sum remainder\n  max_sum_remainder\
    \ = max_sum % capacity\n  # find max sum remainder count\n  max_sum_remainder_count\
    \ = max_sum_remainder > 0 ? 1 : 0\n  # find max sum count\n  max_sum_count + max_sum_remainder_count\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  grid.map { |row|\
    \ row.sum }.max / capacity\nend", "  return 0 if grid.empty?\n  return 0 if grid[0].empty?\n\
    \  #puts \"grid: #{grid}\"\n  #puts \"capacity: #{capacity}\"\n  #puts \"grid.length:\
    \ #{grid.length}\"\n  #puts \"grid[0].length: #{grid[0].length}\"\n  #puts \"\
    grid.max: #{grid.max}\"\n  #puts \"grid.max.max: #{grid.max.max}\"\n  #puts \"\
    grid.max.max.max: #{grid.max.max.max}\"\n  #puts \"grid.max.max.max.max: #{grid.max.max.max.max}\"\
    \n  #puts \"grid.max.max.max.max.max: #{grid.max.max.max.max.max}\"\n  #puts \"\
    grid.max.max.max.max.max.max: #{grid.max.max.max.max.max.max}\"\n  #puts \"grid.max.max.max.max.max.max.max:\
    \ #{grid.max.max.max.max.max.max.max}\"\n  #puts \"grid.max.max.max.max.max.max.max.max:\
    \ #{grid.max.max.max.max.max.max.max.max}\"\n  #puts \"grid.max.max.max.max.max.max.max.max.max:\
    \ #{grid.max.max.max.max.max.max.max.max.max}\"\n  #puts \"grid.max.max.max.max.max.max.max.max.max.max:\
    \ #{grid.max.max.max.max.max.max.max.max.max.max}\"\n  #puts \"grid.max.max.max.max.max.max.max.max.max.max.max:\
    \ #{grid.max.max.max.max.max.max.max.max.max.max.max}\"\n  #puts \"grid.max.max.max.max.max.max.max.max.max.max.max.max:\
    \ #{grid.", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.reduce(:+)\
    \ if row.reduce(:+) > max_fill\n  end\n  max_fill\nend", "  # fill each well to\
    \ capacity\n  # return the number of times we had to fill\n  # fill each well\
    \ to capacity\n  # return the number of times we had to fill\n  grid.map { |row|\
    \ row.map { |well| well == 0 ? 0 : capacity } }\nend", "  # return 0 if grid.empty?\n\
    \  # return 0 if grid.all? { |row| row.all? { |cell| cell == 0 } }\n  # return\
    \ 0 if grid.all? { |row| row.all? { |cell| cell == 1 } }\n  # return 0 if capacity\
    \ == 0\n  # return 0 if capacity == 1 && grid.all? { |row| row.all? { |cell| cell\
    \ == 1 } }\n  # return 0 if capacity == 1 && grid.all? { |row| row.all? { |cell|\
    \ cell == 0 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any? {\
    \ |cell| cell == 1 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 0 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 1 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 0 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 1 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 0 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 1 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 0 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 1 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 0 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 1 } }\n  # return 0 if capacity == 1 && grid.any? { |row| row.any?\
    \ { |cell| cell == 0 } }\n  # return 0", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.reduce(:+) if row.reduce(:+) > max_fill\n  end\n  max_fill\nend", "  #\n\
    \  # Fill the grid from the bottom up.\n  #\n  # The idea is to fill the bottom\
    \ row first, then the second row from the bottom, etc.\n  #\n  # The number of\
    \ buckets needed to fill a row is the number of wells that need to be filled,\n\
    \  # divided by the capacity of the bucket.\n  #\n  # If the number of wells that\
    \ need to be filled is not a multiple of the bucket capacity,\n  # then we need\
    \ to add one more bucket.\n  #\n  # The number of buckets needed to fill a row\
    \ is the maximum of the number of buckets needed\n  # to fill the row above it,\
    \ and the number of buckets needed to fill the row itself.\n  #\n  # The number\
    \ of buckets needed to fill the entire grid is the number of buckets needed to\
    \ fill\n  # the top row.\n  #\n  # Time complexity: O(n*m)\n  # Space complexity:\
    \ O(n)\n  #\n  n = grid.size\n  m = grid[0].size\n  buckets = Array.new(n, 0)\n\
    \  (n-1).downto(0) do |i|\n    wells = grid[i].reduce(:+)\n    buckets[i] = [buckets[i+1],\
    \ (wells + capacity - 1) / capacity].max\n  end\n  buckets[0]\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  # fill the buckets\n  # lower the buckets\n  # repeat until\
    \ all wells are empty\n  # return the number of times the buckets were lowered\n\
    \  #\n  # fill the buckets\n  # lower the buckets\n  # repeat until all wells\
    \ are empty\n  # return the number of times the buckets were lowered\n  #\n  #\
    \ fill the buckets\n  # lower the buckets\n  # repeat until all wells are empty\n\
    \  # return the number of times the buckets were lowered\n  #\n  # fill the buckets\n\
    \  # lower the buckets\n  # repeat until all wells are empty\n  # return the number\
    \ of times the buckets were lowered\n  #\n  # fill the buckets\n  # lower the\
    \ buckets\n  # repeat until all wells are empty\n  # return the number of times\
    \ the buckets were lowered\n  #\n  # fill the buckets\n  # lower the buckets\n\
    \  # repeat until all wells are empty\n  # return the number of times the buckets\
    \ were lowered\n  #\n  # fill the buckets\n  # lower the buckets\n  # repeat until\
    \ all wells are empty\n  # return the number of times the buckets were lowered\n\
    \  #\n  # fill the buckets\n  # lower the buckets\n  # repeat until all wells\
    \ are empty\n  # return the number of times the buckets were lowered\n  #\n  #\
    \ fill the buckets\n  # lower the buckets\n  # repeat until all wells are empty\n\
    \  # return the number of times the buckets were lowered\n  #\n  # fill the buckets\n\
    \  # lower the buckets\n  # repeat until all wells are empty\n  # return the number\
    \ of times the buckets were lowered\n  #\n  # fill the buckets\n  # lower the\
    \ buckets\n  # repeat until all wells are empty\n  # return the number of times\
    \ the buckets were lowered\n  #\n  # fill the buckets\n  # lower the buckets\n\
    \  # repeat until all wells are empty\n  # return the number of times the buckets\
    \ were lowered\n  #\n  # fill the buckets\n  # lower the buckets\n  # repeat until\
    \ all wells are empty\n  # return the number of times the buckets were lowered\n\
    \  #\n  # fill the buckets\n  # lower the buckets\n  # repeat until all wells\
    \ are empty\n  # return the number of times the buckets were lowered\n  #\n  #\
    \ fill the buckets\n ", "  max_fill = 0\n  grid.each do |row|\n    row.each do\
    \ |cell|\n      max_fill = [max_fill, cell].max\n    end\n  end\n  max_fill =\
    \ [max_fill, capacity].min\n  max_fill\nend", "  return 0 if grid.empty?\n  return\
    \ 0 if grid.first.empty?\n  return 0 if capacity <= 0\n  #puts \"grid=#{grid.inspect},\
    \ capacity=#{capacity}\"\n  max_fill_helper(grid, capacity, 0, 0)\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill > capacity ? capacity : max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.max if row.max > max_fill\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    row.each do |col|\n      max_fill = col if col\
    \ > max_fill\n    end\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  return 0 if grid.empty?\n  rows = grid.length\n  cols = grid[0].length\n  max_fill_count\
    \ = 0\n  (0...rows).each do |row|\n    (0...cols).each do |col|\n      max_fill_count\
    \ += grid[row][col] / capacity\n      grid[row][col] %= capacity\n    end\n  end\n\
    \  max_fill_count\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill =\
    \ [max_fill, row.sum].max\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n\
    \  rows = grid.length\n  cols = grid[0].length\n  max_fill = 0\n  (0...rows).each\
    \ do |i|\n    (0...cols).each do |j|\n      max_fill = [max_fill, grid[i][j]].max\n\
    \    end\n  end\n  max_fill\nend", "  # return 0 if grid.empty?\n  # return 0\
    \ if grid.all? { |row| row.all? { |well| well == 0 } }\n  # return 0 if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ { |row| row.all? { |well| well == 1 } }\n  # return grid.length if grid.all?\
    \ {", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend", "  # Fill\
    \ the buckets with the maximum amount of water possible.\n  # Return the number\
    \ of times the buckets were lowered.\n  # Fill the buckets with the maximum amount\
    \ of water possible.\n  # Return the number of times the buckets were lowered.\n\
    \  # Fill the buckets with the maximum amount of water possible.\n  # Return the\
    \ number of times the buckets were lowered.\n  # Fill the buckets with the maximum\
    \ amount of water possible.\n  # Return the number of times the buckets were lowered.\n\
    \  # Fill the buckets with the maximum amount of water possible.\n  # Return the\
    \ number of times the buckets were lowered.\n  # Fill the buckets with the maximum\
    \ amount of water possible.\n  # Return the number of times the buckets were lowered.\n\
    \  # Fill the buckets with the maximum amount of water possible.\n  # Return the\
    \ number of times the buckets were lowered.\n  # Fill the buckets with the maximum\
    \ amount of water possible.\n  # Return the number of times the buckets were lowered.\n\
    \  # Fill the buckets with the maximum amount of water possible.\n  # Return the\
    \ number of times the buckets were lowered.\n  # Fill the buckets with the maximum\
    \ amount of water possible.\n  # Return the number of times the buckets were lowered.\n\
    \  # Fill the buckets with the maximum amount of water possible.\n  # Return the\
    \ number of times the buckets were lowered.\n  # Fill the buckets with the maximum\
    \ amount of water possible.\n  # Return the number of times the buckets were lowered.\n\
    \  # Fill the buckets with the maximum amount of water possible.\n  # Return the\
    \ number of times the buckets were lowered.\n  # Fill the buckets with the maximum\
    \ amount of water possible.\n  # Return the number of times the buckets were lowered.\n\
    \  # Fill the buckets with the maximum amount of water possible.\n  # Return the\
    \ number of times the buckets were lowered.\n  # Fill the buckets with the maximum\
    \ amount of water possible.\n  # Return the number of times the buckets were lowered.\n\
    \  # Fill the buckets with the maximum amount of water possible.\n  # Return the\
    \ number of times the buckets were lowered.\n  # Fill the buckets with the maximum\
    \ amount of water possible.\n  # Return the number of times the buckets were lowered.\n\
    \  # Fill the buckets with the maximum amount of water possible.\n  # Return the\
    \ number of times the buckets were lowered", "  return 0 if grid.empty?\n  rows\
    \ = grid.size\n  cols = grid[0].size\n  return 0 if rows == 0 || cols == 0\n \
    \ # dp[i][j] = max_fill(grid[i][j..-1])\n  dp = Array.new(rows) { Array.new(cols,\
    \ 0) }\n  # dp[i][-1] = grid[i][-1]\n  (0...rows).each { |i| dp[i][-1] = grid[i][-1]\
    \ }\n  # dp[i][j] = max(dp[i][j+1], dp[i-1][j+1], dp[i+1][j+1]) + grid[i][j]\n\
    \  (0...cols-1).each do |j|\n    (0...rows).each do |i|\n      dp[i][j] = [dp[i][j+1],\
    \ dp[i-1][j+1], dp[i+1][j+1]].max + grid[i][j]\n    end\n  end\n  # dp[i][0] =\
    \ dp[i][0] / capacity\n  (0...rows).each { |i| dp[i][0] = dp[i][0] / capacity\
    \ }\n  # max(dp[i][0])\n  dp.map { |row| row[0] }.max\nend\ngrid = [[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]]\ncapacity = 1\nputs max_fill(grid, capacity)\ngrid = [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\ncapacity = 2\nputs max_fill(grid, capacity)\n\
    grid = [[0,0,0], [0,0,0]]\ncapacity = 5\nputs max_fill(grid, capacity)", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.reduce(:+)].max\n  end\n  max_fill\nend", "  grid.map { |row| row.map {\
    \ |well| well / capacity }.sum }.max\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  return\
    \ 0 if grid.empty?\n  return 0 if grid[0].empty?\n  m, n = grid.size, grid[0].size\n\
    \  return 0 if m == 0 || n == 0\n  # dp[i][j] = max_fill(grid[0..i][0..j])\n \
    \ dp = Array.new(m) { Array.new(n, 0) }\n  dp[0][0] = grid[0][0]\n  (1...n).each\
    \ { |j| dp[0][j] = dp[0][j - 1] + grid[0][j] }\n  (1...m).each { |i| dp[i][0]\
    \ = dp[i - 1][0] + grid[i][0] }\n  (1...m).each do |i|\n    (1...n).each do |j|\n\
    \      dp[i][j] = [dp[i - 1][j], dp[i][j - 1]].max + grid[i][j]\n    end\n  end\n\
    \  # puts \"dp = #{dp}\"\n  dp[m - 1][n - 1] / capacity\nend", "  # Fill each\
    \ well with water\n  grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      if col == 1\n        grid[i][j] = capacity\n      end\n \
    \   end\n  end\n  # Fill each well with water from the previous well\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      if col > 0 && i > 0\n\
    \        grid[i][j] = grid[i-1][j] - 1\n      end\n    end\n  end\n  # Fill each\
    \ well with water from the next well\n  grid.each_with_index do |row, i|\n   \
    \ row.each_with_index do |col, j|\n      if col > 0 && j < row.length - 1\n  \
    \      grid[i][j] = [grid[i][j], grid[i][j+1] - 1].min\n      end\n    end\n \
    \ end\n  # Fill each well with water from the previous well\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      if col > 0 && i < grid.length\
    \ - 1\n        grid[i][j] = [grid[i][j], grid[i+1][j] - 1].min\n      end\n  \
    \  end\n  end\n  # Fill each well with water from the next well\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      if col > 0 && j > 0\n\
    \        grid[i][j] = [grid[i][j], grid[i][j-1] - 1].min\n      end\n    end\n\
    \  end\n  # Count the number of times the bucket was lowered\n  count = 0\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      if col > 0\n       \
    \ count += 1\n      end\n    end\n  end\n  count\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill += row.count(1)\n  end\n  max_fill / capacity\nend",
  "  max_fill = 0\n  grid.each do |row|\n    row.each do |cell|\n      max_fill =\
    \ cell if cell > max_fill\n    end\n  end\n  max_fill = capacity if max_fill >\
    \ capacity\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  # fill each well\
    \ to capacity\n  # return the number of times we had to fill a well\n  #\n  #\
    \ fill each well to capacity\n  # return the number of times we had to fill a\
    \ well\n  #\n  # fill each well to capacity\n  # return the number of times we\
    \ had to fill a well\n  #\n  # fill each well to capacity\n  # return the number\
    \ of times we had to fill a well\n  #\n  # fill each well to capacity\n  # return\
    \ the number of times we had to fill a well\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill a well\n  #\n  # fill each well\
    \ to capacity\n  # return the number of times we had to fill a well\n  #\n  #\
    \ fill each well to capacity\n  # return the number of times we had to fill a\
    \ well\n  #\n  # fill each well to capacity\n  # return the number of times we\
    \ had to fill a well\n  #\n  # fill each well to capacity\n  # return the number\
    \ of times we had to fill a well\n  #\n  # fill each well to capacity\n  # return\
    \ the number of times we had to fill a well\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill a well\n  #\n  # fill each well\
    \ to capacity\n  # return the number of times we had to fill a well\n  #\n  #\
    \ fill each well to capacity\n  # return the number of times we had to fill a\
    \ well\n  #\n  # fill each well to capacity\n  # return the number of times we\
    \ had to fill a well\n  #\n  # fill each well to capacity\n  # return the number\
    \ of times we had to fill a well\n  #\n  # fill each well to capacity\n  # return\
    \ the number of times we had to fill a well\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill a well\n  #\n  # fill each well\
    \ to capacity\n  # return the number of times we had to fill a well\n  #\n  #\
    \ fill each well to capacity\n  # return the number of times we had to fill a\
    \ well\n  #\n  # fill each well to capacity\n  # return", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.max if row.max > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  # return 0 if grid.empty?\n  # return\
    \ 0 if grid.first.empty?\n  # return 0 if capacity <= 0\n  # return 0 if grid.all?\
    \ { |row| row.all? { |cell| cell == 0 } }\n  # return 0 if grid.all? { |row| row.all?\
    \ { |cell| cell == 1 } }\n  # return grid.size * grid.first.size if capacity >=\
    \ grid.size * grid.first.size\n  # grid.map! { |row| row.map { |cell| cell ==\
    \ 1 ? capacity : cell } }\n  # grid.each_with_index do |row, i|\n  #   row.each_with_index\
    \ do |cell, j|\n  #     if cell == capacity\n  #       grid[i][j] = 0\n  #   \
    \    if i > 0\n  #         grid[i - 1][j] = grid[i - 1][j] + 1\n  #       end\n\
    \  #       if j > 0\n  #         grid[i][j - 1] = grid[i][j - 1] + 1\n  #    \
    \   end\n  #       if i < grid.size - 1\n  #         grid[i + 1][j] = grid[i +\
    \ 1][j] + 1\n  #       end\n  #       if j < grid.first.size - 1\n  #        \
    \ grid[i][j + 1] = grid[i][j + 1] + 1\n  #       end\n  #     end\n  #   end\n\
    \  # end\n  # max_fill(grid, capacity) + 1\n  return 0 if grid.empty?\n  return\
    \ 0 if grid.first.empty?\n  return 0 if capacity <= 0\n  return 0 if grid.all?\
    \ { |row| row.all? { |cell| cell == 0 } }\n  return 0 if grid.all? { |row| row.all?\
    \ { |cell| cell == 1 } }\n  return grid.size * grid.first.size if capacity >=\
    \ grid.size * grid.first.size\n  grid.map! { |row| row.map { |cell| cell == 1\
    \ ? capacity : cell } }\n  grid.each_with_index do |", "  # fill all wells with\
    \ capacity\n  # return number of times we filled the wells\n  # fill all wells\
    \ with capacity\n  # return number of times we filled the wells\n  # fill all\
    \ wells with capacity\n  # return number of times we filled the wells\n  # fill\
    \ all wells with capacity\n  # return number of times we filled the wells\n  #\
    \ fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the wells\n\
    \  # fill all wells with capacity\n  # return number of times we filled the",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.sum].max\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n\
    \  n, m = grid.size, grid[0].size\n  max_fill = 0\n  (0...n).each do |i|\n   \
    \ (0...m).each do |j|\n      max_fill = [max_fill, grid[i][j]].max\n    end\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = [max_fill, row.sum].max\n  end\n  max_fill\n\
    end", "  return 0 if grid.empty?\n  return 0 if grid[0].empty?\n  return 0 if\
    \ capacity <= 0\n  return 0 if grid.all? { |row| row.all? { |cell| cell == 0 }\
    \ }\n  return grid.length if grid.all? { |row| row.all? { |cell| cell == 1 } }\n\
    \  # puts \"grid=#{grid.inspect}\"\n  # puts \"capacity=#{capacity}\"\n  # puts\
    \ \"grid.length=#{grid.length}\"\n  # puts \"grid[0].length=#{grid[0].length}\"\
    \n  # puts \"grid[0].length * capacity=#{grid[0].length * capacity}\"\n  # puts\
    \ \"grid.length * capacity=#{grid.length * capacity}\"\n  # puts \"grid.length\
    \ * grid[0].length * capacity=#{grid.length * grid[0].length * capacity}\"\n \
    \ # puts \"grid.length * grid[0].length * capacity / 2=#{grid.length * grid[0].length\
    \ * capacity / 2}\"\n  # puts \"grid.length * grid[0].length * capacity / 2 +\
    \ 1=#{grid.length * grid[0].length * capacity / 2 + 1}\"\n  # puts \"grid.length\
    \ * grid[0].length * capacity / 2 + 2=#{grid.length * grid[0].length * capacity\
    \ / 2 + 2}\"\n  # puts \"grid.length * grid[0].length * capacity / 2 + 3=#{grid.length\
    \ * grid[0].length * capacity / 2 + 3}\"\n  # puts \"grid.length * grid[0].length\
    \ * capacity / 2 + 4=#{grid.length * grid[0].length * capacity / 2 + 4}\"\n  #\
    \ puts \"grid.length * grid[0].length * capacity / 2 + 5=#{grid.length * grid[0].length\
    \ * capacity / 2 + 5}\"\n  # puts \"grid.length * grid[0].length * capacity /\
    \ 2 + 6=#{grid.length * grid[0].length * capacity / 2 + 6}\"\n  # puts \"grid.length\
    \ * grid[0].length * capacity / 2 + 7=#{grid.length * grid[0].length * capacity\
    \ / 2 + 7}\"\n  # puts \"", "  grid.map { |row| row.sum }.max / capacity\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.max if row.max > max_fill\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill > capacity ? capacity : max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = row.max if row.max > max_fill\n  end\n  max_fill\n\
    end", "  # find the max height of the grid\n  max_height = 0\n  grid.each do |row|\n\
    \    max_height = row.max if row.max > max_height\n  end\n  # fill the grid from\
    \ the max height down to 0\n  count = 0\n  (max_height).downto(0) do |height|\n\
    \    # fill the grid at this height\n    grid.each do |row|\n      row.each do\
    \ |cell|\n        if cell >= height\n          cell -= capacity\n          count\
    \ += 1\n        end\n      end\n    end\n  end\n  count\nend", "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  # return 0 if grid.empty?\n  # return 0 if grid.all?\
    \ { |row| row.all? { |col| col == 0 } }\n  # return 0 if capacity == 0\n  # return\
    \ grid.length if capacity >= grid.length\n  # return grid.map(&:length).max if\
    \ capacity >= grid.map(&:length).max\n  # return grid.map(&:length).max if capacity\
    \ >= grid.map(&:length).max\n  # return grid.map(&:length).max if capacity >=\
    \ grid.map(&:length).max\n  # return grid.map(&:length).max if capacity >= grid.map(&:length).max\n\
    \  # return grid.map(&:length).max if capacity >= grid.map(&:length).max\n  #\
    \ return grid.map(&:length).max if capacity >= grid.map(&:length).max\n  # return\
    \ grid.map(&:length).max if capacity >= grid.map(&:length).max\n  # return grid.map(&:length).max\
    \ if capacity >= grid.map(&:length).max\n  # return grid.map(&:length).max if\
    \ capacity >= grid.map(&:length).max\n  # return grid.map(&:length).max if capacity\
    \ >= grid.map(&:length).max\n  # return grid.map(&:length).max if capacity >=\
    \ grid.map(&:length).max\n  # return grid.map(&:length).max if capacity >= grid.map(&:length).max\n\
    \  # return grid.map(&:length).max if capacity >= grid.map(&:length).max\n  #\
    \ return grid.map(&:length).max if capacity >= grid.map(&:length).max\n  # return\
    \ grid.map(&:length).max if capacity >= grid.map(&:length).max\n  # return grid.map(&:length).max\
    \ if capacity >= grid.map(&:length).max\n  # return grid.map(&:length).max if\
    \ capacity >= grid.map(&:length).max\n  # return grid.map(&:length).max if capacity\
    \ >= grid.map(&:length).max\n  # return grid.map(&:length).max if capacity >=\
    \ grid.map(&:length).max\n  # return grid.map(&:length).max if capacity >= grid",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  # find the max height of the grid\n  max_height =\
    \ grid.map { |row| row.count(1) }.max\n  # fill the grid with water\n  grid.each\
    \ do |row|\n    (max_height - row.count(1)).times { row.push(1) }\n  end\n  #\
    \ count the number of times we need to lower the bucket\n  grid.flatten.count(1)\
    \ / capacity\nend", "  grid.map { |row| row.reduce(:+) / capacity }.reduce(:+)\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.max if row.max\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.sum].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill += row.count(1)\n  end\n  max_fill / capacity\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.reduce(:+)].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\
    \ > capacity ? capacity : max_fill\nend", "  # Fill each well with water\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      if col == 1\n      \
    \  grid[i][j] = capacity\n      end\n    end\n  end\n  # Find the max value of\
    \ each column\n  max_col_vals = []\n  grid[0].each_with_index do |col, i|\n  \
    \  max_col_vals << grid.map { |row| row[i] }.max\n  end\n  # Find the max value\
    \ of each row\n  max_row_vals = grid.map { |row| row.max }\n  # Find the max value\
    \ of each row and column\n  max_vals = max_row_vals + max_col_vals\n  # Return\
    \ the max value\n  max_vals.max\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  # fill\
    \ each well\n  grid.map! { |row| row.map { |well| well * capacity } }\n  # fill\
    \ each row\n  grid.map! { |row| row.reduce(:+) }\n  # fill each column\n  grid.transpose.map!\
    \ { |col| col.reduce(:+) }\n  # fill each row again\n  grid.map! { |row| row.reduce(:+)\
    \ }\n  # fill each column again\n  grid.transpose.map! { |col| col.reduce(:+)\
    \ }\n  # fill each row again\n  grid.map! { |row| row.reduce(:+) }\n  # fill each\
    \ column again\n  grid.transpose.map! { |col| col.reduce(:+) }\n  # fill each\
    \ row again\n  grid.map! { |row| row.reduce(:+) }\n  # fill each column again\n\
    \  grid.transpose.map! { |col| col.reduce(:+) }\n  # fill each row again\n  grid.map!\
    \ { |row| row.reduce(:+) }\n  # fill each column again\n  grid.transpose.map!\
    \ { |col| col.reduce(:+) }\n  # fill each row again\n  grid.map! { |row| row.reduce(:+)\
    \ }\n  # fill each column again\n  grid.transpose.map! { |col| col.reduce(:+)\
    \ }\n  # fill each row again\n  grid.map! { |row| row.reduce(:+) }\n  # fill each\
    \ column again\n  grid.transpose.map! { |col| col.reduce(:+) }\n  # fill each\
    \ row again\n  grid.map! { |row| row.reduce(:+) }\n  # fill each column again\n\
    \  grid.transpose.map! { |col| col.reduce(:+) }\n  # fill each row again\n  grid.map!\
    \ { |row| row.reduce(:+) }\n  # fill each column again\n  grid.transpose.map!\
    \ { |col| col.reduce(:+) }\n  # fill each row again\n ", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = [max_fill, row.reduce(:+)].max\n  end\n  max_fill\n\
    end", "  # find the max fill\n  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.max if row.max > max_fill\n  end\n  # find the number of times to fill\n\
    \  max_fill / capacity\nend", "  max_fill = 0\n  grid.each do |row|\n    row.each\
    \ do |cell|\n      max_fill += cell\n    end\n  end\n  max_fill / capacity\nend",
  "  max_fill = 0\n  grid.each do |row|\n    row.each do |well|\n      max_fill +=\
    \ well\n    end\n  end\n  max_fill / capacity\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.reduce(:+)].max\n\
    \  end\n  max_fill\nend", "  # find the max height of the grid\n  max_height =\
    \ 0\n  grid.each do |row|\n    max_height = row.max if row.max > max_height\n\
    \  end\n  # fill the grid from the max height to 0\n  # each time, fill the wells\
    \ that are not full\n  # and subtract the capacity from the wells that are full\n\
    \  # return the number of times we filled the wells\n  count = 0\n  (max_height).downto(0)\
    \ do |height|\n    grid.each do |row|\n      row.each do |well|\n        if well\
    \ < height\n          well += capacity\n          count += 1\n        elsif well\
    \ > height\n          well -= capacity\n        end\n      end\n    end\n  end\n\
    \  count\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    row.each do |well|\n      max_fill =\
    \ [max_fill, well].max\n    end\n  end\n  max_fill = [max_fill, capacity].min\n\
    \  max_fill\nend", "  # find the max height of the grid\n  max_height = 0\n  grid.each\
    \ do |row|\n    max_height = row.max if row.max > max_height\n  end\n  # for each\
    \ height, fill the wells\n  max_height.times do |height|\n    grid.each do |row|\n\
    \      row.each_with_index do |well, index|\n        if well > 0\n          row[index]\
    \ -= 1\n        end\n      end\n    end\n  end\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\
    \ > capacity ? capacity : max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill += row.count(1)\n  end\n  max_fill / capacity\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.max if row.max > max_fill\n  end\n\
    \  max_fill\nend", "  grid.map { |row| row.sum }.max / capacity\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill > capacity ? capacity : max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = [max_fill, row.sum].max\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.max if row.max\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.sum if row.sum > max_fill\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  # Fill each bucket to capacity.\n  # If a bucket\
    \ is already full, skip it.\n  # If a bucket is not full, fill it to capacity.\n\
    \  # If a bucket is over capacity, fill it to capacity.\n  # If a bucket is empty,\
    \ skip it.\n  # Return the number of times a bucket was filled.\n  #\n  # Time:\
    \ O(n)\n  # Space: O(1)\n  #\n  # Example:\n  # grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n  # capacity : 1\n  #\n  # max_fill(grid, capacity)\n  # => 6\n\
    \  #\n  # grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n  # capacity :\
    \ 2\n  #\n  # max_fill(grid, capacity)\n  # => 5\n  #\n  # grid : [[0,0,0], [0,0,0]]\n\
    \  # capacity : 5\n  #\n  # max_fill(grid, capacity)\n  # => 0\n  #\n  # grid\
    \ : [[0,0,0], [0,0,0]]\n  # capacity : 1\n  #\n  # max_fill(grid, capacity)\n\
    \  # => 0\n  #\n  # grid : [[0,0,0], [0,0,0]]\n  # capacity : 0\n  #\n  # max_fill(grid,\
    \ capacity)\n  # => 0\n  #\n  # grid : [[0,0,0], [0,0,0]]\n  # capacity : -1\n\
    \  #\n  # max_fill(grid, capacity)\n  # => 0\n  #\n  # grid : [[0,0,0], [0,0,0]]\n\
    \  # capacity : nil\n  #\n  # max_fill(grid, capacity)\n  # => 0\n  #\n  # grid\
    \ : [[0,0,0], [0,0,0]]\n  # capacity : \"1\"\n  #\n  # max_fill(grid, capacity)",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.sum].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.inject(:+)].max\n  end\n  max_fill\nend", "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\
    \ * capacity\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill * capacity\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  # count the number of 1's in each row\n  # if the count is less than capacity,\
    \ we can fill the entire row\n  # if the count is greater than capacity, we can\
    \ fill the entire row\n  # if the count is equal to capacity, we can fill the\
    \ entire row\n  # return the number of rows that can be filled\n  grid.map { |row|\
    \ row.count(1) }.select { |count| count <= capacity }.size\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  # return 0 if grid.empty?\n  # return 0 if grid.all? { |row|\
    \ row.all? { |cell| cell == 0 } }\n  # return grid.length if grid.all? { |row|\
    \ row.all? { |cell| cell == 1 } }\n  # return grid.length if capacity == 1\n \
    \ # return grid.length * grid[0].length if capacity >= grid.length\n  # return\
    \ grid.length if capacity >= grid[0].length\n  # return grid[0].length if capacity\
    \ >= grid.length\n  # return grid.length + grid[0].length if capacity >= grid.length\
    \ + grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0].length if capacity >= grid.length\
    \ * grid[0].length\n  # return grid.length * grid[0", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  return 0 if grid.empty?\n  rows = grid.size\n  cols = grid[0].size\n\
    \  return 0 if rows == 0 || cols == 0\n  # dp[i][j] = max_fill(grid[i][j])\n \
    \ dp = Array.new(rows) { Array.new(cols, 0) }\n  # dp[i][j] = max_fill(grid[i][j])\n\
    \  # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n  # dp[i][j] = max(dp[i-1][j],\
    \ dp[i][j-1]) + grid[i][j]\n  # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\
    \  # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n  # dp[i][j] = max(dp[i-1][j],\
    \ dp[i][j-1]) + grid[i][j]\n  # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\
    \  # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n  # dp[i][j] = max(dp[i-1][j],\
    \ dp[i][j-1]) + grid[i][j]\n  # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\
    \  # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n  # dp[i][j] = max(dp[i-1][j],\
    \ dp[i][j-1]) + grid[i][j]\n ", "  # find the max height of the grid\n  max_height\
    \ = 0\n  grid.each do |row|\n    max_height = row.max if row.max > max_height\n\
    \  end\n  # fill the grid from the top down\n  num_buckets = 0\n  (0...max_height).each\
    \ do |height|\n    grid.each do |row|\n      # fill the row\n      row.each do\
    \ |well|\n        if well > height\n          # fill the well\n          num_buckets\
    \ += 1\n        end\n      end\n    end\n  end\n  num_buckets\nend", "  # fill\
    \ each well with the maximum amount of water\n  # return the number of times the\
    \ bucket was lowered\n  # to fill the wells\n  #\n  # fill each well with the\
    \ maximum amount of water\n  # return the number of times the bucket was lowered\n\
    \  # to fill the wells\n  #\n  # fill each well with the maximum amount of water\n\
    \  # return the number of times the bucket was lowered\n  # to fill the wells\n\
    \  #\n  # fill each well with the maximum amount of water\n  # return the number\
    \ of times the bucket was lowered\n  # to fill the wells\n  #\n  # fill each well\
    \ with the maximum amount of water\n  # return the number of times the bucket\
    \ was lowered\n  # to fill the wells\n  #\n  # fill each well with the maximum\
    \ amount of water\n  # return the number of times the bucket was lowered\n  #\
    \ to fill the wells\n  #\n  # fill each well with the maximum amount of water\n\
    \  # return the number of times the bucket was lowered\n  # to fill the wells\n\
    \  #\n  # fill each well with the maximum amount of water\n  # return the number\
    \ of times the bucket was lowered\n  # to fill the wells\n  #\n  # fill each well\
    \ with the maximum amount of water\n  # return the number of times the bucket\
    \ was lowered\n  # to fill the wells\n  #\n  # fill each well with the maximum\
    \ amount of water\n  # return the number of times the bucket was lowered\n  #\
    \ to fill the wells\n  #\n  # fill each well with the maximum amount of water\n\
    \  # return the number of times the bucket was lowered\n  # to fill the wells\n\
    \  #\n  # fill each well with the maximum amount of water\n  # return the number\
    \ of times the bucket was lowered\n  # to fill the wells\n  #\n  # fill each well\
    \ with the maximum amount of water\n  # return the number of times the bucket\
    \ was lowered\n  # to fill the wells\n  #\n  # fill each well with the maximum\
    \ amount of water\n  # return the number of times the bucket was lowered\n  #\
    \ to fill the wells\n  #\n  # fill each well with the maximum amount of water\n\
    \  # return the number of times the bucket was lowered\n  # to fill the wells\n\
    \  #\n ", "  return 0 if grid.empty?\n  return 0 if grid[0].empty?\n  rows = grid.size\n\
    \  cols = grid[0].size\n  max_fill = 0\n  (0...rows).each do |row|\n    (0...cols).each\
    \ do |col|\n      max_fill = [max_fill, grid[row][col]].max\n    end\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  # find max height\n  max_height\
    \ = 0\n  grid.each do |row|\n    max_height = row.max if row.max > max_height\n\
    \  end\n  # fill each row\n  max_height.times do |i|\n    grid.each do |row|\n\
    \      row.each_with_index do |cell, j|\n        if cell == 1\n          grid[i][j]\
    \ = 0\n          capacity -= 1\n          if capacity == 0\n            capacity\
    \ = max_fill(grid, capacity)\n          end\n        end\n      end\n    end\n\
    \  end\n  capacity\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill > capacity ? capacity : max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.max if row.max > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = row.max if row.max > max_fill\n  end\n \
    \ max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = row.max if row.max > max_fill\n  end\n  max_fill\nend",
  "  return 0 if grid.empty?\n  rows = grid.length\n  cols = grid[0].length\n  max_fill\
    \ = 0\n  (0...rows).each do |i|\n    (0...cols).each do |j|\n      max_fill =\
    \ [max_fill, grid[i][j]].max\n    end\n  end\n  max_fill\nend", "  max_fill =\
    \ 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  grid.map { |row| row.sum }.max / capacity\nend",
  "  grid.map { |row| row.sum }.max / capacity\nend", "  return 0 if grid.empty?\n\
    \  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.sum].max\n\
    \  end\n  max_fill / capacity + (max_fill % capacity > 0 ? 1 : 0)\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.reduce(:+)].max\n \
    \ end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill =\
    \ row.count(1) if row.count(1) > max_fill\n  end\n  max_fill > capacity ? capacity\
    \ : max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1)\
    \ if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill > capacity ? capacity : max_fill\nend", "  # return\
    \ 0 if grid.empty?\n  # return 0 if grid.first.empty?\n  # return 0 if capacity\
    \ <= 0\n  # return grid.size if capacity >= grid.first.size\n  # max_fill_helper(grid,\
    \ capacity, 0, 0)\n  # max_fill_helper(grid, capacity, 0, 0, 0)\n  # max_fill_helper(grid,\
    \ capacity, 0, 0, 0, 0)\n  max_fill_helper(grid, capacity, 0, 0, 0, 0, 0)\nend",
  "  # return 0 if grid.empty?\n  # return 0 if grid.first.empty?\n  # return 0 if\
    \ capacity == 0\n  # return grid.size * grid.first.size if capacity == 1\n  #\
    \ max_fill(grid, capacity - 1) + grid.size * grid.first.size\n  return 0 if grid.empty?\n\
    \  return 0 if grid.first.empty?\n  return 0 if capacity == 0\n  return grid.size\
    \ * grid.first.size if capacity == 1\n  max_fill(grid, capacity - 1) + grid.size\
    \ * grid.first.size\nend", "  # find the max height of the grid\n  max_height\
    \ = grid.map { |row| row.count(1) }.max\n  # fill the grid with the capacity\n\
    \  fill_grid(grid, capacity)\n  # loop through the grid until the max height is\
    \ reached\n  # or the grid is empty\n  max_height.times do |i|\n    # fill the\
    \ grid with the capacity\n    fill_grid(grid, capacity)\n    # break if the grid\
    \ is empty\n    break if grid.all? { |row| row.all? { |cell| cell == 0 } }\n \
    \ end\n  # return the number of times the grid was filled\n  $fill_count\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  return 0 if grid.empty?\n  return 0 if grid.all?\
    \ { |row| row.all? { |cell| cell == 0 } }\n  return grid.size if grid.all? { |row|\
    \ row.all? { |cell| cell == 1 } }\n  return grid.size if capacity == 1\n  return\
    \ grid.size * grid[0].size if capacity >= grid.size\n  return grid.size * capacity\
    \ if capacity >= grid[0].size\n  return grid.size * capacity + (grid[0].size -\
    \ capacity) if capacity < grid[0].size\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = row.max if row.max > max_fill\n  end\n  max_fill\nend",
  "  # fill each well to capacity\n  # return number of times bucket was lowered\n\
    \  # if bucket is already full, don't lower it\n  # if well is already full, don't\
    \ lower bucket\n  # if well is empty, don't lower bucket\n  # if well is partially\
    \ full, fill it to capacity\n  # if well is over capacity, lower bucket to capacity\n\
    \  # if well is partially full and bucket is partially full, fill both to capacity\n\
    \  # if well is partially full and bucket is over capacity, fill well to capacity\n\
    \  # if well is over capacity and bucket is partially full, fill well to capacity\n\
    \  # if well is over capacity and bucket is over capacity, fill well to capacity\n\
    \  # if well is over capacity and bucket is empty, fill well to capacity\n  #\
    \ if well is empty and bucket is partially full, don't lower bucket\n  # if well\
    \ is empty and bucket is over capacity, don't lower bucket\n  # if well is empty\
    \ and bucket is empty, don't lower bucket\n  # if well is partially full and bucket\
    \ is empty, don't lower bucket\n  # if well is over capacity and bucket is empty,\
    \ don't lower bucket\n  # if well is empty and bucket is partially full, don't\
    \ lower bucket\n  # if well is empty and bucket is over capacity, don't lower\
    \ bucket\n  # if well is partially full and bucket is partially full, fill both\
    \ to capacity\n  # if well is partially full and bucket is over capacity, fill\
    \ well to capacity\n  # if well is over capacity and bucket is partially full,\
    \ fill well to capacity\n  # if well is over capacity and bucket is over capacity,\
    \ fill well to capacity\n  # if well is over capacity and bucket is empty, fill\
    \ well to capacity\n  # if well is empty and bucket is partially full, don't lower\
    \ bucket\n  # if well is empty and bucket is over capacity, don't lower bucket\n\
    \  # if well is empty and bucket is empty, don't lower bucket\n  # if well is\
    \ partially full and bucket is empty, don't lower bucket\n  # if well is over\
    \ capacity and bucket is empty, don't lower bucket\n  # if well is empty and bucket\
    \ is partially full, don't lower bucket\n  # if well is empty and bucket is over\
    \ capacity, don't lower bucket\n  # if well is partially full and bucket is partially\
    \ full, fill both", "  grid.map { |row| row.reduce(:+) }.max / capacity\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill > capacity ? capacity : max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  # find the max height of the grid\n  max_height = grid.map\
    \ { |row| row.reduce(0, :+) }.max\n  # start filling the buckets from the max\
    \ height\n  # and keep filling till the grid is empty\n  (1..max_height).reduce(0)\
    \ do |count, height|\n    # fill the buckets with water\n    grid.map! { |row|\
    \ row.map { |well| well >= height ? 0 : well } }\n    # count the number of buckets\
    \ used\n    count + grid.reduce(0) { |sum, row| sum + row.reduce(0, :+) } / capacity\n\
    \  end\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = [max_fill, row.reduce(:+)].max\n  end\n  max_fill\nend",
  "  # fill each well to capacity\n  # return number of times we filled\n  # we can\
    \ fill a well if we have water in the previous well\n  # or if we have water in\
    \ the bucket\n  # we can fill the bucket if we have water in the previous well\n\
    \  # or if we have water in the bucket\n  # we can fill the bucket if we have\
    \ water in the previous well\n  # or if we have water in the bucket\n  # we can\
    \ fill the bucket if we have water in the previous well\n  # or if we have water\
    \ in the bucket\n  # we can fill the bucket if we have water in the previous well\n\
    \  # or if we have water in the bucket\n  # we can fill the bucket if we have\
    \ water in the previous well\n  # or if we have water in the bucket\n  # we can\
    \ fill the bucket if we have water in the previous well\n  # or if we have water\
    \ in the bucket\n  # we can fill the bucket if we have water in the previous well\n\
    \  # or if we have water in the bucket\n  # we can fill the bucket if we have\
    \ water in the previous well\n  # or if we have water in the bucket\n  # we can\
    \ fill the bucket if we have water in the previous well\n  # or if we have water\
    \ in the bucket\n  # we can fill the bucket if we have water in the previous well\n\
    \  # or if we have water in the bucket\n  # we can fill the bucket if we have\
    \ water in the previous well\n  # or if we have water in the bucket\n  # we can\
    \ fill the bucket if we have water in the previous well\n  # or if we have water\
    \ in the bucket\n  # we can fill the bucket if we have water in the previous well\n\
    \  # or if we have water in the bucket\n  # we can fill the bucket if we have\
    \ water in the previous well\n  # or if we have water in the bucket\n  # we can\
    \ fill the bucket if we have water in the previous well\n  # or if we have water\
    \ in the bucket\n  # we can fill the bucket if we have water in the previous well\n\
    \  # or if we have water in the bucket\n  # we can fill the bucket if we have\
    \ water in the previous well\n  # or if we have water in the bucket\n  # we can\
    \ fill the bucket if", "  # fill the first row\n  row = 0\n  col = 0\n  while\
    \ col < grid[row].length\n    if grid[row][col] == 1\n      grid[row][col] = capacity\n\
    \      col += 1\n    else\n      col += 1\n    end\n  end\n  # fill the rest of\
    \ the rows\n  row = 1\n  while row < grid.length\n    col = 0\n    while col <\
    \ grid[row].length\n      if grid[row][col] == 1\n        grid[row][col] = grid[row\
    \ - 1][col] - 1\n        col += 1\n      else\n        col += 1\n      end\n \
    \   end\n    row += 1\n  end\n  # count the number of times we need to lower the\
    \ buckets\n  row = 0\n  count = 0\n  while row < grid.length\n    col = 0\n  \
    \  while col < grid[row].length\n      if grid[row][col] > 0\n        count +=\
    \ 1\n        col += 1\n      else\n        col += 1\n      end\n    end\n    row\
    \ += 1\n  end\n  count\nend", "  return 0 if grid.empty?\n  return 0 if grid.all?\
    \ { |row| row.all? { |col| col == 0 } }\n  max_fill_helper(grid, capacity)\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.max if row.max > max_fill\n\
    \  end\n  max_fill\nend", "  # Fill the first row\n  row_count = grid.length\n\
    \  col_count = grid[0].length\n  max_fill = 0\n  (0...col_count).each do |col|\n\
    \    max_fill += grid[0][col]\n  end\n  # Fill the rest of the rows\n  (1...row_count).each\
    \ do |row|\n    (0...col_count).each do |col|\n      if grid[row][col] == 1\n\
    \        grid[row][col] = [grid[row-1][col], capacity].min\n        max_fill +=\
    \ grid[row][col]\n      end\n    end\n  end\n  max_fill\nend", "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.max if row.max\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  # return 0 if grid.empty?\n \
    \ # return 0 if grid.all? { |row| row.all? { |cell| cell == 0 } }\n  # return\
    \ 0 if grid.all? { |row| row.all? { |cell| cell == 1 } }\n  # return 0 if capacity\
    \ == 0\n  # return 0 if capacity == 1\n  # return 0 if capacity == 2\n  # return\
    \ 0 if capacity == 3\n  # return 0 if capacity == 4\n  # return 0 if capacity\
    \ == 5\n  # return 0 if capacity == 6\n  # return 0 if capacity == 7\n  # return\
    \ 0 if capacity == 8\n  # return 0 if capacity == 9\n  # return 0 if capacity\
    \ == 10\n  # return 0 if capacity == 11\n  # return 0 if capacity == 12\n  # return\
    \ 0 if capacity == 13\n  # return 0 if capacity == 14\n  # return 0 if capacity\
    \ == 15\n  # return 0 if capacity == 16\n  # return 0 if capacity == 17\n  # return\
    \ 0 if capacity == 18\n  # return 0 if capacity == 19\n  # return 0 if capacity\
    \ == 20\n  # return 0 if capacity == 21\n  # return 0 if capacity == 22\n  # return\
    \ 0 if capacity == 23\n  # return 0 if capacity == 24\n  # return 0 if capacity\
    \ == 25\n  # return 0 if capacity == 26\n  # return 0 if capacity == 27\n  # return\
    \ 0 if capacity == 28\n  # return 0 if capacity == 29\n  # return 0 if capacity\
    \ == 30\n  # return 0 if capacity == 31\n  # return 0 if capacity == 32\n  # return\
    \ 0 if capacity == 33\n  # return 0 if capacity == 34\n  # return 0 if capacity\
    \ == 35\n  # return 0 if capacity == 36\n  # return 0 if capacity == 37\n  # return\
    \ 0 if capacity == 38\n  # return 0 if capacity == 39\n  # return 0 if capacity\
    \ == 40\n  # return 0 if capacity == 41\n  # return 0 if capacity == 42\n  # return\
    \ 0 if capacity == 43\n  # return 0 if capacity == 44\n  # return 0 if capacity\
    \ == 45\n  # return 0 if capacity == 46\n  # return 0 if capacity == 47\n  # return\
    \ 0 if capacity == 48\n  # return 0 if capacity", "  rows = grid.length\n  cols\
    \ = grid[0].length\n  max_fill = 0\n  rows.times do |i|\n    cols.times do |j|\n\
    \      max_fill = [max_fill, grid[i][j]].max\n    end\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill > capacity ? capacity\
    \ : max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.max\
    \ if row.max > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.max if row.max > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill > capacity ? capacity : max_fill\nend", "  # return\
    \ 0 if grid.empty?\n  # return 0 if grid[0].empty?\n  # return 0 if capacity ==\
    \ 0\n  # return 0 if grid.all? { |row| row.all? { |cell| cell == 0 } }\n  # return\
    \ grid.size if grid.all? { |row| row.all? { |cell| cell == 1 } }"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
