name: HumanEval_128_prod_signs
language: ruby
results:
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe4fe9ntj\n\
    Started\n.\nFinished in 0.000213 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4694.84 tests/s, 37558.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbm_ust44\n\
    Started\n.\nFinished in 0.00022 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4545.45 tests/s, 36363.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf5u9dwzk\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf5u9dwzk.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf5u9dwzk.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf5u9dwzk.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf5u9dwzk.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf5u9dwzk.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001953 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    512.03 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbxw7qjhk\n\
    Started\n.\nFinished in 0.00025 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4000.00 tests/s, 32000.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpgffkjo_c\n\
    Started\n.\nFinished in 0.000218 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4587.16 tests/s, 36697.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpytlus7u5\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpytlus7u5.rb:16:in\
    \ `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n   \
    \  14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n \
    \ => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9>\
    \ expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.003234 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    309.21 tests/s, 309.21 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpi0yvomhz\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpi0yvomhz.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpi0yvomhz.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpi0yvomhz.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpi0yvomhz.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpi0yvomhz.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001976 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    506.07 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8khrif47\n\
    Started\n.\nFinished in 0.000212 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4716.98 tests/s, 37735.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2zccs1ad\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2zccs1ad.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2zccs1ad.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2zccs1ad.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2zccs1ad.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2zccs1ad.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001952 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    512.30 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpztqj8bqk\n\
    Started\n.\nFinished in 0.000208 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4807.69 tests/s, 38461.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1pqladpy\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1pqladpy.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1pqladpy.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1pqladpy.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1pqladpy.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1pqladpy.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.058737 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    17.03 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuumjebh0\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.sum * arr.map { |num| num.sign\
    \ }.reduce(:*)\n                                                       ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuumjebh0.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuumjebh0.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuumjebh0.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuumjebh0.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpuumjebh0.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001973 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    506.84 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp2uwplmba\n\
    Started\n.\nFinished in 0.000209 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4784.69 tests/s, 38277.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp748ufo5_\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp748ufo5_.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp748ufo5_.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp748ufo5_.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp748ufo5_.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp748ufo5_.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001938 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    516.00 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1gv1zv5y\n\
    Started\n.\nFinished in 0.000212 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4716.98 tests/s, 37735.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpcemnneik\n\
    Started\n.\nFinished in 0.000216 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4629.63 tests/s, 37037.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  if arr.empty?\n    return\
    \ nil\n  end\n  product = 1\n  sum = 0\n  arr.each do |num|\n    if num > 0\n\
    \      product *= 1\n      sum += num\n    elsif num < 0\n      product *= -1\n\
    \      sum += num.abs\n    end\n  end\n  sum * product\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate\
    \ = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n\
    \    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1,\
    \ 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20,\
    \ candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1,\
    \ 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0,\
    \ candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpddl8ndeu\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpddl8ndeu.rb:31:in\
    \ `test_prod_signs'\n     28:   def test_prod_signs\n     29:     candidate =\
    \ method(:prod_signs)\n     30:     assert_equal(-9, candidate.call([1, 2, 2,\
    \ -4]))\n  => 31:     assert_equal(0, candidate.call([0, 1]))\n     32:     assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     33:     assert_equal(nil, candidate.call([]))\n\
    \     34:     assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n<0> expected\
    \ but was\n<1>\n===============================================================================\n\
    \nFinished in 0.004223 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    236.80 tests/s, 473.60 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn8zbhszc\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn8zbhszc.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn8zbhszc.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn8zbhszc.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn8zbhszc.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn8zbhszc.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001943 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    514.67 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm4ot7j1d\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm4ot7j1d.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm4ot7j1d.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm4ot7j1d.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm4ot7j1d.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm4ot7j1d.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001922 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    520.29 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppi3r1tn5\n\
    Started\n.\nFinished in 0.000279 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3584.23 tests/s, 28673.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp804s6w2s\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp804s6w2s.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp804s6w2s.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp804s6w2s.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp804s6w2s.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp804s6w2s.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001928 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    518.67 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb8lxyqay\n\
    Started\n.\nFinished in 0.000214 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4672.90 tests/s, 37383.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp47akdsac\n\
    Started\n.\nFinished in 0.00021 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4761.90 tests/s, 38095.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpsapdx1ux\n\
    Started\n.\nFinished in 0.00021 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4761.90 tests/s, 38095.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmprp7e6cqn\n\
    Started\n.\nFinished in 0.000212 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4716.98 tests/s, 37735.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpy3bqov28\n\
    Started\n.\nFinished in 0.000208 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4807.69 tests/s, 38461.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpubofqv2t\n\
    Started\n.\nFinished in 0.000251 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3984.06 tests/s, 31872.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpabib8o8t\n\
    Started\n.\nFinished in 0.000206 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4854.37 tests/s, 38834.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0lhxln7r\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0lhxln7r.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0lhxln7r.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0lhxln7r.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0lhxln7r.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0lhxln7r.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.005197 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    192.42 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaew_xucu\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaew_xucu.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaew_xucu.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaew_xucu.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaew_xucu.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaew_xucu.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001935 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    516.80 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwdtzjxxe\n\
    Started\n.\nFinished in 0.000228 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4385.96 tests/s, 35087.72 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpigypirlf\n\
    Started\n.\nFinished in 0.00021 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4761.90 tests/s, 38095.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplw6h4xru\n\
    Started\n.\nFinished in 0.000212 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4716.98 tests/s, 37735.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvvr4kzpo\n\
    Started\n.\nFinished in 0.00021 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4761.90 tests/s, 38095.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpof975epx\n\
    Started\n.\nFinished in 0.000218 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4587.16 tests/s, 36697.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp9jjkqy_x\n\
    Started\n.\nFinished in 0.000206 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4854.37 tests/s, 38834.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppcetiw90\n\
    Started\n.\nFinished in 0.000236 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4237.29 tests/s, 33898.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpg3d6h0ix\n\
    Started\n.\nFinished in 0.000209 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4784.69 tests/s, 38277.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6gr0kgwt\n\
    Started\n.\nFinished in 0.00021 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4761.90 tests/s, 38095.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb9r0z2tc\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.sum * arr.map { |num| num.sign\
    \ }.reduce(:*)\n                                                       ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb9r0z2tc.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb9r0z2tc.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb9r0z2tc.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb9r0z2tc.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb9r0z2tc.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002504 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    399.36 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map(&:abs).reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpsdh0e29y\n\
    Started\n.\nFinished in 0.000662 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1510.57 tests/s, 12084.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpiz_8rzn1\n\
    Started\n.\nFinished in 0.000291 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3436.43 tests/s, 27491.41 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdkvhcqy_\n\
    Started\n.\nFinished in 0.000207 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4830.92 tests/s, 38647.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpd8vdxv3_\n\
    Started\n.\nFinished in 0.000238 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4201.68 tests/s, 33613.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpazf6faz0\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpazf6faz0.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpazf6faz0.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpazf6faz0.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpazf6faz0.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpazf6faz0.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001926 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    519.21 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpai14gv4q\n\
    Started\n.\nFinished in 0.000226 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4424.78 tests/s, 35398.23 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpc26vazrd\n\
    Started\n.\nFinished in 0.000239 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4184.10 tests/s, 33472.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe7k3nag4\n\
    Started\n.\nFinished in 0.000211 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4739.34 tests/s, 37914.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphoo1hhre\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphoo1hhre.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphoo1hhre.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphoo1hhre.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphoo1hhre.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphoo1hhre.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001952 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    512.30 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpqeogqn3o\n\
    Started\n.\nFinished in 0.000213 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4694.84 tests/s, 37558.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8_wznhz4\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8_wznhz4.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8_wznhz4.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8_wznhz4.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8_wznhz4.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8_wznhz4.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002085 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    479.62 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb5_8ss2g\n\
    Started\n.\nFinished in 0.000203 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4926.11 tests/s, 39408.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm8ksznxf\n\
    Started\n.\nFinished in 0.000209 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4784.69 tests/s, 38277.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplnl6pvei\n\
    Started\n.\nFinished in 0.000205 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4878.05 tests/s, 39024.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpyudz4dwr\n\
    Started\n.\nFinished in 0.000219 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4566.21 tests/s, 36529.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfo9w9602\n\
    Started\n.\nFinished in 0.000214 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4672.90 tests/s, 37383.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8wp1hq2o\n\
    Started\n.\nFinished in 0.000207 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4830.92 tests/s, 38647.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp9sn2h66w\n\
    Started\n.\nFinished in 0.000205 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4878.05 tests/s, 39024.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp92ahbvgt\n\
    Started\n.\nFinished in 0.000243 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4115.23 tests/s, 32921.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw6gygkpd\n\
    Started\n.\nFinished in 0.000207 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4830.92 tests/s, 38647.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq33ccvia\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq33ccvia.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq33ccvia.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq33ccvia.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq33ccvia.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq33ccvia.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001918 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    521.38 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpoiynv_bt\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpoiynv_bt.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpoiynv_bt.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpoiynv_bt.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpoiynv_bt.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpoiynv_bt.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002287 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    437.25 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpula44yyb\n\
    Started\n.\nFinished in 0.000219 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4566.21 tests/s, 36529.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.inject(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjwt9_efk\n\
    Started\n.\nFinished in 0.000251 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3984.06 tests/s, 31872.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpp1_b_y_g\n\
    Started\n.\nFinished in 0.000593 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1686.34 tests/s, 13490.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3nphovb1\n\
    Started\n.\nFinished in 0.000237 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4219.41 tests/s, 33755.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpilfvefq4\n\
    Started\n.\nFinished in 0.000265 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3773.58 tests/s, 30188.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpasj2y_8r\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpasj2y_8r.rb:16:in\
    \ `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n   \
    \  14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n \
    \ => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9>\
    \ expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.003386 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    295.33 tests/s, 295.33 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe826sqyu\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpe826sqyu.rb:16:in\
    \ `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n   \
    \  14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n \
    \ => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9>\
    \ expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.039623 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    25.24 tests/s, 25.24 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmperdoxyfb\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmperdoxyfb.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmperdoxyfb.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmperdoxyfb.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmperdoxyfb.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmperdoxyfb.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.010735 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    93.15 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpkbax_6ve\n\
    Started\n.\nFinished in 0.000215 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4651.16 tests/s, 37209.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwgds04t6\n\
    Started\n.\nFinished in 0.000212 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4716.98 tests/s, 37735.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1zvg20zo\n\
    Started\n.\nFinished in 0.000233 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4291.85 tests/s, 34334.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpcq_b9ay2\n\
    Started\n.\nFinished in 0.000222 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4504.50 tests/s, 36036.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0s0qg30p\n\
    Started\n.\nFinished in 0.000596 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1677.85 tests/s, 13422.82 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf0rm6wyl\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpf0rm6wyl.rb:16:in\
    \ `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n   \
    \  14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n \
    \ => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9>\
    \ expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.003307 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    302.39 tests/s, 302.39 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphur5sfnb\n\
    Started\n.\nFinished in 0.000232 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4310.34 tests/s, 34482.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz75_smk_\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz75_smk_.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz75_smk_.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz75_smk_.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz75_smk_.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz75_smk_.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.00198 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    505.05 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmph86olr3t\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmph86olr3t.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmph86olr3t.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmph86olr3t.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmph86olr3t.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmph86olr3t.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002782 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    359.45 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpotvwexg1\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpotvwexg1.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpotvwexg1.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpotvwexg1.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpotvwexg1.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpotvwexg1.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002138 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    467.73 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  prod = 1\n  sum = 0\n  arr.each do |num|\n    prod *= num.sign\n    sum +=\
    \ num.abs\n  end\n  prod * sum\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n\
    \    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0,\
    \ 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil,\
    \ candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1,\
    \ 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4,\
    \ candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1,\
    \ 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4hp5e205\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n      prod *= num.sign\n                 ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4hp5e205.rb:14:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4hp5e205.rb:13:in\
    \ `each'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4hp5e205.rb:13:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4hp5e205.rb:23:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4hp5e205.rb:23:in\
    \ `test_prod_signs'\n     20: class TestHumanEval < Test::Unit::TestCase\n   \
    \  21:   def test_prod_signs\n     22:     candidate = method(:prod_signs)\n \
    \ => 23:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     24:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     25:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     26:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002788 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    358.68 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxv5m6cbg\n\
    Started\n.\nFinished in 0.000209 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4784.69 tests/s, 38277.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk1jvn27z\n\
    Started\n.\nFinished in 0.000227 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4405.29 tests/s, 35242.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaezxlvkr\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaezxlvkr.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaezxlvkr.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaezxlvkr.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaezxlvkr.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpaezxlvkr.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001957 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    510.99 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa65rmtv3\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa65rmtv3.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa65rmtv3.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa65rmtv3.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa65rmtv3.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa65rmtv3.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002078 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    481.23 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6w4uidcw\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6w4uidcw.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6w4uidcw.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6w4uidcw.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6w4uidcw.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6w4uidcw.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.004751 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    210.48 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpp4sddgpe\n\
    Started\n.\nFinished in 0.000209 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4784.69 tests/s, 38277.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpy4m6rr80\n\
    Started\n.\nFinished in 0.000285 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3508.77 tests/s, 28070.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp483r70pl\n\
    Started\n.\nFinished in 0.000236 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4237.29 tests/s, 33898.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6e97i78l\n\
    Started\n.\nFinished in 0.000252 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3968.25 tests/s, 31746.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpcn1npazm\n\
    Started\n.\nFinished in 0.000218 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4587.16 tests/s, 36697.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp83xvyn96\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp83xvyn96.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp83xvyn96.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp83xvyn96.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp83xvyn96.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp83xvyn96.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.006755 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    148.04 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxysz2sv5\n\
    Started\n.\nFinished in 0.000223 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4484.30 tests/s, 35874.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpc5jb8tl8\n\
    Started\n.\nFinished in 0.000239 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4184.10 tests/s, 33472.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjsvu_lfl\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjsvu_lfl.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjsvu_lfl.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjsvu_lfl.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjsvu_lfl.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjsvu_lfl.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.00208 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    480.77 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8tmisi_j\n\
    Started\n.\nFinished in 0.00022 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4545.45 tests/s, 36363.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.zero? ? 1 : num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpafk0bo7z\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.sum * arr.map { |num| num.zero?\
    \ ? 1 : num.sign }.reduce(:*)\n                                              \
    \                         ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpafk0bo7z.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpafk0bo7z.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpafk0bo7z.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpafk0bo7z.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpafk0bo7z.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.013521 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    73.96 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp909yq501\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp909yq501.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp909yq501.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp909yq501.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp909yq501.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp909yq501.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002258 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    442.87 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpspjqg5i4\n\
    Started\n.\nFinished in 0.000268 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3731.34 tests/s, 29850.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |i| i.abs }.reduce(:+) * arr.map { |i| i <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmptc01y5vo\n\
    Started\n.\nFinished in 0.000225 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4444.44 tests/s, 35555.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmprh9ru74u\n\
    Started\n.\nFinished in 0.000246 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4065.04 tests/s, 32520.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpavbwivio\n\
    Started\n.\nFinished in 0.000222 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4504.50 tests/s, 36036.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdzvi04nm\n\
    Started\n.\nFinished in 0.000238 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4201.68 tests/s, 33613.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6b9hxos5\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6b9hxos5.rb:16:in\
    \ `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n   \
    \  14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n \
    \ => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9>\
    \ expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005903 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    169.41 tests/s, 169.41 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfi1tn7r0\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfi1tn7r0.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfi1tn7r0.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfi1tn7r0.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfi1tn7r0.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfi1tn7r0.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002074 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    482.16 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3shil8kh\n\
    Started\n.\nFinished in 0.00028 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3571.43 tests/s, 28571.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpu5ad94m2\n\
    Started\n.\nFinished in 0.000203 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4926.11 tests/s, 39408.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpsv0kebdu\n\
    Started\n.\nFinished in 0.00023 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4347.83 tests/s, 34782.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpflmuojpm\n\
    Started\n.\nFinished in 0.000272 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3676.47 tests/s, 29411.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpocj1v9fk\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpocj1v9fk.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpocj1v9fk.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpocj1v9fk.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpocj1v9fk.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpocj1v9fk.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002033 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    491.88 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphzwnm_pi\n\
    Started\n.\nFinished in 0.00036 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2777.78 tests/s, 22222.22 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_x2fd9sf\n\
    Started\n.\nFinished in 0.000402 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2487.56 tests/s, 19900.50 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp9b9g8flz\n\
    Started\n.\nFinished in 0.000224 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4464.29 tests/s, 35714.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.inject(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwwl_hlf9\n\
    Started\n.\nFinished in 0.009959 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    100.41 tests/s, 803.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpl4tx74l0\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpl4tx74l0.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpl4tx74l0.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpl4tx74l0.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpl4tx74l0.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpl4tx74l0.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001964 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    509.16 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0ndrbbh4\n\
    Started\n.\nFinished in 0.000218 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4587.16 tests/s, 36697.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp59w7i8pe\n\
    Started\n.\nFinished in 0.002488 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    401.93 tests/s, 3215.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzoyyz7ln\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzoyyz7ln.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzoyyz7ln.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzoyyz7ln.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzoyyz7ln.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzoyyz7ln.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002045 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    489.00 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwi1pory_\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwi1pory_.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwi1pory_.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwi1pory_.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwi1pory_.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwi1pory_.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002432 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    411.18 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpfvp7q83s\n\
    Started\n.\nFinished in 0.000232 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4310.34 tests/s, 34482.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm5kjofh2\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm5kjofh2.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm5kjofh2.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm5kjofh2.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm5kjofh2.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpm5kjofh2.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002073 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    482.39 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppc4lhdb1\n\
    Started\n.\nFinished in 0.000224 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4464.29 tests/s, 35714.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmply7mqwmi\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmply7mqwmi.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmply7mqwmi.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmply7mqwmi.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmply7mqwmi.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmply7mqwmi.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.030038 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    33.29 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpsrpd_nz8\n\
    Started\n.\nFinished in 0.000238 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4201.68 tests/s, 33613.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpwr24rbzz\n\
    Started\n.\nFinished in 0.000231 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4329.00 tests/s, 34632.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmppv7brv8c\n\
    Started\n.\nFinished in 0.000226 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4424.78 tests/s, 35398.23 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvozm111i\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.reduce(:+) * arr.map { |num|\
    \ num.sign }.reduce(:*)\n                                                    \
    \          ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvozm111i.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvozm111i.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvozm111i.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvozm111i.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvozm111i.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.060833 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    16.44 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpi55dih29\n\
    Started\n.\nFinished in 0.00058 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1724.14 tests/s, 13793.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7xy0ebgi\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7xy0ebgi.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7xy0ebgi.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7xy0ebgi.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7xy0ebgi.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7xy0ebgi.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002055 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    486.62 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpmesr71o_\n\
    Started\n.\nFinished in 0.000313 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3194.89 tests/s, 25559.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  if arr.empty?\n    return\
    \ nil\n  end\n  sum = 0\n  prod = 1\n  arr.each do |num|\n    if num > 0\n   \
    \   prod *= 1\n      sum += num\n    elsif num < 0\n      prod *= -1\n      sum\
    \ += num.abs\n    end\n  end\n  sum * prod\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n\
    \    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0,\
    \ 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil,\
    \ candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1,\
    \ 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4,\
    \ candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1,\
    \ 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpmtgawt6o\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpmtgawt6o.rb:31:in\
    \ `test_prod_signs'\n     28:   def test_prod_signs\n     29:     candidate =\
    \ method(:prod_signs)\n     30:     assert_equal(-9, candidate.call([1, 2, 2,\
    \ -4]))\n  => 31:     assert_equal(0, candidate.call([0, 1]))\n     32:     assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     33:     assert_equal(nil, candidate.call([]))\n\
    \     34:     assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n<0> expected\
    \ but was\n<1>\n===============================================================================\n\
    \nFinished in 0.033571 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    29.79 tests/s, 59.58 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphg5jv7tc\n\
    Started\n.\nFinished in 0.000922 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1084.60 tests/s, 8676.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4vj04qvw\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4vj04qvw.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4vj04qvw.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4vj04qvw.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4vj04qvw.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4vj04qvw.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001906 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    524.66 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpv6im4o_l\n\
    Started\n.\nFinished in 0.002245 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    445.43 tests/s, 3563.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbjo5ep1h\n\
    Started\n.\nFinished in 0.000245 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4081.63 tests/s, 32653.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjeyctchj\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjeyctchj.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjeyctchj.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjeyctchj.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjeyctchj.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjeyctchj.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002013 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    496.77 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1sf9buze\n\
    Started\n.\nFinished in 0.000227 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4405.29 tests/s, 35242.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1gfntbdz\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1gfntbdz.rb:16:in\
    \ `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n   \
    \  14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n \
    \ => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9>\
    \ expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.00372 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    268.82 tests/s, 268.82 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzxqm2u67\n\
    Started\n.\nFinished in 0.002985 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    335.01 tests/s, 2680.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphmbhnvz8\n\
    Started\n.\nFinished in 0.000246 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4065.04 tests/s, 32520.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpmave63zu\n\
    Started\n.\nFinished in 0.000231 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4329.00 tests/s, 34632.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpsqb6f5im\n\
    Started\n.\nFinished in 0.000231 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4329.00 tests/s, 34632.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpxi732n6s\n\
    Started\n.\nFinished in 0.000216 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4629.63 tests/s, 37037.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7jyi_3aj\n\
    Started\n.\nFinished in 0.000231 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4329.00 tests/s, 34632.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpax860uv8\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpax860uv8.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpax860uv8.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpax860uv8.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpax860uv8.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpax860uv8.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.004452 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    224.62 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpht4ijibg\n\
    Started\n.\nFinished in 0.000234 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4273.50 tests/s, 34188.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzlme9nv5\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzlme9nv5.rb:16:in\
    \ `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n   \
    \  14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n \
    \ => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9>\
    \ expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.003116 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    320.92 tests/s, 320.92 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpoksljmx0\n\
    Started\n.\nFinished in 0.000222 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4504.50 tests/s, 36036.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzkab_abl\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzkab_abl.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzkab_abl.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzkab_abl.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzkab_abl.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzkab_abl.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001939 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    515.73 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdf6kw4c4\n\
    Started\n.\nFinished in 0.000222 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4504.50 tests/s, 36036.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.sum * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpnuynwdao\n\
    Started\n.\nFinished in 0.000211 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4739.34 tests/s, 37914.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpjxb80dtw\n\
    Started\n.\nFinished in 0.000272 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3676.47 tests/s, 29411.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpnfcqn8xr\n\
    Started\n.\nFinished in 0.000214 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4672.90 tests/s, 37383.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp07r8xueq\n\
    Started\n.\nFinished in 0.000214 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4672.90 tests/s, 37383.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp725toknh\n\
    Started\n.\nFinished in 0.000281 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3558.72 tests/s, 28469.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzm72k6ph\n\
    Started\n.\nFinished in 0.000232 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4310.34 tests/s, 34482.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0_wee88u\n\
    Started\n.\nFinished in 0.00038 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2631.58 tests/s, 21052.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn_wgsg2a\n\
    Started\n.\nFinished in 0.000236 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4237.29 tests/s, 33898.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp853zupva\n\
    Started\n.\nFinished in 0.000201 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4975.12 tests/s, 39801.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplyh33r6l\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.sum * arr.map { |num| num.sign\
    \ }.reduce(:*)\n                                                       ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplyh33r6l.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplyh33r6l.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplyh33r6l.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplyh33r6l.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmplyh33r6l.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002446 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    408.83 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdlql93u9\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdlql93u9.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdlql93u9.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdlql93u9.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdlql93u9.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpdlql93u9.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002012 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    497.02 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpekgewhfb\n\
    Started\n.\nFinished in 0.000221 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4524.89 tests/s, 36199.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmptw1iulxc\n\
    Started\n.\nFinished in 0.00021 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4761.90 tests/s, 38095.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpl6kd4eu7\n\
    Started\n.\nFinished in 0.000225 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4444.44 tests/s, 35555.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpmjmabhxf\n\
    Started\n.\nFinished in 0.000239 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4184.10 tests/s, 33472.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.inject(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6qst8kc4\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.sum * arr.map { |num| num.sign\
    \ }.inject(:*)\n                                                       ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6qst8kc4.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6qst8kc4.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6qst8kc4.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6qst8kc4.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6qst8kc4.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001935 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    516.80 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpho5f1zij\n\
    Started\n.\nFinished in 0.000255 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3921.57 tests/s, 31372.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt6orufll\n\
    Started\n.\nFinished in 0.000242 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4132.23 tests/s, 33057.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpl6ks4nyk\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpl6ks4nyk.rb:16:in\
    \ `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n   \
    \  14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n \
    \ => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9>\
    \ expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.022531 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    44.38 tests/s, 44.38 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn0prdu_8\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn0prdu_8.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn0prdu_8.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn0prdu_8.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn0prdu_8.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpn0prdu_8.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001941 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    515.20 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphzjnz_3z\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphzjnz_3z.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphzjnz_3z.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphzjnz_3z.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphzjnz_3z.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmphzjnz_3z.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002432 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    411.18 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7hwu8t8p\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |num| num.abs }.sum * arr.map { |num| num.sign\
    \ }.reduce(:*)\n                                                       ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7hwu8t8p.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7hwu8t8p.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7hwu8t8p.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7hwu8t8p.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp7hwu8t8p.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.003163 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    316.16 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4rmr_1es\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4rmr_1es.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4rmr_1es.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4rmr_1es.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4rmr_1es.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4rmr_1es.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002427 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    412.03 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpambkuc3u\n\
    Started\n.\nFinished in 0.000233 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4291.85 tests/s, 34334.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.reduce(1) { |a, e| a * e.sign }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb6qqrd81\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.reduce(1) { |a,\
    \ e| a * e.sign }\n                                                          \
    \         ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb6qqrd81.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb6qqrd81.rb:11:in\
    \ `each'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb6qqrd81.rb:11:in\
    \ `reduce'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb6qqrd81.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb6qqrd81.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpb6qqrd81.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.004014 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    249.13 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw0unwddt\n\
    Started\n.\nFinished in 0.000222 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4504.50 tests/s, 36036.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpq4mfg1nv\n\
    Started\n.\nFinished in 0.000222 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4504.50 tests/s, 36036.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4f4q_tiw\n\
    Started\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4f4q_tiw.rb:16:in\
    \ `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n   \
    \  14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n \
    \ => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9>\
    \ expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.011428 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    87.50 tests/s, 87.50 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp153xm_fz\n\
    Started\n.\nFinished in 0.000223 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4484.30 tests/s, 35874.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpql_l1lha\n\
    Started\n.\nFinished in 0.000226 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4424.78 tests/s, 35398.23 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  prod = 1\n  sum = 0\n  arr.each do |num|\n    prod *= num <=> 0\n    sum +=\
    \ num.abs\n  end\n  prod * sum\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n\
    \    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0,\
    \ 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil,\
    \ candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1,\
    \ 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4,\
    \ candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1,\
    \ 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp3ghtp6z6\n\
    Started\n.\nFinished in 0.000238 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4201.68 tests/s, 33613.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpd0in4tg_\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpd0in4tg_.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpd0in4tg_.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpd0in4tg_.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpd0in4tg_.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpd0in4tg_.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001991 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    502.26 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp1lu7oh4w\n\
    Started\n.\nFinished in 0.000231 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4329.00 tests/s, 34632.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpd_el3m82\n\
    Started\n.\nFinished in 0.000216 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4629.63 tests/s, 37037.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmptnxhjn2b\n\
    Started\n.\nFinished in 0.000234 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4273.50 tests/s, 34188.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.inject(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmprjabtdaf\n\
    Started\n.\nFinished in 0.000216 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4629.63 tests/s, 37037.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw_j7sk79\n\
    Started\n.\nFinished in 0.000221 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4524.89 tests/s, 36199.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzv3j0hmo\n\
    Started\n.\nFinished in 0.000219 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4566.21 tests/s, 36529.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzwh5mgw9\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\n\
    \                                               ^^^^^\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzwh5mgw9.rb:11:in\
    \ `block in prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzwh5mgw9.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzwh5mgw9.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzwh5mgw9.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzwh5mgw9.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001946 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    513.87 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpbo1r56ag\n\
    Started\n.\nFinished in 0.000265 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3773.58 tests/s, 30188.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpkwuqf5n6\n\
    Started\n.\nFinished in 0.000216 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4629.63 tests/s, 37037.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpymh8ylrb\n\
    Started\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval):\n  NoMethodError: undefined method `sign'\
    \ for 1:Integer\n  \n    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign\
    \ }.reduce(:*)\n                                                      ^^^^^\n\
    /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpymh8ylrb.rb:11:in `block in\
    \ prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpymh8ylrb.rb:11:in\
    \ `map'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpymh8ylrb.rb:11:in\
    \ `prod_signs'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpymh8ylrb.rb:17:in\
    \ `call'\n/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpymh8ylrb.rb:17:in\
    \ `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n   \
    \  15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n \
    \ => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.001909 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    523.83 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp4wbtf4nd\n\
    Started\n.\nFinished in 0.000319 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3134.80 tests/s, 25078.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp8qgd9i0d\n\
    Started\n.\nFinished in 0.000215 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4651.16 tests/s, 37209.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6xbnw_4w\n\
    Started\n.\nFinished in 0.000209 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4784.69 tests/s, 38277.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5ilmc102\n\
    Started\n.\nFinished in 0.000225 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4444.44 tests/s, 35555.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvooageom\n\
    Started\n.\nFinished in 0.000218 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4587.16 tests/s, 36697.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.sum * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpyd7s_qo9\n\
    Started\n.\nFinished in 0.000228 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4385.96 tests/s, 35087.72 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpzt61ff8b\n\
    Started\n.\nFinished in 0.000207 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4830.92 tests/s, 38647.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: !!int ''
  stderr: "Loaded suite /var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp6feisycp\n\
    Started\n.\nFinished in 0.000215 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    4651.16 tests/s, 37209.30 assertions/s\n"
  exit_code: 0
  status: OK
