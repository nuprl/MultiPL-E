name: HumanEval_128_prod_signs
language: ruby
results:
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnwy07xi7\nStarted\n.\nFinished in 0.000362381 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2759.53 tests/s, 22076.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5id7cbmp\nStarted\n.\nFinished in 0.00037224 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2686.44 tests/s, 21491.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpwau7pp5y\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpwau7pp5y.rb:11:in `block in prod_signs'\n/tmp/tmpwau7pp5y.rb:11:in\
    \ `map'\n/tmp/tmpwau7pp5y.rb:11:in `prod_signs'\n/tmp/tmpwau7pp5y.rb:17:in `call'\n\
    /tmp/tmpwau7pp5y.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002469634 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    404.92 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxdjl5ofm\nStarted\n.\nFinished in 0.000337363 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2964.17 tests/s, 23713.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5trg08fa\nStarted\n.\nFinished in 0.000347393 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2878.58 tests/s, 23028.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp1o1e68c7\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmp1o1e68c7.rb:16:in `test_prod_signs'\n\
    \     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n\
    \     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:    \
    \ assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005262956 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    190.01 tests/s, 190.01 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp19axdivz\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp19axdivz.rb:11:in `block in prod_signs'\n/tmp/tmp19axdivz.rb:11:in\
    \ `map'\n/tmp/tmp19axdivz.rb:11:in `prod_signs'\n/tmp/tmp19axdivz.rb:17:in `call'\n\
    /tmp/tmp19axdivz.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002175301 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    459.71 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3dzkwoom\nStarted\n.\nFinished in 0.000342443 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2920.19 tests/s, 23361.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpvuf7f963\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpvuf7f963.rb:11:in `block in prod_signs'\n/tmp/tmpvuf7f963.rb:11:in\
    \ `map'\n/tmp/tmpvuf7f963.rb:11:in `prod_signs'\n/tmp/tmpvuf7f963.rb:17:in `call'\n\
    /tmp/tmpvuf7f963.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.003276351 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    305.22 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnkwaiwrv\nStarted\n.\nFinished in 0.000347233 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2879.91 tests/s, 23039.28 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpmni1dqce\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpmni1dqce.rb:11:in `block in prod_signs'\n/tmp/tmpmni1dqce.rb:11:in\
    \ `map'\n/tmp/tmpmni1dqce.rb:11:in `prod_signs'\n/tmp/tmpmni1dqce.rb:17:in `call'\n\
    /tmp/tmpmni1dqce.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002268906 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    440.74 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpsuxflpt8\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpsuxflpt8.rb:11:in `block in prod_signs'\n/tmp/tmpsuxflpt8.rb:11:in\
    \ `map'\n/tmp/tmpsuxflpt8.rb:11:in `prod_signs'\n/tmp/tmpsuxflpt8.rb:17:in `call'\n\
    /tmp/tmpsuxflpt8.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002429858 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    411.55 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8x_duw1l\nStarted\n.\nFinished in 0.000371799 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2689.63 tests/s, 21517.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpi7dsbn4b\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpi7dsbn4b.rb:11:in `block in prod_signs'\n/tmp/tmpi7dsbn4b.rb:11:in\
    \ `map'\n/tmp/tmpi7dsbn4b.rb:11:in `prod_signs'\n/tmp/tmpi7dsbn4b.rb:17:in `call'\n\
    /tmp/tmpi7dsbn4b.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002449035 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    408.32 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmueym6nw\nStarted\n.\nFinished in 0.000461908 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2164.93 tests/s, 17319.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6o10llqb\nStarted\n.\nFinished in 0.00036139 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2767.09 tests/s, 22136.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  if arr.empty?\n    return\
    \ nil\n  end\n  product = 1\n  sum = 0\n  arr.each do |num|\n    if num > 0\n\
    \      product *= 1\n      sum += num\n    elsif num < 0\n      product *= -1\n\
    \      sum += num.abs\n    end\n  end\n  sum * product\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate\
    \ = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n\
    \    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1,\
    \ 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20,\
    \ candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1,\
    \ 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0,\
    \ candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpj_pozimp\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmpj_pozimp.rb:31:in `test_prod_signs'\n\
    \     28:   def test_prod_signs\n     29:     candidate = method(:prod_signs)\n\
    \     30:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n  => 31:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     32:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     33:     assert_equal(nil, candidate.call([]))\n    \
    \ 34:     assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n<0> expected\
    \ but was\n<1>\n===============================================================================\n\
    \nFinished in 0.005605549 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    178.39 tests/s, 356.79 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpi4t8we2g\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpi4t8we2g.rb:11:in `block in prod_signs'\n/tmp/tmpi4t8we2g.rb:11:in\
    \ `map'\n/tmp/tmpi4t8we2g.rb:11:in `prod_signs'\n/tmp/tmpi4t8we2g.rb:17:in `call'\n\
    /tmp/tmpi4t8we2g.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002192953 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    456.01 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqub6dpkk\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpqub6dpkk.rb:11:in `block in prod_signs'\n/tmp/tmpqub6dpkk.rb:11:in\
    \ `map'\n/tmp/tmpqub6dpkk.rb:11:in `prod_signs'\n/tmp/tmpqub6dpkk.rb:17:in `call'\n\
    /tmp/tmpqub6dpkk.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002725634 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    366.89 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp12tr0k8b\nStarted\n.\nFinished in 0.000447041 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2236.93 tests/s, 17895.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqp3c7w57\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpqp3c7w57.rb:11:in `block in prod_signs'\n/tmp/tmpqp3c7w57.rb:11:in\
    \ `map'\n/tmp/tmpqp3c7w57.rb:11:in `prod_signs'\n/tmp/tmpqp3c7w57.rb:17:in `call'\n\
    /tmp/tmpqp3c7w57.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002389443 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    418.51 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvhswa_w8\nStarted\n.\nFinished in 0.000422755 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2365.44 tests/s, 18923.49 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdw4xp65e\nStarted\n.\nFinished in 0.000475464 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2103.21 tests/s, 16825.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmermny47\nStarted\n.\nFinished in 0.000373222 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2679.37 tests/s, 21434.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxa_t990z\nStarted\n.\nFinished in 0.000371248 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2693.62 tests/s, 21548.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5xe95av0\nStarted\n.\nFinished in 0.000360738 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2772.09 tests/s, 22176.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptubghwjj\nStarted\n.\nFinished in 0.000352182 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2839.44 tests/s, 22715.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu0of4ati\nStarted\n.\nFinished in 0.000416372 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2401.70 tests/s, 19213.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjdm8h4c3\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpjdm8h4c3.rb:11:in `block in prod_signs'\n/tmp/tmpjdm8h4c3.rb:11:in\
    \ `map'\n/tmp/tmpjdm8h4c3.rb:11:in `prod_signs'\n/tmp/tmpjdm8h4c3.rb:17:in `call'\n\
    /tmp/tmpjdm8h4c3.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002283985 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    437.83 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmplkj3cvi6\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmplkj3cvi6.rb:11:in `block in prod_signs'\n/tmp/tmplkj3cvi6.rb:11:in\
    \ `map'\n/tmp/tmplkj3cvi6.rb:11:in `prod_signs'\n/tmp/tmplkj3cvi6.rb:17:in `call'\n\
    /tmp/tmplkj3cvi6.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002161505 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    462.64 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxd80rxp0\nStarted\n.\nFinished in 0.000356991 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2801.19 tests/s, 22409.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7k_l8vvt\nStarted\n.\nFinished in 0.00036703 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2724.57 tests/s, 21796.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwlcju4so\nStarted\n.\nFinished in 0.00035603 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2808.75 tests/s, 22470.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxl924hmc\nStarted\n.\nFinished in 0.000365337 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2737.20 tests/s, 21897.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxzcipsvk\nStarted\n.\nFinished in 0.000370727 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2697.40 tests/s, 21579.22 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptw1j4zc2\nStarted\n.\nFinished in 0.000347765 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2875.51 tests/s, 23004.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkukxkznr\nStarted\n.\nFinished in 0.000385235 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2595.82 tests/s, 20766.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjzb0ua72\nStarted\n.\nFinished in 0.000439918 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2273.15 tests/s, 18185.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpe7mshge6\nStarted\n.\nFinished in 0.000336053 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2975.72 tests/s, 23805.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxne0xbny\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpxne0xbny.rb:11:in `block in prod_signs'\n/tmp/tmpxne0xbny.rb:11:in\
    \ `map'\n/tmp/tmpxne0xbny.rb:11:in `prod_signs'\n/tmp/tmpxne0xbny.rb:17:in `call'\n\
    /tmp/tmpxne0xbny.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002190628 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    456.49 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map(&:abs).reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqq0uu434\nStarted\n.\nFinished in 0.000401795 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2488.83 tests/s, 19910.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1r9xx6eg\nStarted\n.\nFinished in 0.000396335 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2523.12 tests/s, 20184.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkq2elbbm\nStarted\n.\nFinished in 0.000312658 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3198.38 tests/s, 25587.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpiuv90bfs\nStarted\n.\nFinished in 0.000418216 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2391.11 tests/s, 19128.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6vyfzdt2\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp6vyfzdt2.rb:11:in `block in prod_signs'\n/tmp/tmp6vyfzdt2.rb:11:in\
    \ `map'\n/tmp/tmp6vyfzdt2.rb:11:in `prod_signs'\n/tmp/tmp6vyfzdt2.rb:17:in `call'\n\
    /tmp/tmp6vyfzdt2.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.003512464 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    284.70 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbz63ghg5\nStarted\n.\nFinished in 0.00036696 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2725.09 tests/s, 21800.74 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpisheyiyc\nStarted\n.\nFinished in 0.000466207 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2144.97 tests/s, 17159.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpq1ayefjh\nStarted\n.\nFinished in 0.000329449 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3035.37 tests/s, 24282.97 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5vi8n88c\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp5vi8n88c.rb:11:in `block in prod_signs'\n/tmp/tmp5vi8n88c.rb:11:in\
    \ `map'\n/tmp/tmp5vi8n88c.rb:11:in `prod_signs'\n/tmp/tmp5vi8n88c.rb:17:in `call'\n\
    /tmp/tmp5vi8n88c.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.00217503 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    459.76 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo6ejlujc\nStarted\n.\nFinished in 0.00036164 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2765.18 tests/s, 22121.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4tvs8vg2\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp4tvs8vg2.rb:11:in `block in prod_signs'\n/tmp/tmp4tvs8vg2.rb:11:in\
    \ `map'\n/tmp/tmp4tvs8vg2.rb:11:in `prod_signs'\n/tmp/tmp4tvs8vg2.rb:17:in `call'\n\
    /tmp/tmp4tvs8vg2.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002470274 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    404.81 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpy4qzhmji\nStarted\n.\nFinished in 0.00038829 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2575.39 tests/s, 20603.16 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpk7r538v8\nStarted\n.\nFinished in 0.000354306 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2822.42 tests/s, 22579.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgi__es_k\nStarted\n.\nFinished in 0.000353876 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2825.85 tests/s, 22606.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqwv0qkwq\nStarted\n.\nFinished in 0.000439316 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2276.27 tests/s, 18210.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpan3r3mn4\nStarted\n.\nFinished in 0.000422905 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2364.60 tests/s, 18916.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpflzwcesr\nStarted\n.\nFinished in 0.000415281 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2408.01 tests/s, 19264.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpv0xvbyae\nStarted\n.\nFinished in 0.000349087 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2864.62 tests/s, 22916.92 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphh8r2uiy\nStarted\n.\nFinished in 0.000412485 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2424.33 tests/s, 19394.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwrb0zpo5\nStarted\n.\nFinished in 0.000409681 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2440.92 tests/s, 19527.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpyys8lu3k\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpyys8lu3k.rb:11:in `block in prod_signs'\n/tmp/tmpyys8lu3k.rb:11:in\
    \ `map'\n/tmp/tmpyys8lu3k.rb:11:in `prod_signs'\n/tmp/tmpyys8lu3k.rb:17:in `call'\n\
    /tmp/tmpyys8lu3k.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002073228 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    482.34 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp42m4xrlo\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp42m4xrlo.rb:11:in `block in prod_signs'\n/tmp/tmp42m4xrlo.rb:11:in\
    \ `map'\n/tmp/tmp42m4xrlo.rb:11:in `prod_signs'\n/tmp/tmp42m4xrlo.rb:17:in `call'\n\
    /tmp/tmp42m4xrlo.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002208282 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    452.84 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpstq48794\nStarted\n.\nFinished in 0.000341252 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2930.39 tests/s, 23443.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.inject(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7r9yekrw\nStarted\n.\nFinished in 0.000364565 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2743.00 tests/s, 21943.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6ns6f4fw\nStarted\n.\nFinished in 0.000459434 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2176.59 tests/s, 17412.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnat1bk9v\nStarted\n.\nFinished in 0.000326323 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3064.45 tests/s, 24515.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpa0vrunah\nStarted\n.\nFinished in 0.000450807 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2218.24 tests/s, 17745.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpk931p7ed\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmpk931p7ed.rb:16:in `test_prod_signs'\n\
    \     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n\
    \     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:    \
    \ assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005906636 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    169.30 tests/s, 169.30 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3zj8v36i\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmp3zj8v36i.rb:16:in `test_prod_signs'\n\
    \     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n\
    \     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:    \
    \ assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.004736447 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    211.13 tests/s, 211.13 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpc_3ygtag\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpc_3ygtag.rb:11:in `block in prod_signs'\n/tmp/tmpc_3ygtag.rb:11:in\
    \ `map'\n/tmp/tmpc_3ygtag.rb:11:in `prod_signs'\n/tmp/tmpc_3ygtag.rb:17:in `call'\n\
    /tmp/tmpc_3ygtag.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002233438 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    447.74 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz31apcr1\nStarted\n.\nFinished in 0.00036197 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2762.66 tests/s, 22101.28 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcsq3q6ld\nStarted\n.\nFinished in 0.000397938 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2512.95 tests/s, 20103.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmponxv09u2\nStarted\n.\nFinished in 0.000351941 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2841.39 tests/s, 22731.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpd5te0npz\nStarted\n.\nFinished in 0.000366158 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2731.06 tests/s, 21848.49 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2cgoksaa\nStarted\n.\nFinished in 0.000449536 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2224.52 tests/s, 17796.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6vn3d3_b\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmp6vn3d3_b.rb:16:in `test_prod_signs'\n\
    \     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n\
    \     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:    \
    \ assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.004884845 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    204.71 tests/s, 204.71 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp35t5wzcr\nStarted\n.\nFinished in 0.000344908 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2899.32 tests/s, 23194.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpb3drwkfu\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpb3drwkfu.rb:11:in `block in prod_signs'\n/tmp/tmpb3drwkfu.rb:11:in\
    \ `map'\n/tmp/tmpb3drwkfu.rb:11:in `prod_signs'\n/tmp/tmpb3drwkfu.rb:17:in `call'\n\
    /tmp/tmpb3drwkfu.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002286198 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    437.41 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqwth9hy0\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpqwth9hy0.rb:11:in `block in prod_signs'\n/tmp/tmpqwth9hy0.rb:11:in\
    \ `map'\n/tmp/tmpqwth9hy0.rb:11:in `prod_signs'\n/tmp/tmpqwth9hy0.rb:17:in `call'\n\
    /tmp/tmpqwth9hy0.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002157177 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    463.57 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5bp03kj2\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp5bp03kj2.rb:11:in `block in prod_signs'\n/tmp/tmp5bp03kj2.rb:11:in\
    \ `map'\n/tmp/tmp5bp03kj2.rb:11:in `prod_signs'\n/tmp/tmp5bp03kj2.rb:17:in `call'\n\
    /tmp/tmp5bp03kj2.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002190749 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    456.46 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  prod = 1\n  sum = 0\n  arr.each do |num|\n    prod *= num.sign\n    sum +=\
    \ num.abs\n  end\n  prod * sum\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n\
    \    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0,\
    \ 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil,\
    \ candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1,\
    \ 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4,\
    \ candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1,\
    \ 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpt7qrwafp\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpt7qrwafp.rb:14:in `block in prod_signs'\n/tmp/tmpt7qrwafp.rb:13:in\
    \ `each'\n/tmp/tmpt7qrwafp.rb:13:in `prod_signs'\n/tmp/tmpt7qrwafp.rb:23:in `call'\n\
    /tmp/tmpt7qrwafp.rb:23:in `test_prod_signs'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_prod_signs\n     22:     candidate = method(:prod_signs)\n\
    \  => 23:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     24:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     25:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     26:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002075623 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    481.78 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp92db_t76\nStarted\n.\nFinished in 0.000343797 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2908.69 tests/s, 23269.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9rk3u1rg\nStarted\n.\nFinished in 0.000350017 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2857.00 tests/s, 22856.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4wszrgfh\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp4wszrgfh.rb:11:in `block in prod_signs'\n/tmp/tmp4wszrgfh.rb:11:in\
    \ `map'\n/tmp/tmp4wszrgfh.rb:11:in `prod_signs'\n/tmp/tmp4wszrgfh.rb:17:in `call'\n\
    /tmp/tmp4wszrgfh.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.00229214 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    436.27 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp07ou25ia\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp07ou25ia.rb:11:in `block in prod_signs'\n/tmp/tmp07ou25ia.rb:11:in\
    \ `map'\n/tmp/tmp07ou25ia.rb:11:in `prod_signs'\n/tmp/tmp07ou25ia.rb:17:in `call'\n\
    /tmp/tmp07ou25ia.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002067437 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    483.69 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpm28pqew7\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpm28pqew7.rb:11:in `block in prod_signs'\n/tmp/tmpm28pqew7.rb:11:in\
    \ `map'\n/tmp/tmpm28pqew7.rb:11:in `prod_signs'\n/tmp/tmpm28pqew7.rb:17:in `call'\n\
    /tmp/tmpm28pqew7.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002231035 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    448.22 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8a2wn2vm\nStarted\n.\nFinished in 0.000380906 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2625.32 tests/s, 21002.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmperak8p2s\nStarted\n.\nFinished in 0.000396134 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2524.40 tests/s, 20195.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6pnq95v9\nStarted\n.\nFinished in 0.000398619 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2508.66 tests/s, 20069.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwb1n3iz7\nStarted\n.\nFinished in 0.000358715 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2787.73 tests/s, 22301.83 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmmqid_sa\nStarted\n.\nFinished in 0.000485594 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2059.33 tests/s, 16474.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpykynqqre\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpykynqqre.rb:11:in `block in prod_signs'\n/tmp/tmpykynqqre.rb:11:in\
    \ `map'\n/tmp/tmpykynqqre.rb:11:in `prod_signs'\n/tmp/tmpykynqqre.rb:17:in `call'\n\
    /tmp/tmpykynqqre.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.00221759 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    450.94 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxxafbp42\nStarted\n.\nFinished in 0.000392657 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2546.75 tests/s, 20374.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpr1o_mes5\nStarted\n.\nFinished in 0.000390655 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2559.80 tests/s, 20478.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpr9s5034d\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpr9s5034d.rb:11:in `block in prod_signs'\n/tmp/tmpr9s5034d.rb:11:in\
    \ `map'\n/tmp/tmpr9s5034d.rb:11:in `prod_signs'\n/tmp/tmpr9s5034d.rb:17:in `call'\n\
    /tmp/tmpr9s5034d.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002645354 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    378.02 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphkl1sk99\nStarted\n.\nFinished in 0.000378352 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2643.04 tests/s, 21144.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.zero? ? 1 : num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpi9tg40w0\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpi9tg40w0.rb:11:in `block in prod_signs'\n/tmp/tmpi9tg40w0.rb:11:in\
    \ `map'\n/tmp/tmpi9tg40w0.rb:11:in `prod_signs'\n/tmp/tmpi9tg40w0.rb:17:in `call'\n\
    /tmp/tmpi9tg40w0.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002231897 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    448.05 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpabyo0yt3\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpabyo0yt3.rb:11:in `block in prod_signs'\n/tmp/tmpabyo0yt3.rb:11:in\
    \ `map'\n/tmp/tmpabyo0yt3.rb:11:in `prod_signs'\n/tmp/tmpabyo0yt3.rb:17:in `call'\n\
    /tmp/tmpabyo0yt3.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002253437 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    443.77 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnl6ll7yd\nStarted\n.\nFinished in 0.000472999 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2114.17 tests/s, 16913.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |i| i.abs }.reduce(:+) * arr.map { |i| i <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3ek2p35t\nStarted\n.\nFinished in 0.000410211 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2437.77 tests/s, 19502.16 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdnh9h5y0\nStarted\n.\nFinished in 0.000390534 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2560.60 tests/s, 20484.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqtciv_y8\nStarted\n.\nFinished in 0.000344027 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2906.75 tests/s, 23253.99 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpziul_0tn\nStarted\n.\nFinished in 0.000395343 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2529.45 tests/s, 20235.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmph2lrh5nn\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmph2lrh5nn.rb:16:in `test_prod_signs'\n\
    \     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n\
    \     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:    \
    \ assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.004819913 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    207.47 tests/s, 207.47 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpy_werrv_\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpy_werrv_.rb:11:in `block in prod_signs'\n/tmp/tmpy_werrv_.rb:11:in\
    \ `map'\n/tmp/tmpy_werrv_.rb:11:in `prod_signs'\n/tmp/tmpy_werrv_.rb:17:in `call'\n\
    /tmp/tmpy_werrv_.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002255581 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    443.34 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9o_94msp\nStarted\n.\nFinished in 0.000323188 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3094.17 tests/s, 24753.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0cvmsqc1\nStarted\n.\nFinished in 0.000348816 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2866.84 tests/s, 22934.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvckakd1l\nStarted\n.\nFinished in 0.000380565 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2627.67 tests/s, 21021.38 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb1qfzy72\nStarted\n.\nFinished in 0.000307239 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3254.80 tests/s, 26038.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3q_06doi\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp3q_06doi.rb:11:in `block in prod_signs'\n/tmp/tmp3q_06doi.rb:11:in\
    \ `map'\n/tmp/tmp3q_06doi.rb:11:in `prod_signs'\n/tmp/tmp3q_06doi.rb:17:in `call'\n\
    /tmp/tmp3q_06doi.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002281359 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    438.34 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_ya_p3z9\nStarted\n.\nFinished in 0.00036158 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2765.64 tests/s, 22125.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdi593lv1\nStarted\n.\nFinished in 0.000366249 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2730.38 tests/s, 21843.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7ob0pjcm\nStarted\n.\nFinished in 0.000467128 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2140.74 tests/s, 17125.93 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.inject(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6z_t7spr\nStarted\n.\nFinished in 0.000352733 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2835.01 tests/s, 22680.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2zq929y9\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp2zq929y9.rb:11:in `block in prod_signs'\n/tmp/tmp2zq929y9.rb:11:in\
    \ `map'\n/tmp/tmp2zq929y9.rb:11:in `prod_signs'\n/tmp/tmp2zq929y9.rb:17:in `call'\n\
    /tmp/tmp2zq929y9.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002197191 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    455.13 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkpgogg1z\nStarted\n.\nFinished in 0.000364736 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2741.71 tests/s, 21933.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpi01q5gft\nStarted\n.\nFinished in 0.000505921 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1976.59 tests/s, 15812.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxx3xkjt9\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpxx3xkjt9.rb:11:in `block in prod_signs'\n/tmp/tmpxx3xkjt9.rb:11:in\
    \ `map'\n/tmp/tmpxx3xkjt9.rb:11:in `prod_signs'\n/tmp/tmpxx3xkjt9.rb:17:in `call'\n\
    /tmp/tmpxx3xkjt9.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002617752 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    382.01 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp05t1ms3t\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp05t1ms3t.rb:11:in `block in prod_signs'\n/tmp/tmp05t1ms3t.rb:11:in\
    \ `map'\n/tmp/tmp05t1ms3t.rb:11:in `prod_signs'\n/tmp/tmp05t1ms3t.rb:17:in `call'\n\
    /tmp/tmp05t1ms3t.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002202791 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    453.97 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzuoftdio\nStarted\n.\nFinished in 0.000392498 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2547.78 tests/s, 20382.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp8h7k7og_\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp8h7k7og_.rb:11:in `block in prod_signs'\n/tmp/tmp8h7k7og_.rb:11:in\
    \ `map'\n/tmp/tmp8h7k7og_.rb:11:in `prod_signs'\n/tmp/tmp8h7k7og_.rb:17:in `call'\n\
    /tmp/tmp8h7k7og_.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002175822 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    459.60 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpembpe8id\nStarted\n.\nFinished in 0.000430058 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2325.27 tests/s, 18602.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpum0qn7tw\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpum0qn7tw.rb:11:in `block in prod_signs'\n/tmp/tmpum0qn7tw.rb:11:in\
    \ `map'\n/tmp/tmpum0qn7tw.rb:11:in `prod_signs'\n/tmp/tmpum0qn7tw.rb:17:in `call'\n\
    /tmp/tmpum0qn7tw.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002782361 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    359.41 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpsnbvtjp3\nStarted\n.\nFinished in 0.000349598 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2860.43 tests/s, 22883.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplyybl5xn\nStarted\n.\nFinished in 0.000316034 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3164.22 tests/s, 25313.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb7jic9ip\nStarted\n.\nFinished in 0.000357331 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2798.53 tests/s, 22388.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6_39fbex\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp6_39fbex.rb:11:in `block in prod_signs'\n/tmp/tmp6_39fbex.rb:11:in\
    \ `map'\n/tmp/tmp6_39fbex.rb:11:in `prod_signs'\n/tmp/tmp6_39fbex.rb:17:in `call'\n\
    /tmp/tmp6_39fbex.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002230564 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    448.32 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3ous0fkc\nStarted\n.\nFinished in 0.000374224 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2672.20 tests/s, 21377.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp94k2vjb6\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp94k2vjb6.rb:11:in `block in prod_signs'\n/tmp/tmp94k2vjb6.rb:11:in\
    \ `map'\n/tmp/tmp94k2vjb6.rb:11:in `prod_signs'\n/tmp/tmp94k2vjb6.rb:17:in `call'\n\
    /tmp/tmp94k2vjb6.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002133931 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    468.62 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp44blpbi\nStarted\n.\nFinished in 0.000418467 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2389.67 tests/s, 19117.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  if arr.empty?\n    return\
    \ nil\n  end\n  sum = 0\n  prod = 1\n  arr.each do |num|\n    if num > 0\n   \
    \   prod *= 1\n      sum += num\n    elsif num < 0\n      prod *= -1\n      sum\
    \ += num.abs\n    end\n  end\n  sum * prod\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n\
    \    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0,\
    \ 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil,\
    \ candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1,\
    \ 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4,\
    \ candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1,\
    \ 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2hj3oij7\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmp2hj3oij7.rb:31:in `test_prod_signs'\n\
    \     28:   def test_prod_signs\n     29:     candidate = method(:prod_signs)\n\
    \     30:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n  => 31:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     32:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     33:     assert_equal(nil, candidate.call([]))\n    \
    \ 34:     assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n<0> expected\
    \ but was\n<1>\n===============================================================================\n\
    \nFinished in 0.005043544 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    198.27 tests/s, 396.55 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpog4ty2io\nStarted\n.\nFinished in 0.000410061 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2438.66 tests/s, 19509.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpmoal7jbs\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpmoal7jbs.rb:11:in `block in prod_signs'\n/tmp/tmpmoal7jbs.rb:11:in\
    \ `map'\n/tmp/tmpmoal7jbs.rb:11:in `prod_signs'\n/tmp/tmpmoal7jbs.rb:17:in `call'\n\
    /tmp/tmpmoal7jbs.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002195487 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    455.48 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo6mwurd4\nStarted\n.\nFinished in 0.000358414 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2790.07 tests/s, 22320.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2tddvub7\nStarted\n.\nFinished in 0.000386657 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2586.27 tests/s, 20690.17 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpgrt2k3tp\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpgrt2k3tp.rb:11:in `block in prod_signs'\n/tmp/tmpgrt2k3tp.rb:11:in\
    \ `map'\n/tmp/tmpgrt2k3tp.rb:11:in `prod_signs'\n/tmp/tmpgrt2k3tp.rb:17:in `call'\n\
    /tmp/tmpgrt2k3tp.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002273445 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    439.86 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1_nih5m9\nStarted\n.\nFinished in 0.000415862 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2404.64 tests/s, 19237.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpp4_gghp2\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmpp4_gghp2.rb:16:in `test_prod_signs'\n\
    \     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n\
    \     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:    \
    \ assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005572908 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    179.44 tests/s, 179.44 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpixvvkkvp\nStarted\n.\nFinished in 0.000379744 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2633.35 tests/s, 21066.82 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpx2xyc6ow\nStarted\n.\nFinished in 0.000379091 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2637.89 tests/s, 21103.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpf01gejcj\nStarted\n.\nFinished in 0.000368633 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2712.73 tests/s, 21701.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdrk_68zk\nStarted\n.\nFinished in 0.000412415 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2424.74 tests/s, 19397.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp76yk5crv\nStarted\n.\nFinished in 0.00038854 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2573.74 tests/s, 20589.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3euf7dax\nStarted\n.\nFinished in 0.000501172 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1995.32 tests/s, 15962.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpa0uttm6n\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpa0uttm6n.rb:11:in `block in prod_signs'\n/tmp/tmpa0uttm6n.rb:11:in\
    \ `map'\n/tmp/tmpa0uttm6n.rb:11:in `prod_signs'\n/tmp/tmpa0uttm6n.rb:17:in `call'\n\
    /tmp/tmpa0uttm6n.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002392879 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    417.91 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6p51ak0u\nStarted\n.\nFinished in 0.000389142 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2569.76 tests/s, 20558.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmps1uq6jw0\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmps1uq6jw0.rb:16:in `test_prod_signs'\n\
    \     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n\
    \     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:    \
    \ assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005248959 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    190.51 tests/s, 190.51 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8r39s_wn\nStarted\n.\nFinished in 0.000327587 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3052.62 tests/s, 24420.99 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpwoggsczr\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpwoggsczr.rb:11:in `block in prod_signs'\n/tmp/tmpwoggsczr.rb:11:in\
    \ `map'\n/tmp/tmpwoggsczr.rb:11:in `prod_signs'\n/tmp/tmpwoggsczr.rb:17:in `call'\n\
    /tmp/tmpwoggsczr.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002230273 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    448.38 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpi8n2tjo6\nStarted\n.\nFinished in 0.000405302 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2467.30 tests/s, 19738.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.sum * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp21dp8tiu\nStarted\n.\nFinished in 0.000384674 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2599.60 tests/s, 20796.83 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp76zsb91s\nStarted\n.\nFinished in 0.000369095 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2709.33 tests/s, 21674.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptywbwces\nStarted\n.\nFinished in 0.000362933 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2755.33 tests/s, 22042.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplsba5_ht\nStarted\n.\nFinished in 0.000341963 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2924.29 tests/s, 23394.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7az25wek\nStarted\n.\nFinished in 0.000392217 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2549.61 tests/s, 20396.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjqgr17g3\nStarted\n.\nFinished in 0.000363774 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2748.96 tests/s, 21991.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpv1y7d5y4\nStarted\n.\nFinished in 0.00042551 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2350.12 tests/s, 18800.97 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_lwlcvbc\nStarted\n.\nFinished in 0.000436581 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2290.53 tests/s, 18324.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgbmr9keo\nStarted\n.\nFinished in 0.000359797 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2779.35 tests/s, 22234.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpscrmnxyi\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpscrmnxyi.rb:11:in `block in prod_signs'\n/tmp/tmpscrmnxyi.rb:11:in\
    \ `map'\n/tmp/tmpscrmnxyi.rb:11:in `prod_signs'\n/tmp/tmpscrmnxyi.rb:17:in `call'\n\
    /tmp/tmpscrmnxyi.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002258988 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    442.68 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpafbn0ifc\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpafbn0ifc.rb:11:in `block in prod_signs'\n/tmp/tmpafbn0ifc.rb:11:in\
    \ `map'\n/tmp/tmpafbn0ifc.rb:11:in `prod_signs'\n/tmp/tmpafbn0ifc.rb:17:in `call'\n\
    /tmp/tmpafbn0ifc.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002234862 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    447.45 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfziqk46c\nStarted\n.\nFinished in 0.000342705 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2917.96 tests/s, 23343.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8juv5dre\nStarted\n.\nFinished in 0.00039848 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2509.54 tests/s, 20076.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp74e5s8m1\nStarted\n.\nFinished in 0.000418898 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2387.22 tests/s, 19097.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5b1gq0ei\nStarted\n.\nFinished in 0.000657587 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1520.71 tests/s, 12165.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.inject(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpy0pbslu0\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpy0pbslu0.rb:11:in `block in prod_signs'\n/tmp/tmpy0pbslu0.rb:11:in\
    \ `map'\n/tmp/tmpy0pbslu0.rb:11:in `prod_signs'\n/tmp/tmpy0pbslu0.rb:17:in `call'\n\
    /tmp/tmpy0pbslu0.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002254449 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    443.57 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmgvvdrzd\nStarted\n.\nFinished in 0.000389042 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2570.42 tests/s, 20563.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6xlet7ww\nStarted\n.\nFinished in 0.000409831 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2440.03 tests/s, 19520.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7mv2uj1k\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmp7mv2uj1k.rb:16:in `test_prod_signs'\n\
    \     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n\
    \     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:    \
    \ assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.006874166 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    145.47 tests/s, 145.47 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpocr27g1_\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpocr27g1_.rb:11:in `block in prod_signs'\n/tmp/tmpocr27g1_.rb:11:in\
    \ `map'\n/tmp/tmpocr27g1_.rb:11:in `prod_signs'\n/tmp/tmpocr27g1_.rb:17:in `call'\n\
    /tmp/tmpocr27g1_.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002195458 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    455.49 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpt0npfz5n\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpt0npfz5n.rb:11:in `block in prod_signs'\n/tmp/tmpt0npfz5n.rb:11:in\
    \ `map'\n/tmp/tmpt0npfz5n.rb:11:in `prod_signs'\n/tmp/tmpt0npfz5n.rb:17:in `call'\n\
    /tmp/tmpt0npfz5n.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002263746 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    441.75 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpsogfbzt_\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpsogfbzt_.rb:11:in `block in prod_signs'\n/tmp/tmpsogfbzt_.rb:11:in\
    \ `map'\n/tmp/tmpsogfbzt_.rb:11:in `prod_signs'\n/tmp/tmpsogfbzt_.rb:17:in `call'\n\
    /tmp/tmpsogfbzt_.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.003431543 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    291.41 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmph3c8dyzc\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmph3c8dyzc.rb:11:in `block in prod_signs'\n/tmp/tmph3c8dyzc.rb:11:in\
    \ `map'\n/tmp/tmph3c8dyzc.rb:11:in `prod_signs'\n/tmp/tmph3c8dyzc.rb:17:in `call'\n\
    /tmp/tmph3c8dyzc.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002095151 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    477.29 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpku1dyb5i\nStarted\n.\nFinished in 0.000424288 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2356.89 tests/s, 18855.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.reduce(1) { |a, e| a * e.sign }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp1etfqqz6\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp1etfqqz6.rb:11:in `block in prod_signs'\n/tmp/tmp1etfqqz6.rb:11:in\
    \ `each'\n/tmp/tmp1etfqqz6.rb:11:in `reduce'\n/tmp/tmp1etfqqz6.rb:11:in `prod_signs'\n\
    /tmp/tmp1etfqqz6.rb:17:in `call'\n/tmp/tmp1etfqqz6.rb:17:in `test_prod_signs'\n\
    \     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n\
    \     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:    \
    \ assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002381828 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    419.85 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzcqohwg5\nStarted\n.\nFinished in 0.001113884 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    897.76 tests/s, 7182.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp08zj3p3d\nStarted\n.\nFinished in 0.000346961 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2882.17 tests/s, 23057.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqfqhpqwx\nStarted\nF\n===============================================================================\n\
    Failure: test_prod_signs(TestHumanEval)\n/tmp/tmpqfqhpqwx.rb:16:in `test_prod_signs'\n\
    \     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n\
    \     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:\
    \     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:    \
    \ assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005092566 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    196.36 tests/s, 196.36 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1g335rzg\nStarted\n.\nFinished in 0.000415832 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2404.82 tests/s, 19238.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpebrft48r\nStarted\n.\nFinished in 0.000406404 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2460.61 tests/s, 19684.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  prod = 1\n  sum = 0\n  arr.each do |num|\n    prod *= num <=> 0\n    sum +=\
    \ num.abs\n  end\n  prod * sum\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n\
    \    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0,\
    \ 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil,\
    \ candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1,\
    \ 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4,\
    \ candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1,\
    \ 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_edxbgkp\nStarted\n.\nFinished in 0.000367972 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2717.60 tests/s, 21740.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3itbhrvc\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmp3itbhrvc.rb:11:in `block in prod_signs'\n/tmp/tmp3itbhrvc.rb:11:in\
    \ `map'\n/tmp/tmp3itbhrvc.rb:11:in `prod_signs'\n/tmp/tmp3itbhrvc.rb:17:in `call'\n\
    /tmp/tmp3itbhrvc.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002223461 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    449.75 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3urcg6qx\nStarted\n.\nFinished in 0.000335462 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2980.96 tests/s, 23847.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo8ylj0fm\nStarted\n.\nFinished in 0.000381768 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2619.39 tests/s, 20955.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyaycl6pu\nStarted\n.\nFinished in 0.000344087 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2906.24 tests/s, 23249.93 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.inject(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpr_y2mpjg\nStarted\n.\nFinished in 0.000374575 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2669.69 tests/s, 21357.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpy3gdm__8\nStarted\n.\nFinished in 0.000375567 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2662.64 tests/s, 21301.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpsqw_vgjz\nStarted\n.\nFinished in 0.000369706 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2704.85 tests/s, 21638.82 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpogql14u_\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpogql14u_.rb:11:in `block in prod_signs'\n/tmp/tmpogql14u_.rb:11:in\
    \ `map'\n/tmp/tmpogql14u_.rb:11:in `prod_signs'\n/tmp/tmpogql14u_.rb:17:in `call'\n\
    /tmp/tmpogql14u_.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002262424 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    442.00 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo3xgt7y3\nStarted\n.\nFinished in 0.000364215 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2745.63 tests/s, 21965.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmponjt4uy5\nStarted\n.\nFinished in 0.000369324 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2707.65 tests/s, 21661.20 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpn69ixegc\nStarted\nE\n===============================================================================\n\
    Error: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign'\
    \ for 1:Integer\n/tmp/tmpn69ixegc.rb:11:in `block in prod_signs'\n/tmp/tmpn69ixegc.rb:11:in\
    \ `map'\n/tmp/tmpn69ixegc.rb:11:in `prod_signs'\n/tmp/tmpn69ixegc.rb:17:in `call'\n\
    /tmp/tmpn69ixegc.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n\
    \     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n\
    \  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0,\
    \ candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1,\
    \ 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\
    \nFinished in 0.002568059 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    389.40 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpolv_gj6b\nStarted\n.\nFinished in 0.000456579 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2190.20 tests/s, 17521.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2odaco16\nStarted\n.\nFinished in 0.00036131 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2767.71 tests/s, 22141.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp05zl9x7y\nStarted\n.\nFinished in 0.000418256 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2390.88 tests/s, 19127.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpek8z0jop\nStarted\n.\nFinished in 0.000332866 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3004.21 tests/s, 24033.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2qsthi_0\nStarted\n.\nFinished in 0.000314903 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3175.58 tests/s, 25404.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |e| e.abs }.sum * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7z9g7vex\nStarted\n.\nFinished in 0.000385044 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2597.11 tests/s, 20776.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.inject(:*)\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9danl1gk\nStarted\n.\nFinished in 0.000434146 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2303.37 tests/s, 18426.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given an array arr of integers and you need to return\n# sum\
    \ of magnitudes of integers multiplied by product of all signs\n# of each number\
    \ in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n\
    # Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) ==\
    \ 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n\
    \  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
    \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1,\
    \ 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10,\
    \ candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n\
    \    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4,\
    \ candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1,\
    \ 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpllxs51b0\nStarted\n.\nFinished in 0.000371298 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2693.25 tests/s, 21546.04 assertions/s\n"
  exit_code: 0
  status: OK
