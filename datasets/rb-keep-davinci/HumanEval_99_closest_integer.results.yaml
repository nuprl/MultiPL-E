name: HumanEval_99_closest_integer
language: ruby
results:
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpowjrdmsx\nStarted\n.\nFinished in 0.000308359 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3242.97 tests/s, 16214.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpsec0efmu\nStarted\n.\nFinished in 0.000324279 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3083.76 tests/s, 15418.82 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjrfk540v\nStarted\n.\nFinished in 0.000315733 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3167.23 tests/s, 15836.17 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprv1qmc5u\nStarted\n.\nFinished in 0.000339329 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2946.99 tests/s, 14734.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp608i2we_\nStarted\n.\nFinished in 0.000515408 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1940.21 tests/s, 9701.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpa1van7qj\nStarted\n.\nFinished in 0.000305865 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3269.42 tests/s, 16347.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_b_9hi1y\nStarted\n.\nFinished in 0.00032994 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3030.85 tests/s, 15154.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphzs25je2\nStarted\n.\nFinished in 0.000576143 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1735.68 tests/s, 8678.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4ofn1kaj\nStarted\n.\nFinished in 0.000341702 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2926.53 tests/s, 14632.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7mleeaf1\nStarted\n.\nFinished in 0.000298501 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3350.07 tests/s, 16750.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmyosvm42\nStarted\n.\nFinished in 0.000326394 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3063.78 tests/s, 15318.91 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjacfh36w\nStarted\n.\nFinished in 0.000355729 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2811.13 tests/s, 14055.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpr2jgbczu\nStarted\n.\nFinished in 0.000364005 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2747.22 tests/s, 13736.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value.to_i\
    \ == value\n    value.to_i\n  else\n    value.to_i + (value > 0 ? 1 : -1)\n  end\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp0m_lulzk\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp0m_lulzk.rb:29:in `test_closest_integer'\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n     27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n  => 29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n     31:   end\n     32: end\n<15>\
    \ expected but was\n<16>\n\ndiff:\n? 15\n?  6\n===============================================================================\n\
    \nFinished in 0.004945479 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 4 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    202.20 tests/s, 808.82 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp6jo86ua\nStarted\n.\nFinished in 0.000399371 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2503.94 tests/s, 12519.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5dywi8kl\nStarted\n.\nFinished in 0.000353796 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2826.49 tests/s, 14132.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5vlibf22\nStarted\n.\nFinished in 0.000392438 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2548.17 tests/s, 12740.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphrc0t9uz\nStarted\n.\nFinished in 0.000373211 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2679.45 tests/s, 13397.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4d8afqej\nStarted\n.\nFinished in 0.000335131 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2983.91 tests/s, 14919.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpud5xgsve\nStarted\n.\nFinished in 0.000331053 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3020.66 tests/s, 15103.32 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmph6r_cby3\nStarted\n.\nFinished in 0.000337394 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2963.89 tests/s, 14819.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6_a5qhff\nStarted\n.\nFinished in 0.000476175 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2100.07 tests/s, 10500.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmph6lj0nn7\nStarted\n.\nFinished in 0.000664489 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1504.92 tests/s, 7524.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmps59xz0sn\nStarted\n.\nFinished in 0.000389944 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2564.47 tests/s, 12822.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpw7qebyig\nStarted\n.\nFinished in 0.00030267 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3303.93 tests/s, 16519.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu1pa_j_k\nStarted\n.\nFinished in 0.000300014 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3333.18 tests/s, 16665.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpsz8gj9n9\nStarted\n.\nFinished in 0.000559682 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1786.73 tests/s, 8933.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptyszczrl\nStarted\n.\nFinished in 0.000294705 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3393.22 tests/s, 16966.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbw3jt8fg\nStarted\n.\nFinished in 0.000358524 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2789.21 tests/s, 13946.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmp_2148o\nStarted\n.\nFinished in 0.000354647 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2819.71 tests/s, 14098.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpifbmqq3o\nStarted\n.\nFinished in 0.000326524 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3062.56 tests/s, 15312.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzk86bxv6\nStarted\n.\nFinished in 0.000333688 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2996.81 tests/s, 14984.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgpuixd0n\nStarted\n.\nFinished in 0.000451749 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2213.62 tests/s, 11068.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5xixw11k\nStarted\n.\nFinished in 0.000479151 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2087.02 tests/s, 10435.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpd3wibcus\nStarted\n.\nFinished in 0.000341292 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2930.04 tests/s, 14650.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpur2t44gq\nStarted\n.\nFinished in 0.000878363 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1138.48 tests/s, 5692.41 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4z6iyfqe\nStarted\n.\nFinished in 0.000357082 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2800.48 tests/s, 14002.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1irma6c3\nStarted\n.\nFinished in 0.000378662 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2640.88 tests/s, 13204.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyd4o5uvv\nStarted\n.\nFinished in 0.000309672 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3229.22 tests/s, 16146.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcln0_ixi\nStarted\n.\nFinished in 0.000342153 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2922.67 tests/s, 14613.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp86x_w38q\nStarted\n.\nFinished in 0.000365808 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2733.67 tests/s, 13668.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp91llyynf\nStarted\n.\nFinished in 0.000333137 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3001.77 tests/s, 15008.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5_gwexm7\nStarted\n.\nFinished in 0.000319802 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3126.93 tests/s, 15634.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplaegmw1z\nStarted\n.\nFinished in 0.000316937 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3155.20 tests/s, 15776.01 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplt6k0a9l\nStarted\n.\nFinished in 0.000440749 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2268.87 tests/s, 11344.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpsuv36619\nStarted\n.\nFinished in 0.000338266 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2956.25 tests/s, 14781.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7it25xdr\nStarted\n.\nFinished in 0.000516009 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1937.95 tests/s, 9689.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpe_uwwueo\nStarted\n.\nFinished in 0.000331824 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3013.65 tests/s, 15068.23 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6wfevntw\nStarted\n.\nFinished in 0.000344337 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2904.13 tests/s, 14520.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpl5gwj6jb\nStarted\n.\nFinished in 0.000323298 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3093.12 tests/s, 15465.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_o40jjyu\nStarted\n.\nFinished in 0.000299433 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3339.65 tests/s, 16698.23 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgyvuubv_\nStarted\n.\nFinished in 0.000341643 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2927.03 tests/s, 14635.16 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3ymthff8\nStarted\n.\nFinished in 0.000345029 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2898.31 tests/s, 14491.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprm7rk3tc\nStarted\n.\nFinished in 0.000346571 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2885.41 tests/s, 14427.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbqv5y5kw\nStarted\n.\nFinished in 0.000316776 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3156.80 tests/s, 15784.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    return value.to_i\n  elsif value % 1 < 0.5\n    return value.to_i\n\
    \  else\n    return value.to_i + 1\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n\
    \    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"\
    14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15,\
    \ candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\n\
    end\n"
  stdout: "Loaded suite /tmp/tmpsterlrz4\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpsterlrz4.rb:30:in `test_closest_integer'\n\
    \     27:     candidate = method(:closest_integer)\n     28:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     29:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n  => 30:     assert_equal(-16, candidate.call(\"-15.5\"))\n     31:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n     32:     assert_equal(0, candidate.call(\"0\"\
    ))\n     33:   end\n<-16> expected but was\n<-14>\n\ndiff:\n? -16\n?   4\n===============================================================================\n\
    \nFinished in 0.004790107 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    208.76 tests/s, 626.29 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzb8olftc\nStarted\n.\nFinished in 0.000328849 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3040.91 tests/s, 15204.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpko8uqfee\nStarted\n.\nFinished in 0.0003194 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3130.87 tests/s, 15654.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8dqld2qt\nStarted\n.\nFinished in 0.000335993 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2976.25 tests/s, 14881.26 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptui5_saa\nStarted\n.\nFinished in 0.000331613 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3015.56 tests/s, 15077.82 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpq_xffp_q\nStarted\n.\nFinished in 0.000381858 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2618.77 tests/s, 13093.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value.round\
    \ == value\n    value.round\n  else\n    value.round > value ? value.round - 1\
    \ : value.round\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10,\
    \ candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n  \
    \  assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"\
    15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3nyiq3vh\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp3nyiq3vh.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.005436762 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    183.93 tests/s, 367.87 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6uwcqulm\nStarted\n.\nFinished in 0.000370035 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2702.45 tests/s, 13512.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfzr6i9hp\nStarted\n.\nFinished in 0.000349947 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2857.58 tests/s, 14287.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo0j7yueb\nStarted\n.\nFinished in 0.000360267 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2775.72 tests/s, 13878.60 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpd181y6ow\nStarted\n.\nFinished in 0.000352102 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2840.09 tests/s, 14200.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqe_z6s9d\nStarted\n.\nFinished in 0.00032521 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3074.94 tests/s, 15374.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdo_1kk77\nStarted\n.\nFinished in 0.000394112 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2537.35 tests/s, 12686.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ - value.to_i >= 0.5\n    value.ceil\n  else\n    value.floor\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5lwqlsqr\nStarted\n.\nFinished in 0.000551949 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1811.76 tests/s, 9058.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    return value.to_i\n  elsif value % 1 > 0.5\n    return value.ceil\n\
    \  else\n    return value.floor\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n\
    \    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"\
    14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15,\
    \ candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\n\
    end\n"
  stdout: "Loaded suite /tmp/tmpd88o_svs\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpd88o_svs.rb:29:in `test_closest_integer'\n\
    \     26:   def test_closest_integer\n     27:     candidate = method(:closest_integer)\n\
    \     28:     assert_equal(10, candidate.call(\"10\"))\n  => 29:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     30:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     31:     assert_equal(15, candidate.call(\"15.3\"))\n     32: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.004703493 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    212.61 tests/s, 425.22 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpx88ocqij\nStarted\n.\nFinished in 0.000312066 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3204.45 tests/s, 16022.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9c4vp874\nStarted\n.\nFinished in 0.000317397 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3150.63 tests/s, 15753.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpps7v0198\nStarted\n.\nFinished in 0.000383882 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2604.97 tests/s, 13024.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9ji5uxth\nStarted\n.\nFinished in 0.000298632 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3348.60 tests/s, 16743.01 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxzmvqdta\nStarted\n.\nFinished in 0.000374394 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2670.98 tests/s, 13354.91 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp17o3wgdd\nStarted\n.\nFinished in 0.000400423 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2497.36 tests/s, 12486.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnh9csiib\nStarted\n.\nFinished in 0.000317025 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3154.33 tests/s, 15771.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpinbog4c7\nStarted\n.\nFinished in 0.000445469 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2244.83 tests/s, 11224.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwodl1iw9\nStarted\n.\nFinished in 0.000307628 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3250.68 tests/s, 16253.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz44ug0ms\nStarted\n.\nFinished in 0.00033506 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2984.54 tests/s, 14922.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgveiaa6q\nStarted\n.\nFinished in 0.000350349 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2854.30 tests/s, 14271.48 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_pkqlcmr\nStarted\n.\nFinished in 0.000316135 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3163.21 tests/s, 15816.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5d13w349\nStarted\n.\nFinished in 0.000371289 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2693.32 tests/s, 13466.60 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpss6rqbft\nStarted\n.\nFinished in 0.000341181 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2931.00 tests/s, 14654.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwbvbxygy\nStarted\n.\nFinished in 0.000349467 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2861.50 tests/s, 14307.50 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp31c80xz3\nStarted\n.\nFinished in 0.000345269 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2896.29 tests/s, 14481.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6k3sh1pp\nStarted\n.\nFinished in 0.000332275 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3009.56 tests/s, 15047.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpip1i0b4x\nStarted\n.\nFinished in 0.000390564 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2560.40 tests/s, 12802.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpowglgvp5\nStarted\n.\nFinished in 0.000316025 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3164.31 tests/s, 15821.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvqa5bdu2\nStarted\n.\nFinished in 0.000314622 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3178.42 tests/s, 15892.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp10cv8020\nStarted\n.\nFinished in 0.000395774 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2526.69 tests/s, 12633.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpw1jbjhlj\nStarted\n.\nFinished in 0.000343636 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2910.06 tests/s, 14550.28 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz7ks689z\nStarted\n.\nFinished in 0.000339489 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2945.60 tests/s, 14728.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7fbqybrz\nStarted\n.\nFinished in 0.000450797 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2218.29 tests/s, 11091.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqhvgqylc\nStarted\n.\nFinished in 0.00037733 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2650.20 tests/s, 13251.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8b_hzdfz\nStarted\n.\nFinished in 0.000365016 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2739.61 tests/s, 13698.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpq201en53\nStarted\n.\nFinished in 0.00048904 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2044.82 tests/s, 10224.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3opojbjp\nStarted\n.\nFinished in 0.000397939 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2512.95 tests/s, 12564.74 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0bqjhmtf\nStarted\n.\nFinished in 0.000302579 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3304.92 tests/s, 16524.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjezhfxph\nStarted\n.\nFinished in 0.00035143 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2845.52 tests/s, 14227.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkszkwh9i\nStarted\n.\nFinished in 0.000325823 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3069.15 tests/s, 15345.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpt4_t18tp\nStarted\n.\nFinished in 0.000311366 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3211.65 tests/s, 16058.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcfnigrkn\nStarted\n.\nFinished in 0.00033011 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3029.29 tests/s, 15146.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpi5hzvjx6\nStarted\n.\nFinished in 0.000345869 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2891.27 tests/s, 14456.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ - value.to_i >= 0.5\n    value.to_i + 1\n  else\n    value.to_i\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4xy5jr5r\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp4xy5jr5r.rb:28:in `test_closest_integer'\n\
    \     25:     candidate = method(:closest_integer)\n     26:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     27:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n  => 28:     assert_equal(-16, candidate.call(\"-15.5\"))\n     29:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n     30:     assert_equal(0, candidate.call(\"0\"\
    ))\n     31:   end\n<-16> expected but was\n<-15>\n\ndiff:\n? -16\n?   5\n===============================================================================\n\
    \nFinished in 0.006050456 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    165.28 tests/s, 495.83 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbd0cjphu\nStarted\n.\nFinished in 0.000346271 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2887.91 tests/s, 14439.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqtqgakav\nStarted\n.\nFinished in 0.000426071 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2347.03 tests/s, 11735.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpk1d9z332\nStarted\n.\nFinished in 0.000336453 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2972.18 tests/s, 14860.92 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkbl3va_1\nStarted\n.\nFinished in 0.000348506 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2869.39 tests/s, 14346.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1xmxkmoh\nStarted\n.\nFinished in 0.000304011 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3289.35 tests/s, 16446.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpd7cupvpn\nStarted\n.\nFinished in 0.000314941 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3175.20 tests/s, 15875.99 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpufxx_j1u\nStarted\n.\nFinished in 0.000333918 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2994.75 tests/s, 14973.74 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpde0nwqo2\nStarted\n.\nFinished in 0.000340551 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2936.42 tests/s, 14682.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfhl8av7o\nStarted\n.\nFinished in 0.000334419 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2990.26 tests/s, 14951.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpf3jpg1k_\nStarted\n.\nFinished in 0.000310744 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3218.08 tests/s, 16090.42 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6dpex0e_\nStarted\n.\nFinished in 0.000378021 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2645.36 tests/s, 13226.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppufrx557\nStarted\n.\nFinished in 0.000420981 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2375.40 tests/s, 11877.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwjgs7bzv\nStarted\n.\nFinished in 0.000314903 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3175.58 tests/s, 15877.91 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpijzi5ty5\nStarted\n.\nFinished in 0.000375847 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2660.66 tests/s, 13303.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpys46g8ms\nStarted\n.\nFinished in 0.000389783 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2565.53 tests/s, 12827.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp906oownt\nStarted\n.\nFinished in 0.000351401 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2845.75 tests/s, 14228.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnif_u36x\nStarted\n.\nFinished in 0.000333868 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2995.20 tests/s, 14975.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyvwy1xtj\nStarted\n.\nFinished in 0.00030342 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3295.76 tests/s, 16478.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpktrjpu7u\nStarted\n.\nFinished in 0.000320763 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3117.57 tests/s, 15587.83 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvsuu3p2d\nStarted\n.\nFinished in 0.000321335 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3112.02 tests/s, 15560.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkr0ibb2i\nStarted\n.\nFinished in 0.000581763 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1718.91 tests/s, 8594.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzq5qq9v1\nStarted\n.\nFinished in 0.000317737 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3147.26 tests/s, 15736.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyj4152x0\nStarted\n.\nFinished in 0.000334579 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2988.83 tests/s, 14944.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value < 0 ? value.ceil : value.floor\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10,\
    \ candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n  \
    \  assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"\
    15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmphgzmmn69\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmphgzmmn69.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.004992527 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    200.30 tests/s, 400.60 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpixk_v6h8\nStarted\n.\nFinished in 0.000374204 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2672.34 tests/s, 13361.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfisxnupk\nStarted\n.\nFinished in 0.000322076 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3104.86 tests/s, 15524.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphez_7lw4\nStarted\n.\nFinished in 0.000346391 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2886.91 tests/s, 14434.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpakkyzb2k\nStarted\n.\nFinished in 0.000349977 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2857.33 tests/s, 14286.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8iv0fs_6\nStarted\n.\nFinished in 0.000338326 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2955.73 tests/s, 14778.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9wza99hb\nStarted\n.\nFinished in 0.000310965 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3215.80 tests/s, 16078.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdr6709q4\nStarted\n.\nFinished in 0.000318758 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3137.18 tests/s, 15685.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdrhkaqgc\nStarted\n.\nFinished in 0.000318198 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3142.70 tests/s, 15713.49 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpofuxq65f\nStarted\n.\nFinished in 0.000333197 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3001.23 tests/s, 15006.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzbpqoft5\nStarted\n.\nFinished in 0.00033482 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2986.68 tests/s, 14933.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpw8_hk471\nStarted\n.\nFinished in 0.000418567 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2389.10 tests/s, 11945.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9qelxtdl\nStarted\n.\nFinished in 0.000339799 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2942.92 tests/s, 14714.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ == value.to_i\n    value.to_i\n  elsif value > value.to_i\n    value.to_i +\
    \ 1\n  else\n    value.to_i - 1\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n\
    \    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"\
    14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15,\
    \ candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\n\
    end\n"
  stdout: "Loaded suite /tmp/tmp_owsbd_6\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp_owsbd_6.rb:31:in `test_closest_integer'\n\
    \     28:     assert_equal(10, candidate.call(\"10\"))\n     29:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     30:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n  => 31:     assert_equal(15, candidate.call(\"15.3\"))\n     32: \
    \    assert_equal(0, candidate.call(\"0\"))\n     33:   end\n     34: end\n<15>\
    \ expected but was\n<16>\n\ndiff:\n? 15\n?  6\n===============================================================================\n\
    \nFinished in 0.005665322 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 4 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    176.51 tests/s, 706.05 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz4ueuib9\nStarted\n.\nFinished in 0.000359897 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2778.57 tests/s, 13892.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptc6a31op\nStarted\n.\nFinished in 0.000320052 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3124.49 tests/s, 15622.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjiqyv34m\nStarted\n.\nFinished in 0.000322527 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3100.52 tests/s, 15502.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpomq5citn\nStarted\n.\nFinished in 0.000350038 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2856.83 tests/s, 14284.16 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphmv4i4wy\nStarted\n.\nFinished in 0.000363543 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2750.71 tests/s, 13753.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 >= 0.5\n    value.ceil\n  else\n    value.floor\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpdhl9ad7f\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpdhl9ad7f.rb:28:in `test_closest_integer'\n\
    \     25:     candidate = method(:closest_integer)\n     26:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     27:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n  => 28:     assert_equal(-16, candidate.call(\"-15.5\"))\n     29:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n     30:     assert_equal(0, candidate.call(\"0\"\
    ))\n     31:   end\n<-16> expected but was\n<-15>\n\ndiff:\n? -16\n?   5\n===============================================================================\n\
    \nFinished in 0.005620538 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    177.92 tests/s, 533.76 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo7rlc55a\nStarted\n.\nFinished in 0.000318809 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3136.67 tests/s, 15683.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpsz3vn2z1\nStarted\n.\nFinished in 0.000328789 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3041.46 tests/s, 15207.32 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu2fxvtgd\nStarted\n.\nFinished in 0.000333447 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2998.98 tests/s, 14994.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8lo3vslm\nStarted\n.\nFinished in 0.000334769 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2987.13 tests/s, 14935.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpy4gelfzi\nStarted\n.\nFinished in 0.000338156 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2957.22 tests/s, 14786.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyfrv_xoy\nStarted\n.\nFinished in 0.00031926 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3132.24 tests/s, 15661.22 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  # your code here\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpj6v7ie8s\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpj6v7ie8s.rb:21:in `test_closest_integer'\n\
    \     18: class TestHumanEval < Test::Unit::TestCase\n     19:   def test_closest_integer\n\
    \     20:     candidate = method(:closest_integer)\n  => 21:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     22:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n     23:     assert_equal(-16, candidate.call(\"-15.5\"))\n     24:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n<10> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.004551277 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    219.72 tests/s, 219.72 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpinymblqd\nStarted\n.\nFinished in 0.000465415 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2148.62 tests/s, 10743.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4u8hyzdj\nStarted\n.\nFinished in 0.000341713 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2926.43 tests/s, 14632.16 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7ygsfc59\nStarted\n.\nFinished in 0.000309611 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3229.86 tests/s, 16149.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpk8yeo5hj\nStarted\n.\nFinished in 0.000337243 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2965.22 tests/s, 14826.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpd4t9r1aq\nStarted\n.\nFinished in 0.000330271 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3027.82 tests/s, 15139.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcvkfjdi8\nStarted\n.\nFinished in 0.00033563 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2979.47 tests/s, 14897.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptv5tszfw\nStarted\n.\nFinished in 0.000345289 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2896.12 tests/s, 14480.62 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxfcj24d9\nStarted\n.\nFinished in 0.000349868 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2858.22 tests/s, 14291.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2o8gfwtd\nStarted\n.\nFinished in 0.00036134 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2767.48 tests/s, 13837.38 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc_xfih0z\nStarted\n.\nFinished in 0.000649942 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1538.60 tests/s, 7692.99 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbsr9is8x\nStarted\n.\nFinished in 0.000342534 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2919.42 tests/s, 14597.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmper66bkel\nStarted\n.\nFinished in 0.000343096 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2914.64 tests/s, 14573.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplj_dxghq\nStarted\n.\nFinished in 0.00046761 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2138.53 tests/s, 10692.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ - value.to_i > 0.5\n    value.to_i + 1\n  else\n    value.to_i\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfbsjujyg\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpfbsjujyg.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.007107484 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    140.70 tests/s, 281.39 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  # Your code here\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7ne8toeh\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp7ne8toeh.rb:21:in `test_closest_integer'\n\
    \     18: class TestHumanEval < Test::Unit::TestCase\n     19:   def test_closest_integer\n\
    \     20:     candidate = method(:closest_integer)\n  => 21:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     22:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n     23:     assert_equal(-16, candidate.call(\"-15.5\"))\n     24:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n<10> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005849118 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    170.97 tests/s, 170.97 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpiae4f676\nStarted\n.\nFinished in 0.000401836 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2488.58 tests/s, 12442.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0xq0ys3f\nStarted\n.\nFinished in 0.000353755 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2826.82 tests/s, 14134.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6d0an3vr\nStarted\n.\nFinished in 0.000424809 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2354.00 tests/s, 11770.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpll025qou\nStarted\n.\nFinished in 0.000354276 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2822.66 tests/s, 14113.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkckquppp\nStarted\n.\nFinished in 0.000348075 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2872.94 tests/s, 14364.72 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 >= 0.5\n    value = value.ceil\n  else\n    value = value.floor\n  end\n\
    \  value\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10,\
    \ candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n  \
    \  assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"\
    15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjrds41s4\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpjrds41s4.rb:29:in `test_closest_integer'\n\
    \     26:     candidate = method(:closest_integer)\n     27:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     28:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n  => 29:     assert_equal(-16, candidate.call(\"-15.5\"))\n     30:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n     31:     assert_equal(0, candidate.call(\"0\"\
    ))\n     32:   end\n<-16> expected but was\n<-15>\n\ndiff:\n? -16\n?   5\n===============================================================================\n\
    \nFinished in 0.004808131 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    207.98 tests/s, 623.94 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpw4pymlkl\nStarted\n.\nFinished in 0.000343296 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2912.94 tests/s, 14564.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpl2aweiye\nStarted\n.\nFinished in 0.000376117 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2658.75 tests/s, 13293.74 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value\n  elsif value % 1 > 0.5\n    value.ceil\n  else\n    value.floor\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10,\
    \ candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n  \
    \  assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"\
    15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpm405vpdn\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpm405vpdn.rb:29:in `test_closest_integer'\n\
    \     26:   def test_closest_integer\n     27:     candidate = method(:closest_integer)\n\
    \     28:     assert_equal(10, candidate.call(\"10\"))\n  => 29:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     30:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     31:     assert_equal(15, candidate.call(\"15.3\"))\n     32: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.004660553 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    214.57 tests/s, 429.13 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkpes02pq\nStarted\n.\nFinished in 0.000348265 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2871.38 tests/s, 14356.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppy6g4up4\nStarted\n.\nFinished in 0.000328718 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3042.12 tests/s, 15210.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ < 0\n    value = value.ceil\n  else\n    value = value.floor\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpulono7yk\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpulono7yk.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.004861772 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    205.69 tests/s, 411.37 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppecmfgqr\nStarted\n.\nFinished in 0.000336382 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2972.81 tests/s, 14864.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpivtho_t9\nStarted\n.\nFinished in 0.000327075 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3057.40 tests/s, 15287.01 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpneh36u27\nStarted\n.\nFinished in 0.000348405 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2870.22 tests/s, 14351.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmotg20b_\nStarted\n.\nFinished in 0.000322036 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3105.24 tests/s, 15526.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpuzrt23v1\nStarted\n.\nFinished in 0.000312027 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3204.85 tests/s, 16024.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpup0tx8le\nStarted\n.\nFinished in 0.00043608 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2293.16 tests/s, 11465.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplzy338gr\nStarted\n.\nFinished in 0.000366709 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2726.96 tests/s, 13634.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_21j5oya\nStarted\n.\nFinished in 0.000454755 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2198.99 tests/s, 10994.93 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value.round\
    \ == value\n    value.round\n  else\n    value.round(1)\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmphfypc212\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmphfypc212.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14.5>\n\n\
    diff:\n? 14.5\n===============================================================================\n\
    \nFinished in 0.004572889 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    218.68 tests/s, 437.36 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc4e4vivd\nStarted\n.\nFinished in 0.000408358 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2448.83 tests/s, 12244.16 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6aseogdq\nStarted\n.\nFinished in 0.000446039 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2241.96 tests/s, 11209.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppeeieglp\nStarted\n.\nFinished in 0.000314411 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3180.55 tests/s, 15902.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpv3j1g39_\nStarted\n.\nFinished in 0.000360698 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2772.40 tests/s, 13862.01 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpt4bxb65n\nStarted\n.\nFinished in 0.000322787 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3098.02 tests/s, 15490.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpumpe2ndk\nStarted\n.\nFinished in 0.000383351 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2608.58 tests/s, 13042.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbn49ib6w\nStarted\n.\nFinished in 0.00030284 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3302.07 tests/s, 16510.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpd_06veb3\nStarted\n.\nFinished in 0.00029765 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3359.65 tests/s, 16798.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpj473wxvq\nStarted\n.\nFinished in 0.000282751 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    3536.68 tests/s, 17683.40 assertions/s\n"
  exit_code: 0
  status: OK
